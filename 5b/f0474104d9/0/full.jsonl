{"type":"file-history-snapshot","messageId":"419d76bc-01da-47ab-8292-f6cf09dd2274","snapshot":{"messageId":"419d76bc-01da-47ab-8292-f6cf09dd2274","trackedFileBackups":{},"timestamp":"2026-02-10T23:20:18.621Z"},"isSnapshotUpdate":false}
{"parentUuid":null,"isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"progress","data":{"type":"hook_progress","hookEvent":"SessionStart","hookName":"SessionStart:clear","command":"entire hooks claude-code session-start"},"parentToolUseID":"4d287c94-cd4e-4666-930d-030ccbfbc10f","toolUseID":"4d287c94-cd4e-4666-930d-030ccbfbc10f","timestamp":"2026-02-10T23:20:18.438Z","uuid":"f01f7b55-4b3f-4716-8fbd-eb6e7ddc399e"}
{"parentUuid":"f01f7b55-4b3f-4716-8fbd-eb6e7ddc399e","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"user","message":{"role":"user","content":"Implement the following plan:\n\n# Plan: Add SSM & Secrets Manager to CDK mode CloudFormation parsing and auto-creation\n\n## Context\n\nSSM Parameter Store and Secrets Manager providers are already implemented and working in Terraform mode (where `tofu apply` creates resources via API). However, in CDK mode, LDK parses the CloudFormation template to auto-create resources on startup — and the parser doesn't know about `AWS::SSM::Parameter` or `AWS::SecretsManager::Secret` yet. This means CDK projects that define SSM parameters or secrets (like the sample-project) fail at runtime because the Lambda functions can't find those resources.\n\nAdditionally, the `create_ssm_app()` and `create_secretsmanager_app()` factory functions currently accept no initial state — they always start empty. We need them to accept pre-seeded resources.\n\n## Files to modify\n\n### 1. `src/lws/parser/assembly.py` — Add dataclasses and collectors\n\n**Add dataclasses** (after `CognitoUserPool`, before `AppModel`):\n```python\n@dataclass\nclass SsmParameter:\n    name: str\n    type: str          # \"String\", \"StringList\", \"SecureString\"\n    value: str\n    description: str = \"\"\n\n@dataclass\nclass SmSecret:\n    name: str\n    description: str = \"\"\n    secret_string: str | None = None  # from SecretString or GenerateSecretString template\n```\n\n**Add fields to `AppModel`**:\n```python\nssm_parameters: list[SsmParameter] = field(default_factory=list)\nsecrets: list[SmSecret] = field(default_factory=list)\n```\n\n**Add collector functions**:\n- `_collect_ssm_parameters(resources, resolver)` — filter `AWS::SSM::Parameter`, extract Name, Type, Value, Description\n- `_collect_secrets(resources, resolver)` — filter `AWS::SecretsManager::Secret`, extract Name, Description, and SecretString (or `SecretStringTemplate` from `GenerateSecretString`)\n\n**Add to `_process_stack()`**:\n```python\nmodel.ssm_parameters.extend(_collect_ssm_parameters(resources, resolver))\nmodel.secrets.extend(_collect_secrets(resources, resolver))\n```\n\n**Add to `_build_resource_map()`** — SSM Ref returns the parameter name, Secrets Manager Ref returns the secret ARN:\n```python\nelif r.resource_type == \"AWS::SSM::Parameter\":\n    name = r.properties.get(\"Name\", r.logical_id)\n    resource_map[r.logical_id] = name\nelif r.resource_type == \"AWS::SecretsManager::Secret\":\n    name = r.properties.get(\"Name\", r.logical_id)\n    resource_map[r.logical_id] = f\"arn:aws:secretsmanager:us-east-1:000000000000:secret:{name}\"\n```\n\n### 2. `src/lws/parser/tree_parser.py` — Add FQN mappings\n\nAdd to `FQN_CATEGORY_MAP`:\n```python\n\"aws-cdk-lib.aws_ssm.StringParameter\": \"ssm\",\n\"aws-cdk-lib.aws_secretsmanager.Secret\": \"secretsmanager\",\n```\n\n### 3. `src/lws/providers/ssm/routes.py` — Accept initial parameters\n\nChange `create_ssm_app()` signature to accept optional initial parameters:\n```python\ndef create_ssm_app(initial_parameters: list[dict] | None = None) -> FastAPI:\n```\nAfter creating `state = _SsmState()`, seed it with initial parameters by creating `_Parameter` objects for each entry.\n\n### 4. `src/lws/providers/secretsmanager/routes.py` — Accept initial secrets\n\nChange `create_secretsmanager_app()` signature to accept optional initial secrets:\n```python\ndef create_secretsmanager_app(initial_secrets: list[dict] | None = None) -> FastAPI:\n```\nAfter creating `state = _SecretsState()`, seed it with initial secrets by creating `_Secret` and `_SecretVersion` objects for each entry.\n\n### 5. `src/lws/cli/ldk.py` — Pass parsed resources to providers in CDK mode\n\nIn `_create_providers()` (CDK mode), where SSM and SecretsManager HTTP providers are created (step 9), pass the AppModel data:\n\n```python\nssm_params = [{\"name\": p.name, \"type\": p.type, \"value\": p.value, \"description\": p.description}\n              for p in app_model.ssm_parameters]\nsm_secrets = [{\"name\": s.name, \"description\": s.description, \"secret_string\": s.secret_string}\n              for s in app_model.secrets]\n\nproviders[\"__ssm_http__\"] = _HttpServiceProvider(\n    \"ssm-http\", lambda: create_ssm_app(ssm_params), ssm_port\n)\nproviders[\"__secretsmanager_http__\"] = _HttpServiceProvider(\n    \"secretsmanager-http\", lambda: create_secretsmanager_app(sm_secrets), secretsmanager_port\n)\n```\n\n### 6. `src/lws/cli/ldk.py` — Add display details\n\nIn `_collect_extra_resources()`, add:\n```python\n\"ssm_parameters\": (\"name\", \"ssm_parameters\"),\n\"secrets\": (\"name\", \"secrets\"),\n```\n\nIn `_add_resource_details()`, add:\n```python\nfor p in app_model.ssm_parameters:\n    details[f\"Parameter:{p.name}\"] = f\"lws ssm get-parameter --name {p.name}\"\nfor s in app_model.secrets:\n    details[f\"Secret:{s.name}\"] = f\"lws secretsmanager get-secret-value --secret-id {s.name}\"\n```\n\n## Verification\n\n```bash\n# 1. Unit tests\ncd /Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services\nuv run python -m pytest tests/ -x -q\n\n# 2. Lint\nuvx ruff check src tests\n\n# 3. CDK sample E2E\ncd /Users/eamonnfaherty/Development/github.com/local-web-services/sample-project\nnpx cdk synth\nldk dev &  # wait for startup — should show Parameter and Secret in resource table\nbash test-orders.sh  # workflow should SUCCEED with SSM and SecretsManager calls working\n\n# 4. Terraform sample E2E (should still work — no changes to terraform mode)\ncd /Users/eamonnfaherty/Development/github.com/local-web-services/sample-project-terraform\nldk dev --mode terraform &\ntofu apply -auto-approve\nbash test-orders.sh\n```\n\n\nIf you need specific details from before exiting plan mode (like exact code snippets, error messages, or content you generated), read the full transcript at: /Users/eamonnfaherty/.REDACTED.jsonl"},"uuid":"419d76bc-01da-47ab-8292-f6cf09dd2274","timestamp":"2026-02-10T23:20:18.049Z","planContent":"# Plan: Add SSM & Secrets Manager to CDK mode CloudFormation parsing and auto-creation\n\n## Context\n\nSSM Parameter Store and Secrets Manager providers are already implemented and working in Terraform mode (where `tofu apply` creates resources via API). However, in CDK mode, LDK parses the CloudFormation template to auto-create resources on startup — and the parser doesn't know about `AWS::SSM::Parameter` or `AWS::SecretsManager::Secret` yet. This means CDK projects that define SSM parameters or secrets (like the sample-project) fail at runtime because the Lambda functions can't find those resources.\n\nAdditionally, the `create_ssm_app()` and `create_secretsmanager_app()` factory functions currently accept no initial state — they always start empty. We need them to accept pre-seeded resources.\n\n## Files to modify\n\n### 1. `src/lws/parser/assembly.py` — Add dataclasses and collectors\n\n**Add dataclasses** (after `CognitoUserPool`, before `AppModel`):\n```python\n@dataclass\nclass SsmParameter:\n    name: str\n    type: str          # \"String\", \"StringList\", \"SecureString\"\n    value: str\n    description: str = \"\"\n\n@dataclass\nclass SmSecret:\n    name: str\n    description: str = \"\"\n    secret_string: str | None = None  # from SecretString or GenerateSecretString template\n```\n\n**Add fields to `AppModel`**:\n```python\nssm_parameters: list[SsmParameter] = field(default_factory=list)\nsecrets: list[SmSecret] = field(default_factory=list)\n```\n\n**Add collector functions**:\n- `_collect_ssm_parameters(resources, resolver)` — filter `AWS::SSM::Parameter`, extract Name, Type, Value, Description\n- `_collect_secrets(resources, resolver)` — filter `AWS::SecretsManager::Secret`, extract Name, Description, and SecretString (or `SecretStringTemplate` from `GenerateSecretString`)\n\n**Add to `_process_stack()`**:\n```python\nmodel.ssm_parameters.extend(_collect_ssm_parameters(resources, resolver))\nmodel.secrets.extend(_collect_secrets(resources, resolver))\n```\n\n**Add to `_build_resource_map()`** — SSM Ref returns the parameter name, Secrets Manager Ref returns the secret ARN:\n```python\nelif r.resource_type == \"AWS::SSM::Parameter\":\n    name = r.properties.get(\"Name\", r.logical_id)\n    resource_map[r.logical_id] = name\nelif r.resource_type == \"AWS::SecretsManager::Secret\":\n    name = r.properties.get(\"Name\", r.logical_id)\n    resource_map[r.logical_id] = f\"arn:aws:secretsmanager:us-east-1:000000000000:secret:{name}\"\n```\n\n### 2. `src/lws/parser/tree_parser.py` — Add FQN mappings\n\nAdd to `FQN_CATEGORY_MAP`:\n```python\n\"aws-cdk-lib.aws_ssm.StringParameter\": \"ssm\",\n\"aws-cdk-lib.aws_secretsmanager.Secret\": \"secretsmanager\",\n```\n\n### 3. `src/lws/providers/ssm/routes.py` — Accept initial parameters\n\nChange `create_ssm_app()` signature to accept optional initial parameters:\n```python\ndef create_ssm_app(initial_parameters: list[dict] | None = None) -> FastAPI:\n```\nAfter creating `state = _SsmState()`, seed it with initial parameters by creating `_Parameter` objects for each entry.\n\n### 4. `src/lws/providers/secretsmanager/routes.py` — Accept initial secrets\n\nChange `create_secretsmanager_app()` signature to accept optional initial secrets:\n```python\ndef create_secretsmanager_app(initial_secrets: list[dict] | None = None) -> FastAPI:\n```\nAfter creating `state = _SecretsState()`, seed it with initial secrets by creating `_Secret` and `_SecretVersion` objects for each entry.\n\n### 5. `src/lws/cli/ldk.py` — Pass parsed resources to providers in CDK mode\n\nIn `_create_providers()` (CDK mode), where SSM and SecretsManager HTTP providers are created (step 9), pass the AppModel data:\n\n```python\nssm_params = [{\"name\": p.name, \"type\": p.type, \"value\": p.value, \"description\": p.description}\n              for p in app_model.ssm_parameters]\nsm_secrets = [{\"name\": s.name, \"description\": s.description, \"secret_string\": s.secret_string}\n              for s in app_model.secrets]\n\nproviders[\"__ssm_http__\"] = _HttpServiceProvider(\n    \"ssm-http\", lambda: create_ssm_app(ssm_params), ssm_port\n)\nproviders[\"__secretsmanager_http__\"] = _HttpServiceProvider(\n    \"secretsmanager-http\", lambda: create_secretsmanager_app(sm_secrets), secretsmanager_port\n)\n```\n\n### 6. `src/lws/cli/ldk.py` — Add display details\n\nIn `_collect_extra_resources()`, add:\n```python\n\"ssm_parameters\": (\"name\", \"ssm_parameters\"),\n\"secrets\": (\"name\", \"secrets\"),\n```\n\nIn `_add_resource_details()`, add:\n```python\nfor p in app_model.ssm_parameters:\n    details[f\"Parameter:{p.name}\"] = f\"lws ssm get-parameter --name {p.name}\"\nfor s in app_model.secrets:\n    details[f\"Secret:{s.name}\"] = f\"lws secretsmanager get-secret-value --secret-id {s.name}\"\n```\n\n## Verification\n\n```bash\n# 1. Unit tests\ncd /Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services\nuv run python -m pytest tests/ -x -q\n\n# 2. Lint\nuvx ruff check src tests\n\n# 3. CDK sample E2E\ncd /Users/eamonnfaherty/Development/github.com/local-web-services/sample-project\nnpx cdk synth\nldk dev &  # wait for startup — should show Parameter and Secret in resource table\nbash test-orders.sh  # workflow should SUCCEED with SSM and SecretsManager calls working\n\n# 4. Terraform sample E2E (should still work — no changes to terraform mode)\ncd /Users/eamonnfaherty/Development/github.com/local-web-services/sample-project-terraform\nldk dev --mode terraform &\ntofu apply -auto-approve\nbash test-orders.sh\n```\n"}
{"parentUuid":"419d76bc-01da-47ab-8292-f6cf09dd2274","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","message":{"model":"claude-opus-4-6","id":"msg_01Rc6hbAU62CYKRBiSnJcYAj","type":"message","role":"assistant","content":[{"type":"text","text":"\n\nI'll start by reading the key files that need to be modified to understand the current state of the code."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":5553,"cache_read_input_tokens":15470,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":5553},"output_tokens":2,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CY1FCABup89maXRijdjwj","type":"assistant","uuid":"ec8b1f74-8981-4989-a07f-ecd1dc465a62","timestamp":"2026-02-10T23:20:21.512Z"}
{"parentUuid":"ec8b1f74-8981-4989-a07f-ecd1dc465a62","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","message":{"model":"claude-opus-4-6","id":"msg_01Rc6hbAU62CYKRBiSnJcYAj","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01G4trMfDkkaBdNrKVV8tjeP","name":"Read","input":{"file_path":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services/src/lws/parser/assembly.py"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":5553,"cache_read_input_tokens":15470,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":5553},"output_tokens":2,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CY1FCABup89maXRijdjwj","type":"assistant","uuid":"79d75a2c-4ccb-4a1b-88ff-2358b1d14616","timestamp":"2026-02-10T23:20:22.124Z"}
{"parentUuid":"79d75a2c-4ccb-4a1b-88ff-2358b1d14616","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"callback"},"parentToolUseID":"toolu_01G4trMfDkkaBdNrKVV8tjeP","toolUseID":"toolu_01G4trMfDkkaBdNrKVV8tjeP","timestamp":"2026-02-10T23:20:22.131Z","uuid":"4ec75cf8-5e07-43f9-a031-f0ed84c3e850"}
{"parentUuid":"79d75a2c-4ccb-4a1b-88ff-2358b1d14616","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01G4trMfDkkaBdNrKVV8tjeP","type":"tool_result","content":"     1→\"\"\"Assembly orchestrator -- top-level entry point for CDK output parsing.\n     2→\n     3→Ties together tree parsing, template parsing, reference resolution and\n     4→asset location to produce a single ``AppModel`` that the rest of the\n     5→system can consume.\n     6→\"\"\"\n     7→\n     8→from __future__ import annotations\n     9→\n    10→import json\n    11→import logging\n    12→from dataclasses import dataclass, field\n    13→from pathlib import Path\n    14→from typing import Any\n    15→\n    16→from lws.parser.asset_parser import parse_assets\n    17→from lws.parser.ref_resolver import RefResolver\n    18→from lws.parser.template_parser import (\n    19→    CfnResource,\n    20→    extract_api_routes,\n    21→    extract_dynamo_tables,\n    22→    extract_lambda_functions,\n    23→    parse_template,\n    24→)\n    25→from lws.parser.tree_parser import parse_tree\n    26→\n    27→logger = logging.getLogger(__name__)\n    28→\n    29→# ---------------------------------------------------------------------------\n    30→# Domain model dataclasses\n    31→# ---------------------------------------------------------------------------\n    32→\n    33→\n    34→@dataclass\n    35→class LambdaFunction:\n    36→    \"\"\"Parsed Lambda function ready for local execution.\"\"\"\n    37→\n    38→    name: str\n    39→    handler: str\n    40→    runtime: str\n    41→    code_path: Path | None = None\n    42→    timeout: int = 30\n    43→    memory: int = 128\n    44→    environment: dict[str, str] = field(default_factory=dict)\n    45→\n    46→    @property\n    47→    def logical_id(self) -> str:\n    48→        return self.name\n    49→\n    50→\n    51→@dataclass\n    52→class DynamoTable:\n    53→    \"\"\"Parsed DynamoDB table definition.\"\"\"\n    54→\n    55→    name: str\n    56→    key_schema: list[dict[str, str]] = field(default_factory=list)\n    57→    gsi_definitions: list[dict[str, Any]] = field(default_factory=list)\n    58→\n    59→    @property\n    60→    def logical_id(self) -> str:\n    61→        return self.name\n    62→\n    63→    @property\n    64→    def table_name(self) -> str:\n    65→        return self.name\n    66→\n    67→\n    68→@dataclass\n    69→class ApiRoute:\n    70→    \"\"\"A single API Gateway route.\"\"\"\n    71→\n    72→    method: str\n    73→    path: str\n    74→    handler_name: str | None = None\n    75→\n    76→\n    77→@dataclass\n    78→class ApiDefinition:\n    79→    \"\"\"A collection of routes making up an API.\"\"\"\n    80→\n    81→    name: str = \"default\"\n    82→    routes: list[ApiRoute] = field(default_factory=list)\n    83→\n    84→    @property\n    85→    def logical_id(self) -> str:\n    86→        return self.name\n    87→\n    88→\n    89→@dataclass\n    90→class SqsQueue:\n    91→    \"\"\"Parsed SQS queue definition.\"\"\"\n    92→\n    93→    name: str\n    94→    is_fifo: bool = False\n    95→    visibility_timeout: int = 30\n    96→    content_based_dedup: bool = False\n    97→    redrive_target: str | None = None\n    98→    max_receive_count: int = 5\n    99→\n   100→\n   101→@dataclass\n   102→class S3Bucket:\n   103→    \"\"\"Parsed S3 bucket definition.\"\"\"\n   104→\n   105→    name: str\n   106→\n   107→\n   108→@dataclass\n   109→class SnsTopic:\n   110→    \"\"\"Parsed SNS topic definition.\"\"\"\n   111→\n   112→    name: str\n   113→    topic_arn: str = \"\"\n   114→\n   115→\n   116→@dataclass\n   117→class EventBus:\n   118→    \"\"\"Parsed EventBridge event bus definition.\"\"\"\n   119→\n   120→    name: str\n   121→    bus_arn: str = \"\"\n   122→\n   123→\n   124→@dataclass\n   125→class EventRule:\n   126→    \"\"\"Parsed EventBridge rule definition.\"\"\"\n   127→\n   128→    rule_name: str\n   129→    event_bus_name: str = \"default\"\n   130→    event_pattern: dict[str, Any] | None = None\n   131→    schedule_expression: str | None = None\n   132→    targets: list[dict[str, Any]] = field(default_factory=list)\n   133→\n   134→\n   135→@dataclass\n   136→class StateMachine:\n   137→    \"\"\"Parsed Step Functions state machine definition.\"\"\"\n   138→\n   139→    name: str\n   140→    definition: str | dict[str, Any] = \"\"\n   141→    workflow_type: str = \"STANDARD\"\n   142→    role_arn: str = \"\"\n   143→    definition_substitutions: dict[str, str] = field(default_factory=dict)\n   144→\n   145→\n   146→@dataclass\n   147→class CognitoUserPool:\n   148→    \"\"\"Parsed Cognito user pool definition.\"\"\"\n   149→\n   150→    logical_id: str\n   151→    user_pool_name: str = \"default\"\n   152→    auto_confirm: bool = True\n   153→    password_policy: dict[str, Any] = field(default_factory=dict)\n   154→    pre_auth_trigger: str | None = None\n   155→    post_confirm_trigger: str | None = None\n   156→    client_id: str = \"\"\n   157→\n   158→\n   159→@dataclass\n   160→class AppModel:\n   161→    \"\"\"Complete parsed representation of a CDK application.\"\"\"\n   162→\n   163→    functions: list[LambdaFunction] = field(default_factory=list)\n   164→    tables: list[DynamoTable] = field(default_factory=list)\n   165→    apis: list[ApiDefinition] = field(default_factory=list)\n   166→    queues: list[SqsQueue] = field(default_factory=list)\n   167→    buckets: list[S3Bucket] = field(default_factory=list)\n   168→    topics: list[SnsTopic] = field(default_factory=list)\n   169→    event_buses: list[EventBus] = field(default_factory=list)\n   170→    event_rules: list[EventRule] = field(default_factory=list)\n   171→    state_machines: list[StateMachine] = field(default_factory=list)\n   172→    user_pools: list[CognitoUserPool] = field(default_factory=list)\n   173→    ecs_services: list[Any] = field(default_factory=list)\n   174→\n   175→\n   176→# ---------------------------------------------------------------------------\n   177→# Orchestrator\n   178→# ---------------------------------------------------------------------------\n   179→\n   180→\n   181→def parse_assembly(cdk_out_path: Path) -> AppModel:\n   182→    \"\"\"Parse an entire CDK ``cdk.out`` directory into an :class:`AppModel`.\n   183→\n   184→    Parameters\n   185→    ----------\n   186→    cdk_out_path:\n   187→        Path to the ``cdk.out`` directory produced by ``cdk synth``.\n   188→\n   189→    Returns\n   190→    -------\n   191→    AppModel\n   192→    \"\"\"\n   193→    manifest_path = cdk_out_path / \"manifest.json\"\n   194→    if not manifest_path.exists():\n   195→        logger.warning(\"No manifest.json found in %s\", cdk_out_path)\n   196→        return AppModel()\n   197→\n   198→    with open(manifest_path, encoding=\"utf-8\") as fh:\n   199→        manifest = json.load(fh)\n   200→\n   201→    # Parse assets (hash -> filesystem path)\n   202→    asset_map = parse_assets(cdk_out_path)\n   203→\n   204→    # Parse tree.json if present\n   205→    tree_path = cdk_out_path / \"tree.json\"\n   206→    if tree_path.exists():\n   207→        parse_tree(tree_path)  # Currently used for validation; future enrichment\n   208→\n   209→    # Collect all stack artifacts\n   210→    model = AppModel()\n   211→    for artifact_id, artifact in (manifest.get(\"artifacts\") or {}).items():\n   212→        if artifact.get(\"type\") != \"aws:cloudformation:stack\":\n   213→            continue\n   214→        _process_stack(cdk_out_path, artifact_id, artifact, asset_map, model)\n   215→\n   216→    return model\n   217→\n   218→\n   219→def _process_stack(\n   220→    cdk_out_path: Path,\n   221→    artifact_id: str,\n   222→    artifact: dict,\n   223→    asset_map: dict[str, Path],\n   224→    model: AppModel,\n   225→) -> None:\n   226→    \"\"\"Process a single CloudFormation stack artifact.\"\"\"\n   227→    template_file = artifact.get(\"properties\", {}).get(\"templateFile\")\n   228→    if not template_file:\n   229→        logger.warning(\"Stack %s has no templateFile\", artifact_id)\n   230→        return\n   231→\n   232→    template_path = cdk_out_path / template_file\n   233→    if not template_path.exists():\n   234→        logger.warning(\"Template not found: %s\", template_path)\n   235→        return\n   236→\n   237→    resources = parse_template(template_path)\n   238→    resource_type_map = {r.logical_id: r.resource_type for r in resources}\n   239→    resource_map = _build_resource_map(resources)\n   240→    resolver = RefResolver(resource_map=resource_map, resource_types=resource_type_map)\n   241→\n   242→    model.functions.extend(_collect_lambdas(resources, asset_map, cdk_out_path, resolver))\n   243→    model.tables.extend(_collect_tables(resources, resolver))\n   244→    api_def = _collect_api_routes(resources, resolver, artifact_id)\n   245→    if api_def:\n   246→        model.apis.append(api_def)\n   247→    model.queues.extend(_collect_queues(resources, resolver))\n   248→    model.buckets.extend(_collect_buckets(resources))\n   249→    model.topics.extend(_collect_topics(resources, resolver))\n   250→    model.event_buses.extend(_collect_event_buses(resources, resolver))\n   251→    model.event_rules.extend(_collect_event_rules(resources, resolver))\n   252→    model.state_machines.extend(_collect_state_machines(resources, resolver))\n   253→    model.user_pools.extend(_collect_user_pools(resources, resolver))\n   254→\n   255→    # ECS needs the raw template dict\n   256→    with open(template_path, encoding=\"utf-8\") as fh:\n   257→        raw_template = json.load(fh)\n   258→    ecs_services = _collect_ecs_services(raw_template)\n   259→    model.ecs_services.extend(ecs_services)\n   260→\n   261→\n   262→def _build_resource_map(resources: list[CfnResource]) -> dict[str, str]:\n   263→    \"\"\"Build a Ref resource_map so intrinsic ``Ref`` calls resolve to useful local values.\n   264→\n   265→    In real CloudFormation:\n   266→    - ``Ref`` on an ``AWS::SQS::Queue`` returns the queue URL.\n   267→    - ``Ref`` on an ``AWS::DynamoDB::Table`` returns the table name.\n   268→\n   269→    We reproduce this behaviour with deterministic local placeholders so that\n   270→    Lambda environment variables like ``QUEUE_URL`` and ``TABLE_NAME`` resolve\n   271→    to values the local providers can understand.\n   272→    \"\"\"\n   273→    resource_map: dict[str, str] = {}\n   274→    for r in resources:\n   275→        if r.resource_type == \"AWS::SQS::Queue\":\n   276→            queue_name = r.properties.get(\"QueueName\", r.logical_id)\n   277→            if isinstance(queue_name, str):\n   278→                # Use ARN format so the SDK connects via AWS_ENDPOINT_URL_SQS\n   279→                # rather than trying to resolve the QueueUrl as a hostname.\n   280→                resource_map[r.logical_id] = f\"arn:ldk:sqs:local:000000000000:queue/{queue_name}\"\n   281→        elif r.resource_type == \"AWS::DynamoDB::Table\":\n   282→            # Ref returns the table name.\n   283→            table_name = r.properties.get(\"TableName\", r.logical_id)\n   284→            if isinstance(table_name, str):\n   285→                resource_map[r.logical_id] = table_name\n   286→        elif r.resource_type == \"AWS::S3::Bucket\":\n   287→            # Ref returns the bucket name.\n   288→            bucket_name = r.properties.get(\"BucketName\", r.logical_id)\n   289→            if isinstance(bucket_name, str):\n   290→                resource_map[r.logical_id] = bucket_name\n   291→            else:\n   292→                resource_map[r.logical_id] = r.logical_id\n   293→        elif r.resource_type == \"AWS::SNS::Topic\":\n   294→            # Ref returns the topic ARN.\n   295→            topic_name = r.properties.get(\"TopicName\", r.logical_id)\n   296→            if isinstance(topic_name, str):\n   297→                resource_map[r.logical_id] = f\"arn:ldk:sns:local:000000000000:{topic_name}\"\n   298→    return resource_map\n   299→\n   300→\n   301→def _collect_lambdas(\n   302→    resources: list[CfnResource],\n   303→    asset_map: dict[str, Path],\n   304→    cdk_out_path: Path,\n   305→    resolver: RefResolver,\n   306→) -> list[LambdaFunction]:\n   307→    \"\"\"Extract Lambda functions from parsed CloudFormation resources.\"\"\"\n   308→    functions: list[LambdaFunction] = []\n   309→    lambda_props_list = extract_lambda_functions(resources)\n   310→    lambda_resources = [r for r in resources if r.resource_type == \"AWS::Lambda::Function\"]\n   311→    for r, props in zip(lambda_resources, lambda_props_list):\n   312→        code_path = _resolve_code_path(props.code_uri, asset_map, cdk_out_path, resolver)\n   313→        env = {k: str(resolver.resolve(v)) for k, v in props.environment.items()}\n   314→        functions.append(\n   315→            LambdaFunction(\n   316→                name=r.logical_id,\n   317→                handler=props.handler or \"index.handler\",\n   318→                runtime=props.runtime or \"python3.11\",\n   319→                code_path=code_path,\n   320→                timeout=props.timeout or 30,\n   321→                memory=props.memory_size or 128,\n   322→                environment=env,\n   323→            )\n   324→        )\n   325→    return functions\n   326→\n   327→\n   328→def _collect_tables(\n   329→    resources: list[CfnResource],\n   330→    resolver: RefResolver,\n   331→) -> list[DynamoTable]:\n   332→    \"\"\"Extract DynamoDB tables from parsed CloudFormation resources.\"\"\"\n   333→    tables: list[DynamoTable] = []\n   334→    dynamo_props_list = extract_dynamo_tables(resources)\n   335→    dynamo_resources = [r for r in resources if r.resource_type == \"AWS::DynamoDB::Table\"]\n   336→    for r, props in zip(dynamo_resources, dynamo_props_list):\n   337→        name = props.table_name or r.logical_id\n   338→        if isinstance(name, dict):\n   339→            name = str(resolver.resolve(name))\n   340→        tables.append(\n   341→            DynamoTable(\n   342→                name=name,\n   343→                key_schema=props.key_schema,\n   344→                gsi_definitions=props.gsi_definitions,\n   345→            )\n   346→        )\n   347→    return tables\n   348→\n   349→\n   350→def _collect_api_routes(\n   351→    resources: list[CfnResource],\n   352→    resolver: RefResolver,\n   353→    artifact_id: str,\n   354→) -> ApiDefinition | None:\n   355→    \"\"\"Extract API Gateway routes from parsed CloudFormation resources.\"\"\"\n   356→    api_routes = extract_api_routes(resources)\n   357→    if not api_routes:\n   358→        return None\n   359→    routes: list[ApiRoute] = []\n   360→    for route_props in api_routes:\n   361→        handler_name = _find_handler_for_integration(\n   362→            route_props.integration_uri, resources, resolver\n   363→        )\n   364→        routes.append(\n   365→            ApiRoute(\n   366→                method=route_props.http_method or \"ANY\",\n   367→                path=route_props.resource_path or \"/\",\n   368→                handler_name=handler_name,\n   369→            )\n   370→        )\n   371→    return ApiDefinition(name=artifact_id, routes=routes)\n   372→\n   373→\n   374→def _resolve_code_from_s3_key(s3_key: str, asset_map: dict[str, Path]) -> Path | None:\n   375→    \"\"\"Try to match an S3Key to an asset by hash.\"\"\"\n   376→    asset_hash = s3_key.replace(\".zip\", \"\")\n   377→    if asset_hash in asset_map:\n   378→        return asset_map[asset_hash]\n   379→    for hash_key, path in asset_map.items():\n   380→        if hash_key in s3_key:\n   381→            return path\n   382→    return None\n   383→\n   384→\n   385→def _resolve_code_from_s3_bucket(\n   386→    s3_bucket: dict, resolver: RefResolver, asset_map: dict[str, Path]\n   387→) -> Path | None:\n   388→    \"\"\"Try to match an S3Bucket ref to an asset.\"\"\"\n   389→    resolved = str(resolver.resolve(s3_bucket))\n   390→    for h, p in asset_map.items():\n   391→        if h in resolved:\n   392→            return p\n   393→    return None\n   394→\n   395→\n   396→def _resolve_code_path(\n   397→    code_uri: Any,\n   398→    asset_map: dict[str, Path],\n   399→    cdk_out_path: Path,\n   400→    resolver: RefResolver,\n   401→) -> Path | None:\n   402→    \"\"\"Resolve a Lambda Code property to a local filesystem path.\"\"\"\n   403→    if code_uri is None:\n   404→        return None\n   405→\n   406→    if isinstance(code_uri, dict):\n   407→        s3_key = code_uri.get(\"S3Key\")\n   408→        if isinstance(s3_key, str):\n   409→            result = _resolve_code_from_s3_key(s3_key, asset_map)\n   410→            if result:\n   411→                return result\n   412→\n   413→        s3_bucket = code_uri.get(\"S3Bucket\")\n   414→        if isinstance(s3_bucket, dict):\n   415→            result = _resolve_code_from_s3_bucket(s3_bucket, resolver, asset_map)\n   416→            if result:\n   417→                return result\n   418→\n   419→    if isinstance(code_uri, str):\n   420→        candidate = cdk_out_path / code_uri\n   421→        if candidate.exists():\n   422→            return candidate\n   423→\n   424→    return None\n   425→\n   426→\n   427→def _find_handler_for_integration(\n   428→    integration_uri: Any,\n   429→    resources: list[CfnResource],\n   430→    resolver: RefResolver,\n   431→) -> str | None:\n   432→    \"\"\"Try to match an API integration URI back to a Lambda logical ID.\"\"\"\n   433→    if integration_uri is None:\n   434→        return None\n   435→\n   436→    resolved = str(resolver.resolve(integration_uri))\n   437→\n   438→    # Look for a Lambda function logical ID in the resolved string\n   439→    for r in resources:\n   440→        if r.resource_type == \"AWS::Lambda::Function\":\n   441→            if r.logical_id in resolved:\n   442→                return r.logical_id\n   443→\n   444→    return None\n   445→\n   446→\n   447→# ---------------------------------------------------------------------------\n   448→# Collectors for new resource types\n   449→# ---------------------------------------------------------------------------\n   450→\n   451→\n   452→def _collect_queues(\n   453→    resources: list[CfnResource],\n   454→    resolver: RefResolver,\n   455→) -> list[SqsQueue]:\n   456→    \"\"\"Extract SQS queues from parsed CloudFormation resources.\"\"\"\n   457→    queues: list[SqsQueue] = []\n   458→    for r in resources:\n   459→        if r.resource_type != \"AWS::SQS::Queue\":\n   460→            continue\n   461→        props = r.properties\n   462→        name = props.get(\"QueueName\", r.logical_id)\n   463→        if isinstance(name, dict):\n   464→            name = str(resolver.resolve(name))\n   465→        is_fifo = bool(props.get(\"FifoQueue\", False))\n   466→        vis = int(props.get(\"VisibilityTimeout\", 30))\n   467→        dedup = bool(props.get(\"ContentBasedDeduplication\", False))\n   468→        redrive = props.get(\"RedrivePolicy\")\n   469→        redrive_target = None\n   470→        max_receive = 5\n   471→        if isinstance(redrive, dict):\n   472→            dlq = redrive.get(\"deadLetterTargetArn\", \"\")\n   473→            if isinstance(dlq, dict):\n   474→                dlq = str(resolver.resolve(dlq))\n   475→            redrive_target = str(dlq) if dlq else None\n   476→            max_receive = int(redrive.get(\"maxReceiveCount\", 5))\n   477→        queues.append(\n   478→            SqsQueue(\n   479→                name=name,\n   480→                is_fifo=is_fifo,\n   481→                visibility_timeout=vis,\n   482→                content_based_dedup=dedup,\n   483→                redrive_target=redrive_target,\n   484→                max_receive_count=max_receive,\n   485→            )\n   486→        )\n   487→    return queues\n   488→\n   489→\n   490→def _collect_buckets(resources: list[CfnResource]) -> list[S3Bucket]:\n   491→    \"\"\"Extract S3 buckets from parsed CloudFormation resources.\"\"\"\n   492→    buckets: list[S3Bucket] = []\n   493→    for r in resources:\n   494→        if r.resource_type != \"AWS::S3::Bucket\":\n   495→            continue\n   496→        name = r.properties.get(\"BucketName\", r.logical_id)\n   497→        if isinstance(name, dict):\n   498→            name = r.logical_id  # Can't resolve intrinsics for bucket names easily\n   499→        buckets.append(S3Bucket(name=name))\n   500→    return buckets\n   501→\n   502→\n   503→def _collect_topics(\n   504→    resources: list[CfnResource],\n   505→    resolver: RefResolver,\n   506→) -> list[SnsTopic]:\n   507→    \"\"\"Extract SNS topics from parsed CloudFormation resources.\"\"\"\n   508→    topics: list[SnsTopic] = []\n   509→    for r in resources:\n   510→        if r.resource_type != \"AWS::SNS::Topic\":\n   511→            continue\n   512→        props = r.properties\n   513→        name = props.get(\"TopicName\", r.logical_id)\n   514→        if isinstance(name, dict):\n   515→            name = str(resolver.resolve(name))\n   516→        arn = f\"arn:aws:sns:us-east-1:000000000000:{name}\"\n   517→        topics.append(SnsTopic(name=name, topic_arn=arn))\n   518→    return topics\n   519→\n   520→\n   521→def _collect_event_buses(\n   522→    resources: list[CfnResource],\n   523→    resolver: RefResolver,\n   524→) -> list[EventBus]:\n   525→    \"\"\"Extract EventBridge event buses from parsed CloudFormation resources.\"\"\"\n   526→    buses: list[EventBus] = []\n   527→    for r in resources:\n   528→        if r.resource_type != \"AWS::Events::EventBus\":\n   529→            continue\n   530→        props = r.properties\n   531→        name = props.get(\"Name\", r.logical_id)\n   532→        if isinstance(name, dict):\n   533→            name = str(resolver.resolve(name))\n   534→        arn = f\"arn:aws:events:us-east-1:000000000000:event-bus/{name}\"\n   535→        buses.append(EventBus(name=name, bus_arn=arn))\n   536→    return buses\n   537→\n   538→\n   539→def _collect_event_rules(\n   540→    resources: list[CfnResource],\n   541→    resolver: RefResolver,\n   542→) -> list[EventRule]:\n   543→    \"\"\"Extract EventBridge rules from parsed CloudFormation resources.\"\"\"\n   544→    rules: list[EventRule] = []\n   545→    for r in resources:\n   546→        if r.resource_type != \"AWS::Events::Rule\":\n   547→            continue\n   548→        props = r.properties\n   549→        rule_name = props.get(\"Name\", r.logical_id)\n   550→        if isinstance(rule_name, dict):\n   551→            rule_name = str(resolver.resolve(rule_name))\n   552→        bus_name = props.get(\"EventBusName\", \"default\")\n   553→        if isinstance(bus_name, dict):\n   554→            bus_name = str(resolver.resolve(bus_name))\n   555→        pattern = props.get(\"EventPattern\")\n   556→        schedule = props.get(\"ScheduleExpression\")\n   557→        raw_targets = props.get(\"Targets\", [])\n   558→        targets: list[dict[str, Any]] = []\n   559→        for t in raw_targets:\n   560→            target_arn = t.get(\"Arn\", \"\")\n   561→            if isinstance(target_arn, dict):\n   562→                target_arn = str(resolver.resolve(target_arn))\n   563→            targets.append(\n   564→                {\n   565→                    \"target_id\": t.get(\"Id\", \"\"),\n   566→                    \"arn\": target_arn,\n   567→                    \"input_path\": t.get(\"InputPath\"),\n   568→                    \"input_template\": t.get(\"InputTransformer\", {}).get(\"InputTemplate\"),\n   569→                }\n   570→            )\n   571→        rules.append(\n   572→            EventRule(\n   573→                rule_name=rule_name,\n   574→                event_bus_name=bus_name,\n   575→                event_pattern=pattern,\n   576→                schedule_expression=schedule,\n   577→                targets=targets,\n   578→            )\n   579→        )\n   580→    return rules\n   581→\n   582→\n   583→def _resolve_sm_definition(definition: Any, resolver: RefResolver) -> Any:\n   584→    \"\"\"Resolve a Step Functions DefinitionString that may use intrinsic functions.\"\"\"\n   585→    if isinstance(definition, dict):\n   586→        return resolver.resolve(definition)\n   587→    return definition\n   588→\n   589→\n   590→def _resolve_substitutions(subs: dict[str, Any], resolver: RefResolver) -> dict[str, str]:\n   591→    \"\"\"Resolve CloudFormation DefinitionSubstitutions to plain strings.\"\"\"\n   592→    return {k: str(resolver.resolve(v)) if isinstance(v, dict) else str(v) for k, v in subs.items()}\n   593→\n   594→\n   595→def _collect_state_machines(\n   596→    resources: list[CfnResource],\n   597→    resolver: RefResolver,\n   598→) -> list[StateMachine]:\n   599→    \"\"\"Extract Step Functions state machines from parsed CloudFormation resources.\"\"\"\n   600→    machines: list[StateMachine] = []\n   601→    for r in resources:\n   602→        if r.resource_type != \"AWS::StepFunctions::StateMachine\":\n   603→            continue\n   604→        props = r.properties\n   605→        name = props.get(\"StateMachineName\", r.logical_id)\n   606→        if isinstance(name, dict):\n   607→            name = str(resolver.resolve(name))\n   608→        definition = props.get(\"DefinitionString\", props.get(\"Definition\", \"\"))\n   609→        definition = _resolve_sm_definition(definition, resolver)\n   610→        role_arn = props.get(\"RoleArn\", \"\")\n   611→        if isinstance(role_arn, dict):\n   612→            role_arn = str(resolver.resolve(role_arn))\n   613→        resolved_subs = _resolve_substitutions(props.get(\"DefinitionSubstitutions\", {}), resolver)\n   614→        machines.append(\n   615→            StateMachine(\n   616→                name=name,\n   617→                definition=definition,\n   618→                workflow_type=props.get(\"StateMachineType\", \"STANDARD\"),\n   619→                role_arn=role_arn,\n   620→                definition_substitutions=resolved_subs,\n   621→            )\n   622→        )\n   623→    return machines\n   624→\n   625→\n   626→def _collect_user_pools(\n   627→    resources: list[CfnResource],\n   628→    resolver: RefResolver,\n   629→) -> list[CognitoUserPool]:\n   630→    \"\"\"Extract Cognito user pools from parsed CloudFormation resources.\"\"\"\n   631→    pools: list[CognitoUserPool] = []\n   632→    # First pass: collect user pool clients to map pool -> client_id\n   633→    client_map: dict[str, str] = {}\n   634→    for r in resources:\n   635→        if r.resource_type != \"AWS::Cognito::UserPoolClient\":\n   636→            continue\n   637→        pool_ref = r.properties.get(\"UserPoolId\", \"\")\n   638→        if isinstance(pool_ref, dict):\n   639→            pool_ref = str(resolver.resolve(pool_ref))\n   640→        client_map[pool_ref] = r.logical_id\n   641→\n   642→    for r in resources:\n   643→        if r.resource_type != \"AWS::Cognito::UserPool\":\n   644→            continue\n   645→        props = r.properties\n   646→        name = props.get(\"UserPoolName\", r.logical_id)\n   647→        if isinstance(name, dict):\n   648→            name = str(resolver.resolve(name))\n   649→        auto_confirm = True\n   650→        lambda_config = props.get(\"LambdaConfig\", {})\n   651→        pre_auth = lambda_config.get(\"PreAuthentication\")\n   652→        if isinstance(pre_auth, dict):\n   653→            pre_auth = str(resolver.resolve(pre_auth))\n   654→        post_confirm = lambda_config.get(\"PostConfirmation\")\n   655→        if isinstance(post_confirm, dict):\n   656→            post_confirm = str(resolver.resolve(post_confirm))\n   657→        pw_policy = props.get(\"Policies\", {}).get(\"PasswordPolicy\", {})\n   658→        client_id = client_map.get(r.logical_id, \"\")\n   659→        pools.append(\n   660→            CognitoUserPool(\n   661→                logical_id=r.logical_id,\n   662→                user_pool_name=name,\n   663→                auto_confirm=auto_confirm,\n   664→                password_policy=pw_policy,\n   665→                pre_auth_trigger=pre_auth,\n   666→                post_confirm_trigger=post_confirm,\n   667→                client_id=client_id,\n   668→            )\n   669→        )\n   670→    return pools\n   671→\n   672→\n   673→def _collect_ecs_services(template: dict) -> list:\n   674→    \"\"\"Extract ECS services from the raw CloudFormation template.\"\"\"\n   675→    try:\n   676→        from lws.providers.ecs.provider import parse_ecs_resources\n   677→\n   678→        return parse_ecs_resources(template)\n   679→    except Exception:\n   680→        logger.debug(\"Could not parse ECS resources\", exc_info=True)\n   681→        return []\n   682→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"af173769-5e93-450f-b1e1-85d43fd75980","timestamp":"2026-02-10T23:20:22.131Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services/src/lws/parser/assembly.py","content":"\"\"\"Assembly orchestrator -- top-level entry point for CDK output parsing.\n\nTies together tree parsing, template parsing, reference resolution and\nasset location to produce a single ``AppModel`` that the rest of the\nsystem can consume.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport json\nimport logging\nfrom dataclasses import dataclass, field\nfrom pathlib import Path\nfrom typing import Any\n\nfrom lws.parser.asset_parser import parse_assets\nfrom lws.parser.ref_resolver import RefResolver\nfrom lws.parser.template_parser import (\n    CfnResource,\n    extract_api_routes,\n    extract_dynamo_tables,\n    extract_lambda_functions,\n    parse_template,\n)\nfrom lws.parser.tree_parser import parse_tree\n\nlogger = logging.getLogger(__name__)\n\n# ---------------------------------------------------------------------------\n# Domain model dataclasses\n# ---------------------------------------------------------------------------\n\n\n@dataclass\nclass LambdaFunction:\n    \"\"\"Parsed Lambda function ready for local execution.\"\"\"\n\n    name: str\n    handler: str\n    runtime: str\n    code_path: Path | None = None\n    timeout: int = 30\n    memory: int = 128\n    environment: dict[str, str] = field(default_factory=dict)\n\n    @property\n    def logical_id(self) -> str:\n        return self.name\n\n\n@dataclass\nclass DynamoTable:\n    \"\"\"Parsed DynamoDB table definition.\"\"\"\n\n    name: str\n    key_schema: list[dict[str, str]] = field(default_factory=list)\n    gsi_definitions: list[dict[str, Any]] = field(default_factory=list)\n\n    @property\n    def logical_id(self) -> str:\n        return self.name\n\n    @property\n    def table_name(self) -> str:\n        return self.name\n\n\n@dataclass\nclass ApiRoute:\n    \"\"\"A single API Gateway route.\"\"\"\n\n    method: str\n    path: str\n    handler_name: str | None = None\n\n\n@dataclass\nclass ApiDefinition:\n    \"\"\"A collection of routes making up an API.\"\"\"\n\n    name: str = \"default\"\n    routes: list[ApiRoute] = field(default_factory=list)\n\n    @property\n    def logical_id(self) -> str:\n        return self.name\n\n\n@dataclass\nclass SqsQueue:\n    \"\"\"Parsed SQS queue definition.\"\"\"\n\n    name: str\n    is_fifo: bool = False\n    visibility_timeout: int = 30\n    content_based_dedup: bool = False\n    redrive_target: str | None = None\n    max_receive_count: int = 5\n\n\n@dataclass\nclass S3Bucket:\n    \"\"\"Parsed S3 bucket definition.\"\"\"\n\n    name: str\n\n\n@dataclass\nclass SnsTopic:\n    \"\"\"Parsed SNS topic definition.\"\"\"\n\n    name: str\n    topic_arn: str = \"\"\n\n\n@dataclass\nclass EventBus:\n    \"\"\"Parsed EventBridge event bus definition.\"\"\"\n\n    name: str\n    bus_arn: str = \"\"\n\n\n@dataclass\nclass EventRule:\n    \"\"\"Parsed EventBridge rule definition.\"\"\"\n\n    rule_name: str\n    event_bus_name: str = \"default\"\n    event_pattern: dict[str, Any] | None = None\n    schedule_expression: str | None = None\n    targets: list[dict[str, Any]] = field(default_factory=list)\n\n\n@dataclass\nclass StateMachine:\n    \"\"\"Parsed Step Functions state machine definition.\"\"\"\n\n    name: str\n    definition: str | dict[str, Any] = \"\"\n    workflow_type: str = \"STANDARD\"\n    role_arn: str = \"\"\n    definition_substitutions: dict[str, str] = field(default_factory=dict)\n\n\n@dataclass\nclass CognitoUserPool:\n    \"\"\"Parsed Cognito user pool definition.\"\"\"\n\n    logical_id: str\n    user_pool_name: str = \"default\"\n    auto_confirm: bool = True\n    password_policy: dict[str, Any] = field(default_factory=dict)\n    pre_auth_trigger: str | None = None\n    post_confirm_trigger: str | None = None\n    client_id: str = \"\"\n\n\n@dataclass\nclass AppModel:\n    \"\"\"Complete parsed representation of a CDK application.\"\"\"\n\n    functions: list[LambdaFunction] = field(default_factory=list)\n    tables: list[DynamoTable] = field(default_factory=list)\n    apis: list[ApiDefinition] = field(default_factory=list)\n    queues: list[SqsQueue] = field(default_factory=list)\n    buckets: list[S3Bucket] = field(default_factory=list)\n    topics: list[SnsTopic] = field(default_factory=list)\n    event_buses: list[EventBus] = field(default_factory=list)\n    event_rules: list[EventRule] = field(default_factory=list)\n    state_machines: list[StateMachine] = field(default_factory=list)\n    user_pools: list[CognitoUserPool] = field(default_factory=list)\n    ecs_services: list[Any] = field(default_factory=list)\n\n\n# ---------------------------------------------------------------------------\n# Orchestrator\n# ---------------------------------------------------------------------------\n\n\ndef parse_assembly(cdk_out_path: Path) -> AppModel:\n    \"\"\"Parse an entire CDK ``cdk.out`` directory into an :class:`AppModel`.\n\n    Parameters\n    ----------\n    cdk_out_path:\n        Path to the ``cdk.out`` directory produced by ``cdk synth``.\n\n    Returns\n    -------\n    AppModel\n    \"\"\"\n    manifest_path = cdk_out_path / \"manifest.json\"\n    if not manifest_path.exists():\n        logger.warning(\"No manifest.json found in %s\", cdk_out_path)\n        return AppModel()\n\n    with open(manifest_path, encoding=\"utf-8\") as fh:\n        manifest = json.load(fh)\n\n    # Parse assets (hash -> filesystem path)\n    asset_map = parse_assets(cdk_out_path)\n\n    # Parse tree.json if present\n    tree_path = cdk_out_path / \"tree.json\"\n    if tree_path.exists():\n        parse_tree(tree_path)  # Currently used for validation; future enrichment\n\n    # Collect all stack artifacts\n    model = AppModel()\n    for artifact_id, artifact in (manifest.get(\"artifacts\") or {}).items():\n        if artifact.get(\"type\") != \"aws:cloudformation:stack\":\n            continue\n        _process_stack(cdk_out_path, artifact_id, artifact, asset_map, model)\n\n    return model\n\n\ndef _process_stack(\n    cdk_out_path: Path,\n    artifact_id: str,\n    artifact: dict,\n    asset_map: dict[str, Path],\n    model: AppModel,\n) -> None:\n    \"\"\"Process a single CloudFormation stack artifact.\"\"\"\n    template_file = artifact.get(\"properties\", {}).get(\"templateFile\")\n    if not template_file:\n        logger.warning(\"Stack %s has no templateFile\", artifact_id)\n        return\n\n    template_path = cdk_out_path / template_file\n    if not template_path.exists():\n        logger.warning(\"Template not found: %s\", template_path)\n        return\n\n    resources = parse_template(template_path)\n    resource_type_map = {r.logical_id: r.resource_type for r in resources}\n    resource_map = _build_resource_map(resources)\n    resolver = RefResolver(resource_map=resource_map, resource_types=resource_type_map)\n\n    model.functions.extend(_collect_lambdas(resources, asset_map, cdk_out_path, resolver))\n    model.tables.extend(_collect_tables(resources, resolver))\n    api_def = _collect_api_routes(resources, resolver, artifact_id)\n    if api_def:\n        model.apis.append(api_def)\n    model.queues.extend(_collect_queues(resources, resolver))\n    model.buckets.extend(_collect_buckets(resources))\n    model.topics.extend(_collect_topics(resources, resolver))\n    model.event_buses.extend(_collect_event_buses(resources, resolver))\n    model.event_rules.extend(_collect_event_rules(resources, resolver))\n    model.state_machines.extend(_collect_state_machines(resources, resolver))\n    model.user_pools.extend(_collect_user_pools(resources, resolver))\n\n    # ECS needs the raw template dict\n    with open(template_path, encoding=\"utf-8\") as fh:\n        raw_template = json.load(fh)\n    ecs_services = _collect_ecs_services(raw_template)\n    model.ecs_services.extend(ecs_services)\n\n\ndef _build_resource_map(resources: list[CfnResource]) -> dict[str, str]:\n    \"\"\"Build a Ref resource_map so intrinsic ``Ref`` calls resolve to useful local values.\n\n    In real CloudFormation:\n    - ``Ref`` on an ``AWS::SQS::Queue`` returns the queue URL.\n    - ``Ref`` on an ``AWS::DynamoDB::Table`` returns the table name.\n\n    We reproduce this behaviour with deterministic local placeholders so that\n    Lambda environment variables like ``QUEUE_URL`` and ``TABLE_NAME`` resolve\n    to values the local providers can understand.\n    \"\"\"\n    resource_map: dict[str, str] = {}\n    for r in resources:\n        if r.resource_type == \"AWS::SQS::Queue\":\n            queue_name = r.properties.get(\"QueueName\", r.logical_id)\n            if isinstance(queue_name, str):\n                # Use ARN format so the SDK connects via AWS_ENDPOINT_URL_SQS\n                # rather than trying to resolve the QueueUrl as a hostname.\n                resource_map[r.logical_id] = f\"arn:ldk:sqs:local:000000000000:queue/{queue_name}\"\n        elif r.resource_type == \"AWS::DynamoDB::Table\":\n            # Ref returns the table name.\n            table_name = r.properties.get(\"TableName\", r.logical_id)\n            if isinstance(table_name, str):\n                resource_map[r.logical_id] = table_name\n        elif r.resource_type == \"AWS::S3::Bucket\":\n            # Ref returns the bucket name.\n            bucket_name = r.properties.get(\"BucketName\", r.logical_id)\n            if isinstance(bucket_name, str):\n                resource_map[r.logical_id] = bucket_name\n            else:\n                resource_map[r.logical_id] = r.logical_id\n        elif r.resource_type == \"AWS::SNS::Topic\":\n            # Ref returns the topic ARN.\n            topic_name = r.properties.get(\"TopicName\", r.logical_id)\n            if isinstance(topic_name, str):\n                resource_map[r.logical_id] = f\"arn:ldk:sns:local:000000000000:{topic_name}\"\n    return resource_map\n\n\ndef _collect_lambdas(\n    resources: list[CfnResource],\n    asset_map: dict[str, Path],\n    cdk_out_path: Path,\n    resolver: RefResolver,\n) -> list[LambdaFunction]:\n    \"\"\"Extract Lambda functions from parsed CloudFormation resources.\"\"\"\n    functions: list[LambdaFunction] = []\n    lambda_props_list = extract_lambda_functions(resources)\n    lambda_resources = [r for r in resources if r.resource_type == \"AWS::Lambda::Function\"]\n    for r, props in zip(lambda_resources, lambda_props_list):\n        code_path = _resolve_code_path(props.code_uri, asset_map, cdk_out_path, resolver)\n        env = {k: str(resolver.resolve(v)) for k, v in props.environment.items()}\n        functions.append(\n            LambdaFunction(\n                name=r.logical_id,\n                handler=props.handler or \"index.handler\",\n                runtime=props.runtime or \"python3.11\",\n                code_path=code_path,\n                timeout=props.timeout or 30,\n                memory=props.memory_size or 128,\n                environment=env,\n            )\n        )\n    return functions\n\n\ndef _collect_tables(\n    resources: list[CfnResource],\n    resolver: RefResolver,\n) -> list[DynamoTable]:\n    \"\"\"Extract DynamoDB tables from parsed CloudFormation resources.\"\"\"\n    tables: list[DynamoTable] = []\n    dynamo_props_list = extract_dynamo_tables(resources)\n    dynamo_resources = [r for r in resources if r.resource_type == \"AWS::DynamoDB::Table\"]\n    for r, props in zip(dynamo_resources, dynamo_props_list):\n        name = props.table_name or r.logical_id\n        if isinstance(name, dict):\n            name = str(resolver.resolve(name))\n        tables.append(\n            DynamoTable(\n                name=name,\n                key_schema=props.key_schema,\n                gsi_definitions=props.gsi_definitions,\n            )\n        )\n    return tables\n\n\ndef _collect_api_routes(\n    resources: list[CfnResource],\n    resolver: RefResolver,\n    artifact_id: str,\n) -> ApiDefinition | None:\n    \"\"\"Extract API Gateway routes from parsed CloudFormation resources.\"\"\"\n    api_routes = extract_api_routes(resources)\n    if not api_routes:\n        return None\n    routes: list[ApiRoute] = []\n    for route_props in api_routes:\n        handler_name = _find_handler_for_integration(\n            route_props.integration_uri, resources, resolver\n        )\n        routes.append(\n            ApiRoute(\n                method=route_props.http_method or \"ANY\",\n                path=route_props.resource_path or \"/\",\n                handler_name=handler_name,\n            )\n        )\n    return ApiDefinition(name=artifact_id, routes=routes)\n\n\ndef _resolve_code_from_s3_key(s3_key: str, asset_map: dict[str, Path]) -> Path | None:\n    \"\"\"Try to match an S3Key to an asset by hash.\"\"\"\n    asset_hash = s3_key.replace(\".zip\", \"\")\n    if asset_hash in asset_map:\n        return asset_map[asset_hash]\n    for hash_key, path in asset_map.items():\n        if hash_key in s3_key:\n            return path\n    return None\n\n\ndef _resolve_code_from_s3_bucket(\n    s3_bucket: dict, resolver: RefResolver, asset_map: dict[str, Path]\n) -> Path | None:\n    \"\"\"Try to match an S3Bucket ref to an asset.\"\"\"\n    resolved = str(resolver.resolve(s3_bucket))\n    for h, p in asset_map.items():\n        if h in resolved:\n            return p\n    return None\n\n\ndef _resolve_code_path(\n    code_uri: Any,\n    asset_map: dict[str, Path],\n    cdk_out_path: Path,\n    resolver: RefResolver,\n) -> Path | None:\n    \"\"\"Resolve a Lambda Code property to a local filesystem path.\"\"\"\n    if code_uri is None:\n        return None\n\n    if isinstance(code_uri, dict):\n        s3_key = code_uri.get(\"S3Key\")\n        if isinstance(s3_key, str):\n            result = _resolve_code_from_s3_key(s3_key, asset_map)\n            if result:\n                return result\n\n        s3_bucket = code_uri.get(\"S3Bucket\")\n        if isinstance(s3_bucket, dict):\n            result = _resolve_code_from_s3_bucket(s3_bucket, resolver, asset_map)\n            if result:\n                return result\n\n    if isinstance(code_uri, str):\n        candidate = cdk_out_path / code_uri\n        if candidate.exists():\n            return candidate\n\n    return None\n\n\ndef _find_handler_for_integration(\n    integration_uri: Any,\n    resources: list[CfnResource],\n    resolver: RefResolver,\n) -> str | None:\n    \"\"\"Try to match an API integration URI back to a Lambda logical ID.\"\"\"\n    if integration_uri is None:\n        return None\n\n    resolved = str(resolver.resolve(integration_uri))\n\n    # Look for a Lambda function logical ID in the resolved string\n    for r in resources:\n        if r.resource_type == \"AWS::Lambda::Function\":\n            if r.logical_id in resolved:\n                return r.logical_id\n\n    return None\n\n\n# ---------------------------------------------------------------------------\n# Collectors for new resource types\n# ---------------------------------------------------------------------------\n\n\ndef _collect_queues(\n    resources: list[CfnResource],\n    resolver: RefResolver,\n) -> list[SqsQueue]:\n    \"\"\"Extract SQS queues from parsed CloudFormation resources.\"\"\"\n    queues: list[SqsQueue] = []\n    for r in resources:\n        if r.resource_type != \"AWS::SQS::Queue\":\n            continue\n        props = r.properties\n        name = props.get(\"QueueName\", r.logical_id)\n        if isinstance(name, dict):\n            name = str(resolver.resolve(name))\n        is_fifo = bool(props.get(\"FifoQueue\", False))\n        vis = int(props.get(\"VisibilityTimeout\", 30))\n        dedup = bool(props.get(\"ContentBasedDeduplication\", False))\n        redrive = props.get(\"RedrivePolicy\")\n        redrive_target = None\n        max_receive = 5\n        if isinstance(redrive, dict):\n            dlq = redrive.get(\"deadLetterTargetArn\", \"\")\n            if isinstance(dlq, dict):\n                dlq = str(resolver.resolve(dlq))\n            redrive_target = str(dlq) if dlq else None\n            max_receive = int(redrive.get(\"maxReceiveCount\", 5))\n        queues.append(\n            SqsQueue(\n                name=name,\n                is_fifo=is_fifo,\n                visibility_timeout=vis,\n                content_based_dedup=dedup,\n                redrive_target=redrive_target,\n                max_receive_count=max_receive,\n            )\n        )\n    return queues\n\n\ndef _collect_buckets(resources: list[CfnResource]) -> list[S3Bucket]:\n    \"\"\"Extract S3 buckets from parsed CloudFormation resources.\"\"\"\n    buckets: list[S3Bucket] = []\n    for r in resources:\n        if r.resource_type != \"AWS::S3::Bucket\":\n            continue\n        name = r.properties.get(\"BucketName\", r.logical_id)\n        if isinstance(name, dict):\n            name = r.logical_id  # Can't resolve intrinsics for bucket names easily\n        buckets.append(S3Bucket(name=name))\n    return buckets\n\n\ndef _collect_topics(\n    resources: list[CfnResource],\n    resolver: RefResolver,\n) -> list[SnsTopic]:\n    \"\"\"Extract SNS topics from parsed CloudFormation resources.\"\"\"\n    topics: list[SnsTopic] = []\n    for r in resources:\n        if r.resource_type != \"AWS::SNS::Topic\":\n            continue\n        props = r.properties\n        name = props.get(\"TopicName\", r.logical_id)\n        if isinstance(name, dict):\n            name = str(resolver.resolve(name))\n        arn = f\"arn:aws:sns:us-east-1:000000000000:{name}\"\n        topics.append(SnsTopic(name=name, topic_arn=arn))\n    return topics\n\n\ndef _collect_event_buses(\n    resources: list[CfnResource],\n    resolver: RefResolver,\n) -> list[EventBus]:\n    \"\"\"Extract EventBridge event buses from parsed CloudFormation resources.\"\"\"\n    buses: list[EventBus] = []\n    for r in resources:\n        if r.resource_type != \"AWS::Events::EventBus\":\n            continue\n        props = r.properties\n        name = props.get(\"Name\", r.logical_id)\n        if isinstance(name, dict):\n            name = str(resolver.resolve(name))\n        arn = f\"arn:aws:events:us-east-1:000000000000:event-bus/{name}\"\n        buses.append(EventBus(name=name, bus_arn=arn))\n    return buses\n\n\ndef _collect_event_rules(\n    resources: list[CfnResource],\n    resolver: RefResolver,\n) -> list[EventRule]:\n    \"\"\"Extract EventBridge rules from parsed CloudFormation resources.\"\"\"\n    rules: list[EventRule] = []\n    for r in resources:\n        if r.resource_type != \"AWS::Events::Rule\":\n            continue\n        props = r.properties\n        rule_name = props.get(\"Name\", r.logical_id)\n        if isinstance(rule_name, dict):\n            rule_name = str(resolver.resolve(rule_name))\n        bus_name = props.get(\"EventBusName\", \"default\")\n        if isinstance(bus_name, dict):\n            bus_name = str(resolver.resolve(bus_name))\n        pattern = props.get(\"EventPattern\")\n        schedule = props.get(\"ScheduleExpression\")\n        raw_targets = props.get(\"Targets\", [])\n        targets: list[dict[str, Any]] = []\n        for t in raw_targets:\n            target_arn = t.get(\"Arn\", \"\")\n            if isinstance(target_arn, dict):\n                target_arn = str(resolver.resolve(target_arn))\n            targets.append(\n                {\n                    \"target_id\": t.get(\"Id\", \"\"),\n                    \"arn\": target_arn,\n                    \"input_path\": t.get(\"InputPath\"),\n                    \"input_template\": t.get(\"InputTransformer\", {}).get(\"InputTemplate\"),\n                }\n            )\n        rules.append(\n            EventRule(\n                rule_name=rule_name,\n                event_bus_name=bus_name,\n                event_pattern=pattern,\n                schedule_expression=schedule,\n                targets=targets,\n            )\n        )\n    return rules\n\n\ndef _resolve_sm_definition(definition: Any, resolver: RefResolver) -> Any:\n    \"\"\"Resolve a Step Functions DefinitionString that may use intrinsic functions.\"\"\"\n    if isinstance(definition, dict):\n        return resolver.resolve(definition)\n    return definition\n\n\ndef _resolve_substitutions(subs: dict[str, Any], resolver: RefResolver) -> dict[str, str]:\n    \"\"\"Resolve CloudFormation DefinitionSubstitutions to plain strings.\"\"\"\n    return {k: str(resolver.resolve(v)) if isinstance(v, dict) else str(v) for k, v in subs.items()}\n\n\ndef _collect_state_machines(\n    resources: list[CfnResource],\n    resolver: RefResolver,\n) -> list[StateMachine]:\n    \"\"\"Extract Step Functions state machines from parsed CloudFormation resources.\"\"\"\n    machines: list[StateMachine] = []\n    for r in resources:\n        if r.resource_type != \"AWS::StepFunctions::StateMachine\":\n            continue\n        props = r.properties\n        name = props.get(\"StateMachineName\", r.logical_id)\n        if isinstance(name, dict):\n            name = str(resolver.resolve(name))\n        definition = props.get(\"DefinitionString\", props.get(\"Definition\", \"\"))\n        definition = _resolve_sm_definition(definition, resolver)\n        role_arn = props.get(\"RoleArn\", \"\")\n        if isinstance(role_arn, dict):\n            role_arn = str(resolver.resolve(role_arn))\n        resolved_subs = _resolve_substitutions(props.get(\"DefinitionSubstitutions\", {}), resolver)\n        machines.append(\n            StateMachine(\n                name=name,\n                definition=definition,\n                workflow_type=props.get(\"StateMachineType\", \"STANDARD\"),\n                role_arn=role_arn,\n                definition_substitutions=resolved_subs,\n            )\n        )\n    return machines\n\n\ndef _collect_user_pools(\n    resources: list[CfnResource],\n    resolver: RefResolver,\n) -> list[CognitoUserPool]:\n    \"\"\"Extract Cognito user pools from parsed CloudFormation resources.\"\"\"\n    pools: list[CognitoUserPool] = []\n    # First pass: collect user pool clients to map pool -> client_id\n    client_map: dict[str, str] = {}\n    for r in resources:\n        if r.resource_type != \"AWS::Cognito::UserPoolClient\":\n            continue\n        pool_ref = r.properties.get(\"UserPoolId\", \"\")\n        if isinstance(pool_ref, dict):\n            pool_ref = str(resolver.resolve(pool_ref))\n        client_map[pool_ref] = r.logical_id\n\n    for r in resources:\n        if r.resource_type != \"AWS::Cognito::UserPool\":\n            continue\n        props = r.properties\n        name = props.get(\"UserPoolName\", r.logical_id)\n        if isinstance(name, dict):\n            name = str(resolver.resolve(name))\n        auto_confirm = True\n        lambda_config = props.get(\"LambdaConfig\", {})\n        pre_auth = lambda_config.get(\"PreAuthentication\")\n        if isinstance(pre_auth, dict):\n            pre_auth = str(resolver.resolve(pre_auth))\n        post_confirm = lambda_config.get(\"PostConfirmation\")\n        if isinstance(post_confirm, dict):\n            post_confirm = str(resolver.resolve(post_confirm))\n        pw_policy = props.get(\"Policies\", {}).get(\"PasswordPolicy\", {})\n        client_id = client_map.get(r.logical_id, \"\")\n        pools.append(\n            CognitoUserPool(\n                logical_id=r.logical_id,\n                user_pool_name=name,\n                auto_confirm=auto_confirm,\n                password_policy=pw_policy,\n                pre_auth_trigger=pre_auth,\n                post_confirm_trigger=post_confirm,\n                client_id=client_id,\n            )\n        )\n    return pools\n\n\ndef _collect_ecs_services(template: dict) -> list:\n    \"\"\"Extract ECS services from the raw CloudFormation template.\"\"\"\n    try:\n        from lws.providers.ecs.provider import parse_ecs_resources\n\n        return parse_ecs_resources(template)\n    except Exception:\n        logger.debug(\"Could not parse ECS resources\", exc_info=True)\n        return []\n","numLines":682,"startLine":1,"totalLines":682}},"sourceToolAssistantUUID":"79d75a2c-4ccb-4a1b-88ff-2358b1d14616"}
{"parentUuid":"af173769-5e93-450f-b1e1-85d43fd75980","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","message":{"model":"claude-opus-4-6","id":"msg_01Rc6hbAU62CYKRBiSnJcYAj","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01M3CM5Z8bZmW9JqJ6atEEeu","name":"Read","input":{"file_path":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services/src/lws/parser/tree_parser.py"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":5553,"cache_read_input_tokens":15470,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":5553},"output_tokens":2,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CY1FCABup89maXRijdjwj","type":"assistant","uuid":"07b7631d-8243-40b2-8fb5-15f3bbbae181","timestamp":"2026-02-10T23:20:22.656Z"}
{"parentUuid":"07b7631d-8243-40b2-8fb5-15f3bbbae181","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"callback"},"parentToolUseID":"toolu_01M3CM5Z8bZmW9JqJ6atEEeu","toolUseID":"toolu_01M3CM5Z8bZmW9JqJ6atEEeu","timestamp":"2026-02-10T23:20:22.662Z","uuid":"c083b467-43d1-479b-b90f-c767d0569fb9"}
{"parentUuid":"07b7631d-8243-40b2-8fb5-15f3bbbae181","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01M3CM5Z8bZmW9JqJ6atEEeu","type":"tool_result","content":"     1→\"\"\"Parser for CDK tree.json files.\n     2→\n     3→Walks the construct tree and produces a flat/nested list of ConstructNode\n     4→dataclasses that downstream stages use to correlate logical IDs with\n     5→CDK-level metadata (FQN, resource category, etc.).\n     6→\"\"\"\n     7→\n     8→from __future__ import annotations\n     9→\n    10→import json\n    11→import logging\n    12→from dataclasses import dataclass, field\n    13→from pathlib import Path\n    14→\n    15→logger = logging.getLogger(__name__)\n    16→\n    17→# ---------------------------------------------------------------------------\n    18→# Known CDK FQN -> resource-category mapping\n    19→# ---------------------------------------------------------------------------\n    20→FQN_CATEGORY_MAP: dict[str, str] = {\n    21→    \"aws-cdk-lib.aws_lambda.Function\": \"lambda\",\n    22→    \"aws-cdk-lib.aws_lambda_nodejs.NodejsFunction\": \"lambda\",\n    23→    \"aws-cdk-lib.aws_lambda_python_alpha.PythonFunction\": \"lambda\",\n    24→    \"aws-cdk-lib.aws_dynamodb.Table\": \"dynamodb\",\n    25→    \"aws-cdk-lib.aws_dynamodb.TableV2\": \"dynamodb\",\n    26→    \"aws-cdk-lib.aws_apigateway.RestApi\": \"apigateway\",\n    27→    \"aws-cdk-lib.aws_apigateway.LambdaRestApi\": \"apigateway\",\n    28→    \"aws-cdk-lib.aws_apigatewayv2.HttpApi\": \"apigatewayv2\",\n    29→    \"aws-cdk-lib.aws_apigatewayv2_alpha.HttpApi\": \"apigatewayv2\",\n    30→    \"aws-cdk-lib.aws_s3.Bucket\": \"s3\",\n    31→    \"aws-cdk-lib.aws_sqs.Queue\": \"sqs\",\n    32→    \"aws-cdk-lib.aws_sns.Topic\": \"sns\",\n    33→    \"aws-cdk-lib.aws_stepfunctions.StateMachine\": \"stepfunctions\",\n    34→    \"aws-cdk-lib.aws_events.Rule\": \"events\",\n    35→}\n    36→\n    37→\n    38→@dataclass\n    39→class ConstructNode:\n    40→    \"\"\"A node in the CDK construct tree.\"\"\"\n    41→\n    42→    path: str\n    43→    id: str\n    44→    fqn: str | None = None\n    45→    children: list[ConstructNode] = field(default_factory=list)\n    46→    cfn_type: str | None = None\n    47→\n    48→    @property\n    49→    def category(self) -> str | None:\n    50→        \"\"\"Return a human-friendly resource category derived from the FQN.\"\"\"\n    51→        if self.fqn is not None:\n    52→            return FQN_CATEGORY_MAP.get(self.fqn)\n    53→        return None\n    54→\n    55→\n    56→def _walk_node(node_data: dict) -> ConstructNode:\n    57→    \"\"\"Recursively convert a raw tree-JSON dict into a ConstructNode.\"\"\"\n    58→    path = node_data.get(\"path\", \"\")\n    59→    node_id = node_data.get(\"id\", \"\")\n    60→\n    61→    construct_info = node_data.get(\"constructInfo\", {})\n    62→    fqn = construct_info.get(\"fqn\") if construct_info else None\n    63→\n    64→    # Some leaf nodes carry an AWS CloudFormation type directly\n    65→    cfn_type = (\n    66→        node_data.get(\"attributes\", {}).get(\"aws:cdk:cloudformation:type\")\n    67→        if node_data.get(\"attributes\")\n    68→        else None\n    69→    )\n    70→\n    71→    children: list[ConstructNode] = []\n    72→    for child_data in (node_data.get(\"children\") or {}).values():\n    73→        children.append(_walk_node(child_data))\n    74→\n    75→    return ConstructNode(\n    76→        path=path,\n    77→        id=node_id,\n    78→        fqn=fqn,\n    79→        children=children,\n    80→        cfn_type=cfn_type,\n    81→    )\n    82→\n    83→\n    84→def parse_tree(tree_json_path: Path) -> list[ConstructNode]:\n    85→    \"\"\"Parse a CDK ``tree.json`` and return top-level construct nodes.\n    86→\n    87→    Parameters\n    88→    ----------\n    89→    tree_json_path:\n    90→        Absolute or relative path to the ``tree.json`` file emitted by\n    91→        ``cdk synth``.\n    92→\n    93→    Returns\n    94→    -------\n    95→    list[ConstructNode]\n    96→        The immediate children of the tree root (typically one node per\n    97→        CDK stack).\n    98→    \"\"\"\n    99→    with open(tree_json_path, encoding=\"utf-8\") as fh:\n   100→        data = json.load(fh)\n   101→\n   102→    tree_root = data.get(\"tree\", data)\n   103→\n   104→    children: list[ConstructNode] = []\n   105→    for child_data in (tree_root.get(\"children\") or {}).values():\n   106→        children.append(_walk_node(child_data))\n   107→\n   108→    return children\n   109→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"248810db-33a6-462e-927b-3114564a9eec","timestamp":"2026-02-10T23:20:22.661Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services/src/lws/parser/tree_parser.py","content":"\"\"\"Parser for CDK tree.json files.\n\nWalks the construct tree and produces a flat/nested list of ConstructNode\ndataclasses that downstream stages use to correlate logical IDs with\nCDK-level metadata (FQN, resource category, etc.).\n\"\"\"\n\nfrom __future__ import annotations\n\nimport json\nimport logging\nfrom dataclasses import dataclass, field\nfrom pathlib import Path\n\nlogger = logging.getLogger(__name__)\n\n# ---------------------------------------------------------------------------\n# Known CDK FQN -> resource-category mapping\n# ---------------------------------------------------------------------------\nFQN_CATEGORY_MAP: dict[str, str] = {\n    \"aws-cdk-lib.aws_lambda.Function\": \"lambda\",\n    \"aws-cdk-lib.aws_lambda_nodejs.NodejsFunction\": \"lambda\",\n    \"aws-cdk-lib.aws_lambda_python_alpha.PythonFunction\": \"lambda\",\n    \"aws-cdk-lib.aws_dynamodb.Table\": \"dynamodb\",\n    \"aws-cdk-lib.aws_dynamodb.TableV2\": \"dynamodb\",\n    \"aws-cdk-lib.aws_apigateway.RestApi\": \"apigateway\",\n    \"aws-cdk-lib.aws_apigateway.LambdaRestApi\": \"apigateway\",\n    \"aws-cdk-lib.aws_apigatewayv2.HttpApi\": \"apigatewayv2\",\n    \"aws-cdk-lib.aws_apigatewayv2_alpha.HttpApi\": \"apigatewayv2\",\n    \"aws-cdk-lib.aws_s3.Bucket\": \"s3\",\n    \"aws-cdk-lib.aws_sqs.Queue\": \"sqs\",\n    \"aws-cdk-lib.aws_sns.Topic\": \"sns\",\n    \"aws-cdk-lib.aws_stepfunctions.StateMachine\": \"stepfunctions\",\n    \"aws-cdk-lib.aws_events.Rule\": \"events\",\n}\n\n\n@dataclass\nclass ConstructNode:\n    \"\"\"A node in the CDK construct tree.\"\"\"\n\n    path: str\n    id: str\n    fqn: str | None = None\n    children: list[ConstructNode] = field(default_factory=list)\n    cfn_type: str | None = None\n\n    @property\n    def category(self) -> str | None:\n        \"\"\"Return a human-friendly resource category derived from the FQN.\"\"\"\n        if self.fqn is not None:\n            return FQN_CATEGORY_MAP.get(self.fqn)\n        return None\n\n\ndef _walk_node(node_data: dict) -> ConstructNode:\n    \"\"\"Recursively convert a raw tree-JSON dict into a ConstructNode.\"\"\"\n    path = node_data.get(\"path\", \"\")\n    node_id = node_data.get(\"id\", \"\")\n\n    construct_info = node_data.get(\"constructInfo\", {})\n    fqn = construct_info.get(\"fqn\") if construct_info else None\n\n    # Some leaf nodes carry an AWS CloudFormation type directly\n    cfn_type = (\n        node_data.get(\"attributes\", {}).get(\"aws:cdk:cloudformation:type\")\n        if node_data.get(\"attributes\")\n        else None\n    )\n\n    children: list[ConstructNode] = []\n    for child_data in (node_data.get(\"children\") or {}).values():\n        children.append(_walk_node(child_data))\n\n    return ConstructNode(\n        path=path,\n        id=node_id,\n        fqn=fqn,\n        children=children,\n        cfn_type=cfn_type,\n    )\n\n\ndef parse_tree(tree_json_path: Path) -> list[ConstructNode]:\n    \"\"\"Parse a CDK ``tree.json`` and return top-level construct nodes.\n\n    Parameters\n    ----------\n    tree_json_path:\n        Absolute or relative path to the ``tree.json`` file emitted by\n        ``cdk synth``.\n\n    Returns\n    -------\n    list[ConstructNode]\n        The immediate children of the tree root (typically one node per\n        CDK stack).\n    \"\"\"\n    with open(tree_json_path, encoding=\"utf-8\") as fh:\n        data = json.load(fh)\n\n    tree_root = data.get(\"tree\", data)\n\n    children: list[ConstructNode] = []\n    for child_data in (tree_root.get(\"children\") or {}).values():\n        children.append(_walk_node(child_data))\n\n    return children\n","numLines":109,"startLine":1,"totalLines":109}},"sourceToolAssistantUUID":"07b7631d-8243-40b2-8fb5-15f3bbbae181"}
{"parentUuid":"248810db-33a6-462e-927b-3114564a9eec","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","message":{"model":"claude-opus-4-6","id":"msg_01Rc6hbAU62CYKRBiSnJcYAj","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_0151zbeKZnbVjuESDnDXsNK5","name":"Read","input":{"file_path":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services/src/lws/providers/ssm/routes.py"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":5553,"cache_read_input_tokens":15470,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":5553},"output_tokens":2,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CY1FCABup89maXRijdjwj","type":"assistant","uuid":"80780eca-47da-41df-9de1-8bf7b4a0e3a0","timestamp":"2026-02-10T23:20:23.168Z"}
{"parentUuid":"80780eca-47da-41df-9de1-8bf7b4a0e3a0","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"callback"},"parentToolUseID":"toolu_0151zbeKZnbVjuESDnDXsNK5","toolUseID":"toolu_0151zbeKZnbVjuESDnDXsNK5","timestamp":"2026-02-10T23:20:23.175Z","uuid":"d9fea10d-44e0-4932-b315-ce696724d397"}
{"parentUuid":"80780eca-47da-41df-9de1-8bf7b4a0e3a0","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_0151zbeKZnbVjuESDnDXsNK5","type":"tool_result","content":"     1→\"\"\"SSM Parameter Store HTTP routes.\n     2→\n     3→Implements the SSM wire protocol that AWS SDKs and Terraform use,\n     4→using JSON request/response format with X-Amz-Target header dispatch.\n     5→\"\"\"\n     6→\n     7→from __future__ import annotations\n     8→\n     9→import json\n    10→import time\n    11→from typing import Any\n    12→\n    13→from fastapi import FastAPI, Request, Response\n    14→\n    15→from lws.logging.logger import get_logger\n    16→from lws.logging.middleware import RequestLoggingMiddleware\n    17→\n    18→_logger = get_logger(\"ldk.ssm\")\n    19→\n    20→_ACCOUNT_ID = \"000000000000\"\n    21→_REGION = \"us-east-1\"\n    22→\n    23→\n    24→# ------------------------------------------------------------------\n    25→# In-memory state\n    26→# ------------------------------------------------------------------\n    27→\n    28→\n    29→class _Parameter:\n    30→    \"\"\"Represents an SSM parameter.\"\"\"\n    31→\n    32→    def __init__(\n    33→        self,\n    34→        name: str,\n    35→        value: str,\n    36→        param_type: str = \"String\",\n    37→        description: str = \"\",\n    38→        tags: dict[str, str] | None = None,\n    39→    ) -> None:\n    40→        self.name = name\n    41→        self.value = value\n    42→        self.type = param_type\n    43→        self.description = description\n    44→        self.version = 1\n    45→        self.tags: dict[str, str] = tags or {}\n    46→        self.last_modified_date: float = time.time()\n    47→        self.arn = f\"arn:aws:ssm:{_REGION}:{_ACCOUNT_ID}:parameter{name}\"\n    48→\n    49→\n    50→class _SsmState:\n    51→    \"\"\"In-memory store for SSM parameters.\"\"\"\n    52→\n    53→    def __init__(self) -> None:\n    54→        self._parameters: dict[str, _Parameter] = {}\n    55→\n    56→\n    57→# ------------------------------------------------------------------\n    58→# Action handlers\n    59→# ------------------------------------------------------------------\n    60→\n    61→\n    62→async def _handle_put_parameter(state: _SsmState, body: dict) -> Response:\n    63→    name = body.get(\"Name\", \"\")\n    64→    value = body.get(\"Value\", \"\")\n    65→    param_type = body.get(\"Type\", \"String\")\n    66→    description = body.get(\"Description\", \"\")\n    67→    overwrite = body.get(\"Overwrite\", False)\n    68→    tags_list = body.get(\"Tags\", [])\n    69→    tags = {t[\"Key\"]: t[\"Value\"] for t in tags_list} if tags_list else {}\n    70→\n    71→    existing = state._parameters.get(name)\n    72→    if existing and not overwrite:\n    73→        return _error_response(\n    74→            \"ParameterAlreadyExists\",\n    75→            \"The parameter already exists. To overwrite set Overwrite to true.\",\n    76→        )\n    77→\n    78→    if existing:\n    79→        existing.value = value\n    80→        existing.type = param_type\n    81→        if description:\n    82→            existing.description = description\n    83→        existing.version += 1\n    84→        existing.last_modified_date = time.time()\n    85→        if tags:\n    86→            existing.tags.update(tags)\n    87→        version = existing.version\n    88→    else:\n    89→        param = _Parameter(\n    90→            name=name,\n    91→            value=value,\n    92→            param_type=param_type,\n    93→            description=description,\n    94→            tags=tags,\n    95→        )\n    96→        state._parameters[name] = param\n    97→        version = param.version\n    98→\n    99→    return _json_response({\"Version\": version, \"Tier\": \"Standard\"})\n   100→\n   101→\n   102→async def _handle_get_parameter(state: _SsmState, body: dict) -> Response:\n   103→    name = body.get(\"Name\", \"\")\n   104→    with_decryption = body.get(\"WithDecryption\", False)\n   105→    param = state._parameters.get(name)\n   106→    if param is None:\n   107→        return _error_response(\n   108→            \"ParameterNotFound\",\n   109→            f\"Parameter {name} not found.\",\n   110→            status_code=400,\n   111→        )\n   112→    return _json_response({\"Parameter\": _format_parameter(param, with_decryption=with_decryption)})\n   113→\n   114→\n   115→async def _handle_get_parameters(state: _SsmState, body: dict) -> Response:\n   116→    names = body.get(\"Names\", [])\n   117→    with_decryption = body.get(\"WithDecryption\", False)\n   118→    parameters = []\n   119→    invalid = []\n   120→    for name in names:\n   121→        param = state._parameters.get(name)\n   122→        if param:\n   123→            parameters.append(_format_parameter(param, with_decryption=with_decryption))\n   124→        else:\n   125→            invalid.append(name)\n   126→    return _json_response({\"Parameters\": parameters, \"InvalidParameters\": invalid})\n   127→\n   128→\n   129→async def _handle_get_parameters_by_path(state: _SsmState, body: dict) -> Response:\n   130→    path = body.get(\"Path\", \"/\")\n   131→    recursive = body.get(\"Recursive\", False)\n   132→    with_decryption = body.get(\"WithDecryption\", False)\n   133→\n   134→    parameters = []\n   135→    for name, param in state._parameters.items():\n   136→        if recursive:\n   137→            if name.startswith(path):\n   138→                parameters.append(_format_parameter(param, with_decryption=with_decryption))\n   139→        else:\n   140→            # Non-recursive: only direct children\n   141→            if name.startswith(path):\n   142→                remainder = name[len(path) :].lstrip(\"/\")\n   143→                if \"/\" not in remainder:\n   144→                    parameters.append(_format_parameter(param, with_decryption=with_decryption))\n   145→\n   146→    return _json_response({\"Parameters\": parameters})\n   147→\n   148→\n   149→async def _handle_delete_parameter(state: _SsmState, body: dict) -> Response:\n   150→    name = body.get(\"Name\", \"\")\n   151→    if name not in state._parameters:\n   152→        return _error_response(\n   153→            \"ParameterNotFound\",\n   154→            f\"Parameter {name} not found.\",\n   155→            status_code=400,\n   156→        )\n   157→    del state._parameters[name]\n   158→    return _json_response({})\n   159→\n   160→\n   161→async def _handle_delete_parameters(state: _SsmState, body: dict) -> Response:\n   162→    names = body.get(\"Names\", [])\n   163→    deleted = []\n   164→    invalid = []\n   165→    for name in names:\n   166→        if name in state._parameters:\n   167→            del state._parameters[name]\n   168→            deleted.append(name)\n   169→        else:\n   170→            invalid.append(name)\n   171→    return _json_response({\"DeletedParameters\": deleted, \"InvalidParameters\": invalid})\n   172→\n   173→\n   174→async def _handle_describe_parameters(state: _SsmState, body: dict) -> Response:\n   175→    filters = body.get(\"ParameterFilters\", [])\n   176→    params_list = list(state._parameters.values())\n   177→\n   178→    # Apply basic name filtering\n   179→    for f in filters:\n   180→        key = f.get(\"Key\", \"\")\n   181→        values = f.get(\"Values\", [])\n   182→        option = f.get(\"Option\", \"Equals\")\n   183→        if key == \"Name\":\n   184→            if option == \"Equals\":\n   185→                params_list = [p for p in params_list if p.name in values]\n   186→            elif option == \"BeginsWith\":\n   187→                params_list = [p for p in params_list if any(p.name.startswith(v) for v in values)]\n   188→            elif option == \"Contains\":\n   189→                params_list = [p for p in params_list if any(v in p.name for v in values)]\n   190→\n   191→    descriptions = [_format_parameter_metadata(p) for p in params_list]\n   192→    return _json_response({\"Parameters\": descriptions})\n   193→\n   194→\n   195→async def _handle_add_tags_to_resource(state: _SsmState, body: dict) -> Response:\n   196→    resource_id = body.get(\"ResourceId\", \"\")\n   197→    resource_type = body.get(\"ResourceType\", \"Parameter\")\n   198→    tags_list = body.get(\"Tags\", [])\n   199→\n   200→    if resource_type == \"Parameter\":\n   201→        param = state._parameters.get(resource_id)\n   202→        if param is None:\n   203→            return _error_response(\n   204→                \"InvalidResourceId\",\n   205→                f\"Parameter {resource_id} not found.\",\n   206→                status_code=400,\n   207→            )\n   208→        for tag in tags_list:\n   209→            param.tags[tag[\"Key\"]] = tag[\"Value\"]\n   210→\n   211→    return _json_response({})\n   212→\n   213→\n   214→async def _handle_remove_tags_from_resource(state: _SsmState, body: dict) -> Response:\n   215→    resource_id = body.get(\"ResourceId\", \"\")\n   216→    resource_type = body.get(\"ResourceType\", \"Parameter\")\n   217→    tag_keys = body.get(\"TagKeys\", [])\n   218→\n   219→    if resource_type == \"Parameter\":\n   220→        param = state._parameters.get(resource_id)\n   221→        if param is None:\n   222→            return _error_response(\n   223→                \"InvalidResourceId\",\n   224→                f\"Parameter {resource_id} not found.\",\n   225→                status_code=400,\n   226→            )\n   227→        for key in tag_keys:\n   228→            param.tags.pop(key, None)\n   229→\n   230→    return _json_response({})\n   231→\n   232→\n   233→async def _handle_list_tags_for_resource(state: _SsmState, body: dict) -> Response:\n   234→    resource_id = body.get(\"ResourceId\", \"\")\n   235→    resource_type = body.get(\"ResourceType\", \"Parameter\")\n   236→\n   237→    tags: list[dict[str, str]] = []\n   238→    if resource_type == \"Parameter\":\n   239→        param = state._parameters.get(resource_id)\n   240→        if param is not None:\n   241→            tags = [{\"Key\": k, \"Value\": v} for k, v in param.tags.items()]\n   242→\n   243→    return _json_response({\"TagList\": tags})\n   244→\n   245→\n   246→# ------------------------------------------------------------------\n   247→# Helpers\n   248→# ------------------------------------------------------------------\n   249→\n   250→\n   251→def _format_parameter(param: _Parameter, *, with_decryption: bool = False) -> dict[str, Any]:\n   252→    \"\"\"Format a parameter for API response.\"\"\"\n   253→    value = param.value\n   254→    if param.type == \"SecureString\" and not with_decryption:\n   255→        value = \"***\"\n   256→    return {\n   257→        \"Name\": param.name,\n   258→        \"Type\": param.type,\n   259→        \"Value\": value,\n   260→        \"Version\": param.version,\n   261→        \"LastModifiedDate\": param.last_modified_date,\n   262→        \"ARN\": param.arn,\n   263→        \"DataType\": \"text\",\n   264→    }\n   265→\n   266→\n   267→def _format_parameter_metadata(param: _Parameter) -> dict[str, Any]:\n   268→    \"\"\"Format a parameter for DescribeParameters response.\"\"\"\n   269→    return {\n   270→        \"Name\": param.name,\n   271→        \"Type\": param.type,\n   272→        \"Description\": param.description,\n   273→        \"Version\": param.version,\n   274→        \"LastModifiedDate\": param.last_modified_date,\n   275→        \"ARN\": param.arn,\n   276→        \"Tier\": \"Standard\",\n   277→        \"DataType\": \"text\",\n   278→    }\n   279→\n   280→\n   281→def _json_response(data: dict, status_code: int = 200) -> Response:\n   282→    \"\"\"Return a JSON response.\"\"\"\n   283→    return Response(\n   284→        content=json.dumps(data, default=str),\n   285→        status_code=status_code,\n   286→        media_type=\"application/x-amz-json-1.1\",\n   287→    )\n   288→\n   289→\n   290→def _error_response(code: str, message: str, status_code: int = 400) -> Response:\n   291→    \"\"\"Return an error response in SSM format.\"\"\"\n   292→    error_body = {\"__type\": code, \"message\": message}\n   293→    return _json_response(error_body, status_code=status_code)\n   294→\n   295→\n   296→# ------------------------------------------------------------------\n   297→# Action dispatch table\n   298→# ------------------------------------------------------------------\n   299→\n   300→\n   301→_ACTION_HANDLERS: dict[str, Any] = {\n   302→    \"PutParameter\": _handle_put_parameter,\n   303→    \"GetParameter\": _handle_get_parameter,\n   304→    \"GetParameters\": _handle_get_parameters,\n   305→    \"GetParametersByPath\": _handle_get_parameters_by_path,\n   306→    \"DeleteParameter\": _handle_delete_parameter,\n   307→    \"DeleteParameters\": _handle_delete_parameters,\n   308→    \"DescribeParameters\": _handle_describe_parameters,\n   309→    \"AddTagsToResource\": _handle_add_tags_to_resource,\n   310→    \"RemoveTagsFromResource\": _handle_remove_tags_from_resource,\n   311→    \"ListTagsForResource\": _handle_list_tags_for_resource,\n   312→}\n   313→\n   314→\n   315→# ------------------------------------------------------------------\n   316→# App factory\n   317→# ------------------------------------------------------------------\n   318→\n   319→\n   320→def create_ssm_app() -> FastAPI:\n   321→    \"\"\"Create a FastAPI application that speaks the SSM wire protocol.\"\"\"\n   322→    app = FastAPI(title=\"LDK SSM\")\n   323→    app.add_middleware(RequestLoggingMiddleware, logger=_logger, service_name=\"ssm\")\n   324→    state = _SsmState()\n   325→\n   326→    @app.post(\"/\")\n   327→    async def dispatch(request: Request) -> Response:\n   328→        target = request.headers.get(\"x-amz-target\", \"\")\n   329→        body = await _parse_request_body(request)\n   330→        action = _resolve_action(target, body)\n   331→\n   332→        handler = _ACTION_HANDLERS.get(action)\n   333→        if handler is None:\n   334→            _logger.warning(\"Unknown SSM action: %s\", action)\n   335→            return _error_response(\n   336→                \"InvalidAction\",\n   337→                f\"lws: SSM operation '{action}' is not yet implemented\",\n   338→            )\n   339→\n   340→        return await handler(state, body)\n   341→\n   342→    return app\n   343→\n   344→\n   345→async def _parse_request_body(request: Request) -> dict:\n   346→    \"\"\"Parse the JSON request body.\"\"\"\n   347→    body_bytes = await request.body()\n   348→    if not body_bytes:\n   349→        return {}\n   350→    try:\n   351→        return json.loads(body_bytes)\n   352→    except json.JSONDecodeError:\n   353→        return {}\n   354→\n   355→\n   356→def _resolve_action(target: str, body: dict) -> str:\n   357→    \"\"\"Resolve the API action from the target header or body.\"\"\"\n   358→    if target:\n   359→        # X-Amz-Target format: AmazonSSM.PutParameter\n   360→        return target.rsplit(\".\", 1)[-1] if \".\" in target else target\n   361→    return body.get(\"Action\", \"\")\n   362→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"506f88eb-467b-47c8-9ecf-da0840a78cad","timestamp":"2026-02-10T23:20:23.174Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services/src/lws/providers/ssm/routes.py","content":"\"\"\"SSM Parameter Store HTTP routes.\n\nImplements the SSM wire protocol that AWS SDKs and Terraform use,\nusing JSON request/response format with X-Amz-Target header dispatch.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport json\nimport time\nfrom typing import Any\n\nfrom fastapi import FastAPI, Request, Response\n\nfrom lws.logging.logger import get_logger\nfrom lws.logging.middleware import RequestLoggingMiddleware\n\n_logger = get_logger(\"ldk.ssm\")\n\n_ACCOUNT_ID = \"000000000000\"\n_REGION = \"us-east-1\"\n\n\n# ------------------------------------------------------------------\n# In-memory state\n# ------------------------------------------------------------------\n\n\nclass _Parameter:\n    \"\"\"Represents an SSM parameter.\"\"\"\n\n    def __init__(\n        self,\n        name: str,\n        value: str,\n        param_type: str = \"String\",\n        description: str = \"\",\n        tags: dict[str, str] | None = None,\n    ) -> None:\n        self.name = name\n        self.value = value\n        self.type = param_type\n        self.description = description\n        self.version = 1\n        self.tags: dict[str, str] = tags or {}\n        self.last_modified_date: float = time.time()\n        self.arn = f\"arn:aws:ssm:{_REGION}:{_ACCOUNT_ID}:parameter{name}\"\n\n\nclass _SsmState:\n    \"\"\"In-memory store for SSM parameters.\"\"\"\n\n    def __init__(self) -> None:\n        self._parameters: dict[str, _Parameter] = {}\n\n\n# ------------------------------------------------------------------\n# Action handlers\n# ------------------------------------------------------------------\n\n\nasync def _handle_put_parameter(state: _SsmState, body: dict) -> Response:\n    name = body.get(\"Name\", \"\")\n    value = body.get(\"Value\", \"\")\n    param_type = body.get(\"Type\", \"String\")\n    description = body.get(\"Description\", \"\")\n    overwrite = body.get(\"Overwrite\", False)\n    tags_list = body.get(\"Tags\", [])\n    tags = {t[\"Key\"]: t[\"Value\"] for t in tags_list} if tags_list else {}\n\n    existing = state._parameters.get(name)\n    if existing and not overwrite:\n        return _error_response(\n            \"ParameterAlreadyExists\",\n            \"The parameter already exists. To overwrite set Overwrite to true.\",\n        )\n\n    if existing:\n        existing.value = value\n        existing.type = param_type\n        if description:\n            existing.description = description\n        existing.version += 1\n        existing.last_modified_date = time.time()\n        if tags:\n            existing.tags.update(tags)\n        version = existing.version\n    else:\n        param = _Parameter(\n            name=name,\n            value=value,\n            param_type=param_type,\n            description=description,\n            tags=tags,\n        )\n        state._parameters[name] = param\n        version = param.version\n\n    return _json_response({\"Version\": version, \"Tier\": \"Standard\"})\n\n\nasync def _handle_get_parameter(state: _SsmState, body: dict) -> Response:\n    name = body.get(\"Name\", \"\")\n    with_decryption = body.get(\"WithDecryption\", False)\n    param = state._parameters.get(name)\n    if param is None:\n        return _error_response(\n            \"ParameterNotFound\",\n            f\"Parameter {name} not found.\",\n            status_code=400,\n        )\n    return _json_response({\"Parameter\": _format_parameter(param, with_decryption=with_decryption)})\n\n\nasync def _handle_get_parameters(state: _SsmState, body: dict) -> Response:\n    names = body.get(\"Names\", [])\n    with_decryption = body.get(\"WithDecryption\", False)\n    parameters = []\n    invalid = []\n    for name in names:\n        param = state._parameters.get(name)\n        if param:\n            parameters.append(_format_parameter(param, with_decryption=with_decryption))\n        else:\n            invalid.append(name)\n    return _json_response({\"Parameters\": parameters, \"InvalidParameters\": invalid})\n\n\nasync def _handle_get_parameters_by_path(state: _SsmState, body: dict) -> Response:\n    path = body.get(\"Path\", \"/\")\n    recursive = body.get(\"Recursive\", False)\n    with_decryption = body.get(\"WithDecryption\", False)\n\n    parameters = []\n    for name, param in state._parameters.items():\n        if recursive:\n            if name.startswith(path):\n                parameters.append(_format_parameter(param, with_decryption=with_decryption))\n        else:\n            # Non-recursive: only direct children\n            if name.startswith(path):\n                remainder = name[len(path) :].lstrip(\"/\")\n                if \"/\" not in remainder:\n                    parameters.append(_format_parameter(param, with_decryption=with_decryption))\n\n    return _json_response({\"Parameters\": parameters})\n\n\nasync def _handle_delete_parameter(state: _SsmState, body: dict) -> Response:\n    name = body.get(\"Name\", \"\")\n    if name not in state._parameters:\n        return _error_response(\n            \"ParameterNotFound\",\n            f\"Parameter {name} not found.\",\n            status_code=400,\n        )\n    del state._parameters[name]\n    return _json_response({})\n\n\nasync def _handle_delete_parameters(state: _SsmState, body: dict) -> Response:\n    names = body.get(\"Names\", [])\n    deleted = []\n    invalid = []\n    for name in names:\n        if name in state._parameters:\n            del state._parameters[name]\n            deleted.append(name)\n        else:\n            invalid.append(name)\n    return _json_response({\"DeletedParameters\": deleted, \"InvalidParameters\": invalid})\n\n\nasync def _handle_describe_parameters(state: _SsmState, body: dict) -> Response:\n    filters = body.get(\"ParameterFilters\", [])\n    params_list = list(state._parameters.values())\n\n    # Apply basic name filtering\n    for f in filters:\n        key = f.get(\"Key\", \"\")\n        values = f.get(\"Values\", [])\n        option = f.get(\"Option\", \"Equals\")\n        if key == \"Name\":\n            if option == \"Equals\":\n                params_list = [p for p in params_list if p.name in values]\n            elif option == \"BeginsWith\":\n                params_list = [p for p in params_list if any(p.name.startswith(v) for v in values)]\n            elif option == \"Contains\":\n                params_list = [p for p in params_list if any(v in p.name for v in values)]\n\n    descriptions = [_format_parameter_metadata(p) for p in params_list]\n    return _json_response({\"Parameters\": descriptions})\n\n\nasync def _handle_add_tags_to_resource(state: _SsmState, body: dict) -> Response:\n    resource_id = body.get(\"ResourceId\", \"\")\n    resource_type = body.get(\"ResourceType\", \"Parameter\")\n    tags_list = body.get(\"Tags\", [])\n\n    if resource_type == \"Parameter\":\n        param = state._parameters.get(resource_id)\n        if param is None:\n            return _error_response(\n                \"InvalidResourceId\",\n                f\"Parameter {resource_id} not found.\",\n                status_code=400,\n            )\n        for tag in tags_list:\n            param.tags[tag[\"Key\"]] = tag[\"Value\"]\n\n    return _json_response({})\n\n\nasync def _handle_remove_tags_from_resource(state: _SsmState, body: dict) -> Response:\n    resource_id = body.get(\"ResourceId\", \"\")\n    resource_type = body.get(\"ResourceType\", \"Parameter\")\n    tag_keys = body.get(\"TagKeys\", [])\n\n    if resource_type == \"Parameter\":\n        param = state._parameters.get(resource_id)\n        if param is None:\n            return _error_response(\n                \"InvalidResourceId\",\n                f\"Parameter {resource_id} not found.\",\n                status_code=400,\n            )\n        for key in tag_keys:\n            param.tags.pop(key, None)\n\n    return _json_response({})\n\n\nasync def _handle_list_tags_for_resource(state: _SsmState, body: dict) -> Response:\n    resource_id = body.get(\"ResourceId\", \"\")\n    resource_type = body.get(\"ResourceType\", \"Parameter\")\n\n    tags: list[dict[str, str]] = []\n    if resource_type == \"Parameter\":\n        param = state._parameters.get(resource_id)\n        if param is not None:\n            tags = [{\"Key\": k, \"Value\": v} for k, v in param.tags.items()]\n\n    return _json_response({\"TagList\": tags})\n\n\n# ------------------------------------------------------------------\n# Helpers\n# ------------------------------------------------------------------\n\n\ndef _format_parameter(param: _Parameter, *, with_decryption: bool = False) -> dict[str, Any]:\n    \"\"\"Format a parameter for API response.\"\"\"\n    value = param.value\n    if param.type == \"SecureString\" and not with_decryption:\n        value = \"***\"\n    return {\n        \"Name\": param.name,\n        \"Type\": param.type,\n        \"Value\": value,\n        \"Version\": param.version,\n        \"LastModifiedDate\": param.last_modified_date,\n        \"ARN\": param.arn,\n        \"DataType\": \"text\",\n    }\n\n\ndef _format_parameter_metadata(param: _Parameter) -> dict[str, Any]:\n    \"\"\"Format a parameter for DescribeParameters response.\"\"\"\n    return {\n        \"Name\": param.name,\n        \"Type\": param.type,\n        \"Description\": param.description,\n        \"Version\": param.version,\n        \"LastModifiedDate\": param.last_modified_date,\n        \"ARN\": param.arn,\n        \"Tier\": \"Standard\",\n        \"DataType\": \"text\",\n    }\n\n\ndef _json_response(data: dict, status_code: int = 200) -> Response:\n    \"\"\"Return a JSON response.\"\"\"\n    return Response(\n        content=json.dumps(data, default=str),\n        status_code=status_code,\n        media_type=\"application/x-amz-json-1.1\",\n    )\n\n\ndef _error_response(code: str, message: str, status_code: int = 400) -> Response:\n    \"\"\"Return an error response in SSM format.\"\"\"\n    error_body = {\"__type\": code, \"message\": message}\n    return _json_response(error_body, status_code=status_code)\n\n\n# ------------------------------------------------------------------\n# Action dispatch table\n# ------------------------------------------------------------------\n\n\n_ACTION_HANDLERS: dict[str, Any] = {\n    \"PutParameter\": _handle_put_parameter,\n    \"GetParameter\": _handle_get_parameter,\n    \"GetParameters\": _handle_get_parameters,\n    \"GetParametersByPath\": _handle_get_parameters_by_path,\n    \"DeleteParameter\": _handle_delete_parameter,\n    \"DeleteParameters\": _handle_delete_parameters,\n    \"DescribeParameters\": _handle_describe_parameters,\n    \"AddTagsToResource\": _handle_add_tags_to_resource,\n    \"RemoveTagsFromResource\": _handle_remove_tags_from_resource,\n    \"ListTagsForResource\": _handle_list_tags_for_resource,\n}\n\n\n# ------------------------------------------------------------------\n# App factory\n# ------------------------------------------------------------------\n\n\ndef create_ssm_app() -> FastAPI:\n    \"\"\"Create a FastAPI application that speaks the SSM wire protocol.\"\"\"\n    app = FastAPI(title=\"LDK SSM\")\n    app.add_middleware(RequestLoggingMiddleware, logger=_logger, service_name=\"ssm\")\n    state = _SsmState()\n\n    @app.post(\"/\")\n    async def dispatch(request: Request) -> Response:\n        target = request.headers.get(\"x-amz-target\", \"\")\n        body = await _parse_request_body(request)\n        action = _resolve_action(target, body)\n\n        handler = _ACTION_HANDLERS.get(action)\n        if handler is None:\n            _logger.warning(\"Unknown SSM action: %s\", action)\n            return _error_response(\n                \"InvalidAction\",\n                f\"lws: SSM operation '{action}' is not yet implemented\",\n            )\n\n        return await handler(state, body)\n\n    return app\n\n\nasync def _parse_request_body(request: Request) -> dict:\n    \"\"\"Parse the JSON request body.\"\"\"\n    body_bytes = await request.body()\n    if not body_bytes:\n        return {}\n    try:\n        return json.loads(body_bytes)\n    except json.JSONDecodeError:\n        return {}\n\n\ndef _resolve_action(target: str, body: dict) -> str:\n    \"\"\"Resolve the API action from the target header or body.\"\"\"\n    if target:\n        # X-Amz-Target format: AmazonSSM.PutParameter\n        return target.rsplit(\".\", 1)[-1] if \".\" in target else target\n    return body.get(\"Action\", \"\")\n","numLines":362,"startLine":1,"totalLines":362}},"sourceToolAssistantUUID":"80780eca-47da-41df-9de1-8bf7b4a0e3a0"}
{"parentUuid":"506f88eb-467b-47c8-9ecf-da0840a78cad","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","message":{"model":"claude-opus-4-6","id":"msg_01Rc6hbAU62CYKRBiSnJcYAj","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Xj2JHEgcWC1hwH5oizn4Ny","name":"Read","input":{"file_path":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services/src/lws/providers/secretsmanager/routes.py"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":5553,"cache_read_input_tokens":15470,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":5553},"output_tokens":2,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CY1FCABup89maXRijdjwj","type":"assistant","uuid":"2cf318b4-7e90-4814-83f9-1900e9d68daf","timestamp":"2026-02-10T23:20:23.714Z"}
{"parentUuid":"2cf318b4-7e90-4814-83f9-1900e9d68daf","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"callback"},"parentToolUseID":"toolu_01Xj2JHEgcWC1hwH5oizn4Ny","toolUseID":"toolu_01Xj2JHEgcWC1hwH5oizn4Ny","timestamp":"2026-02-10T23:20:23.721Z","uuid":"0e9971ce-580b-4174-b3a9-486c7a3c0082"}
{"parentUuid":"2cf318b4-7e90-4814-83f9-1900e9d68daf","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Xj2JHEgcWC1hwH5oizn4Ny","type":"tool_result","content":"     1→\"\"\"Secrets Manager HTTP routes.\n     2→\n     3→Implements the Secrets Manager wire protocol that AWS SDKs and Terraform use,\n     4→using JSON request/response format with X-Amz-Target header dispatch.\n     5→\"\"\"\n     6→\n     7→from __future__ import annotations\n     8→\n     9→import json\n    10→import time\n    11→import uuid\n    12→from typing import Any\n    13→\n    14→from fastapi import FastAPI, Request, Response\n    15→\n    16→from lws.logging.logger import get_logger\n    17→from lws.logging.middleware import RequestLoggingMiddleware\n    18→\n    19→_logger = get_logger(\"ldk.secretsmanager\")\n    20→\n    21→_ACCOUNT_ID = \"000000000000\"\n    22→_REGION = \"us-east-1\"\n    23→\n    24→\n    25→# ------------------------------------------------------------------\n    26→# In-memory state\n    27→# ------------------------------------------------------------------\n    28→\n    29→\n    30→class _SecretVersion:\n    31→    \"\"\"A single version of a secret.\"\"\"\n    32→\n    33→    def __init__(\n    34→        self,\n    35→        version_id: str,\n    36→        secret_string: str | None = None,\n    37→        secret_binary: str | None = None,\n    38→        stages: list[str] | None = None,\n    39→    ) -> None:\n    40→        self.version_id = version_id\n    41→        self.secret_string = secret_string\n    42→        self.secret_binary = secret_binary\n    43→        self.stages = stages or [\"AWSCURRENT\"]\n    44→        self.created_date: float = time.time()\n    45→\n    46→\n    47→class _Secret:\n    48→    \"\"\"Represents a Secrets Manager secret.\"\"\"\n    49→\n    50→    def __init__(\n    51→        self,\n    52→        name: str,\n    53→        description: str = \"\",\n    54→        tags: dict[str, str] | None = None,\n    55→    ) -> None:\n    56→        self.name = name\n    57→        self.arn = f\"arn:aws:secretsmanager:{_REGION}:{_ACCOUNT_ID}:secret:{name}\"\n    58→        self.description = description\n    59→        self.tags: dict[str, str] = tags or {}\n    60→        self.versions: dict[str, _SecretVersion] = {}\n    61→        self.current_version_id: str | None = None\n    62→        self.deleted_date: float | None = None\n    63→        self.created_date: float = time.time()\n    64→        self.last_changed_date: float = time.time()\n    65→\n    66→\n    67→class _SecretsState:\n    68→    \"\"\"In-memory store for Secrets Manager secrets.\"\"\"\n    69→\n    70→    def __init__(self) -> None:\n    71→        self._secrets: dict[str, _Secret] = {}\n    72→\n    73→\n    74→# ------------------------------------------------------------------\n    75→# Action handlers\n    76→# ------------------------------------------------------------------\n    77→\n    78→\n    79→async def _handle_create_secret(state: _SecretsState, body: dict) -> Response:\n    80→    name = body.get(\"Name\", \"\")\n    81→    description = body.get(\"Description\", \"\")\n    82→    secret_string = body.get(\"SecretString\")\n    83→    secret_binary = body.get(\"SecretBinary\")\n    84→    tags_list = body.get(\"Tags\", [])\n    85→    tags = {t[\"Key\"]: t[\"Value\"] for t in tags_list} if tags_list else {}\n    86→\n    87→    if name in state._secrets:\n    88→        existing = state._secrets[name]\n    89→        if existing.deleted_date is not None:\n    90→            # Restore soft-deleted secret\n    91→            existing.deleted_date = None\n    92→            existing.description = description\n    93→            existing.tags = tags\n    94→        else:\n    95→            return _error_response(\n    96→                \"ResourceExistsException\",\n    97→                f\"The secret {name} already exists.\",\n    98→            )\n    99→\n   100→    secret = _Secret(name=name, description=description, tags=tags)\n   101→    state._secrets[name] = secret\n   102→\n   103→    version_id: str | None = None\n   104→    if secret_string is not None or secret_binary is not None:\n   105→        version_id = str(uuid.uuid4())\n   106→        version = _SecretVersion(\n   107→            version_id=version_id,\n   108→            secret_string=secret_string,\n   109→            secret_binary=secret_binary,\n   110→            stages=[\"AWSCURRENT\"],\n   111→        )\n   112→        secret.versions[version_id] = version\n   113→        secret.current_version_id = version_id\n   114→\n   115→    result: dict[str, Any] = {\"ARN\": secret.arn, \"Name\": name}\n   116→    if version_id:\n   117→        result[\"VersionId\"] = version_id\n   118→    return _json_response(result)\n   119→\n   120→\n   121→async def _handle_get_secret_value(state: _SecretsState, body: dict) -> Response:\n   122→    secret_id = body.get(\"SecretId\", \"\")\n   123→    version_id = body.get(\"VersionId\")\n   124→    version_stage = body.get(\"VersionStage\", \"AWSCURRENT\")\n   125→\n   126→    secret = _find_secret(state, secret_id)\n   127→    if secret is None or secret.deleted_date is not None:\n   128→        return _error_response(\n   129→            \"ResourceNotFoundException\",\n   130→            f\"Secret {secret_id} not found.\",\n   131→        )\n   132→\n   133→    version = _resolve_version(secret, version_id, version_stage)\n   134→    if version is None:\n   135→        return _error_response(\n   136→            \"ResourceNotFoundException\",\n   137→            f\"No version found for secret {secret_id}.\",\n   138→        )\n   139→\n   140→    result: dict[str, Any] = {\n   141→        \"ARN\": secret.arn,\n   142→        \"Name\": secret.name,\n   143→        \"VersionId\": version.version_id,\n   144→        \"VersionStages\": version.stages,\n   145→        \"CreatedDate\": version.created_date,\n   146→    }\n   147→    if version.secret_string is not None:\n   148→        result[\"SecretString\"] = version.secret_string\n   149→    if version.secret_binary is not None:\n   150→        result[\"SecretBinary\"] = version.secret_binary\n   151→    return _json_response(result)\n   152→\n   153→\n   154→async def _handle_put_secret_value(state: _SecretsState, body: dict) -> Response:\n   155→    secret_id = body.get(\"SecretId\", \"\")\n   156→    secret_string = body.get(\"SecretString\")\n   157→    secret_binary = body.get(\"SecretBinary\")\n   158→\n   159→    secret = _find_secret(state, secret_id)\n   160→    if secret is None or secret.deleted_date is not None:\n   161→        return _error_response(\n   162→            \"ResourceNotFoundException\",\n   163→            f\"Secret {secret_id} not found.\",\n   164→        )\n   165→\n   166→    # Move AWSCURRENT from old version\n   167→    if secret.current_version_id and secret.current_version_id in secret.versions:\n   168→        old = secret.versions[secret.current_version_id]\n   169→        if \"AWSCURRENT\" in old.stages:\n   170→            old.stages.remove(\"AWSCURRENT\")\n   171→        if \"AWSPREVIOUS\" not in old.stages:\n   172→            old.stages.append(\"AWSPREVIOUS\")\n   173→\n   174→    version_id = str(uuid.uuid4())\n   175→    version = _SecretVersion(\n   176→        version_id=version_id,\n   177→        secret_string=secret_string,\n   178→        secret_binary=secret_binary,\n   179→        stages=[\"AWSCURRENT\"],\n   180→    )\n   181→    secret.versions[version_id] = version\n   182→    secret.current_version_id = version_id\n   183→    secret.last_changed_date = time.time()\n   184→\n   185→    return _json_response({\"ARN\": secret.arn, \"Name\": secret.name, \"VersionId\": version_id})\n   186→\n   187→\n   188→async def _handle_update_secret(state: _SecretsState, body: dict) -> Response:\n   189→    secret_id = body.get(\"SecretId\", \"\")\n   190→    description = body.get(\"Description\")\n   191→    secret_string = body.get(\"SecretString\")\n   192→    secret_binary = body.get(\"SecretBinary\")\n   193→\n   194→    secret = _find_secret(state, secret_id)\n   195→    if secret is None or secret.deleted_date is not None:\n   196→        return _error_response(\n   197→            \"ResourceNotFoundException\",\n   198→            f\"Secret {secret_id} not found.\",\n   199→        )\n   200→\n   201→    if description is not None:\n   202→        secret.description = description\n   203→\n   204→    version_id: str | None = None\n   205→    if secret_string is not None or secret_binary is not None:\n   206→        # Move AWSCURRENT from old version\n   207→        if secret.current_version_id and secret.current_version_id in secret.versions:\n   208→            old = secret.versions[secret.current_version_id]\n   209→            if \"AWSCURRENT\" in old.stages:\n   210→                old.stages.remove(\"AWSCURRENT\")\n   211→            if \"AWSPREVIOUS\" not in old.stages:\n   212→                old.stages.append(\"AWSPREVIOUS\")\n   213→\n   214→        version_id = str(uuid.uuid4())\n   215→        version = _SecretVersion(\n   216→            version_id=version_id,\n   217→            secret_string=secret_string,\n   218→            secret_binary=secret_binary,\n   219→            stages=[\"AWSCURRENT\"],\n   220→        )\n   221→        secret.versions[version_id] = version\n   222→        secret.current_version_id = version_id\n   223→\n   224→    secret.last_changed_date = time.time()\n   225→    result: dict[str, Any] = {\"ARN\": secret.arn, \"Name\": secret.name}\n   226→    if version_id:\n   227→        result[\"VersionId\"] = version_id\n   228→    return _json_response(result)\n   229→\n   230→\n   231→async def _handle_delete_secret(state: _SecretsState, body: dict) -> Response:\n   232→    secret_id = body.get(\"SecretId\", \"\")\n   233→    force_delete = body.get(\"ForceDeleteWithoutRecovery\", False)\n   234→\n   235→    secret = _find_secret(state, secret_id)\n   236→    if secret is None:\n   237→        return _error_response(\n   238→            \"ResourceNotFoundException\",\n   239→            f\"Secret {secret_id} not found.\",\n   240→        )\n   241→\n   242→    if force_delete:\n   243→        state._secrets.pop(secret.name, None)\n   244→    else:\n   245→        secret.deleted_date = time.time()\n   246→\n   247→    return _json_response(\n   248→        {\n   249→            \"ARN\": secret.arn,\n   250→            \"Name\": secret.name,\n   251→            \"DeletionDate\": secret.deleted_date or time.time(),\n   252→        }\n   253→    )\n   254→\n   255→\n   256→async def _handle_describe_secret(state: _SecretsState, body: dict) -> Response:\n   257→    secret_id = body.get(\"SecretId\", \"\")\n   258→    secret = _find_secret(state, secret_id)\n   259→    if secret is None:\n   260→        return _error_response(\n   261→            \"ResourceNotFoundException\",\n   262→            f\"Secret {secret_id} not found.\",\n   263→        )\n   264→    return _json_response(_format_secret_description(secret))\n   265→\n   266→\n   267→async def _handle_list_secrets(state: _SecretsState, body: dict) -> Response:\n   268→    secrets = [\n   269→        _format_secret_description(s) for s in state._secrets.values() if s.deleted_date is None\n   270→    ]\n   271→    return _json_response({\"SecretList\": secrets})\n   272→\n   273→\n   274→async def _handle_restore_secret(state: _SecretsState, body: dict) -> Response:\n   275→    secret_id = body.get(\"SecretId\", \"\")\n   276→    secret = _find_secret(state, secret_id)\n   277→    if secret is None:\n   278→        return _error_response(\n   279→            \"ResourceNotFoundException\",\n   280→            f\"Secret {secret_id} not found.\",\n   281→        )\n   282→    if secret.deleted_date is None:\n   283→        return _error_response(\n   284→            \"InvalidRequestException\",\n   285→            f\"Secret {secret_id} is not scheduled for deletion.\",\n   286→        )\n   287→    secret.deleted_date = None\n   288→    return _json_response({\"ARN\": secret.arn, \"Name\": secret.name})\n   289→\n   290→\n   291→async def _handle_tag_resource(state: _SecretsState, body: dict) -> Response:\n   292→    secret_id = body.get(\"SecretId\", \"\")\n   293→    tags_list = body.get(\"Tags\", [])\n   294→\n   295→    secret = _find_secret(state, secret_id)\n   296→    if secret is None:\n   297→        return _error_response(\n   298→            \"ResourceNotFoundException\",\n   299→            f\"Secret {secret_id} not found.\",\n   300→        )\n   301→\n   302→    for tag in tags_list:\n   303→        secret.tags[tag[\"Key\"]] = tag[\"Value\"]\n   304→    return _json_response({})\n   305→\n   306→\n   307→async def _handle_untag_resource(state: _SecretsState, body: dict) -> Response:\n   308→    secret_id = body.get(\"SecretId\", \"\")\n   309→    tag_keys = body.get(\"TagKeys\", [])\n   310→\n   311→    secret = _find_secret(state, secret_id)\n   312→    if secret is None:\n   313→        return _error_response(\n   314→            \"ResourceNotFoundException\",\n   315→            f\"Secret {secret_id} not found.\",\n   316→        )\n   317→\n   318→    for key in tag_keys:\n   319→        secret.tags.pop(key, None)\n   320→    return _json_response({})\n   321→\n   322→\n   323→async def _handle_get_resource_policy(state: _SecretsState, body: dict) -> Response:\n   324→    secret_id = body.get(\"SecretId\", \"\")\n   325→    secret = _find_secret(state, secret_id)\n   326→    if secret is None:\n   327→        return _error_response(\n   328→            \"ResourceNotFoundException\",\n   329→            f\"Secret {secret_id} not found.\",\n   330→        )\n   331→    return _json_response({\"ARN\": secret.arn, \"Name\": secret.name})\n   332→\n   333→\n   334→async def _handle_list_secret_version_ids(state: _SecretsState, body: dict) -> Response:\n   335→    secret_id = body.get(\"SecretId\", \"\")\n   336→    secret = _find_secret(state, secret_id)\n   337→    if secret is None:\n   338→        return _error_response(\n   339→            \"ResourceNotFoundException\",\n   340→            f\"Secret {secret_id} not found.\",\n   341→        )\n   342→\n   343→    versions = [\n   344→        {\n   345→            \"VersionId\": v.version_id,\n   346→            \"VersionStages\": v.stages,\n   347→            \"CreatedDate\": v.created_date,\n   348→        }\n   349→        for v in secret.versions.values()\n   350→    ]\n   351→    return _json_response({\"ARN\": secret.arn, \"Name\": secret.name, \"Versions\": versions})\n   352→\n   353→\n   354→# ------------------------------------------------------------------\n   355→# Helpers\n   356→# ------------------------------------------------------------------\n   357→\n   358→\n   359→def _find_secret(state: _SecretsState, secret_id: str) -> _Secret | None:\n   360→    \"\"\"Find a secret by name or ARN.\"\"\"\n   361→    if secret_id in state._secrets:\n   362→        return state._secrets[secret_id]\n   363→    for s in state._secrets.values():\n   364→        if s.arn == secret_id:\n   365→            return s\n   366→    return None\n   367→\n   368→\n   369→def _resolve_version(\n   370→    secret: _Secret,\n   371→    version_id: str | None,\n   372→    version_stage: str,\n   373→) -> _SecretVersion | None:\n   374→    \"\"\"Resolve a secret version by ID or stage.\"\"\"\n   375→    if version_id:\n   376→        return secret.versions.get(version_id)\n   377→    for v in secret.versions.values():\n   378→        if version_stage in v.stages:\n   379→            return v\n   380→    return None\n   381→\n   382→\n   383→def _format_secret_description(secret: _Secret) -> dict[str, Any]:\n   384→    \"\"\"Format a secret for DescribeSecret / ListSecrets response.\"\"\"\n   385→    result: dict[str, Any] = {\n   386→        \"ARN\": secret.arn,\n   387→        \"Name\": secret.name,\n   388→        \"Description\": secret.description,\n   389→        \"CreatedDate\": secret.created_date,\n   390→        \"LastChangedDate\": secret.last_changed_date,\n   391→    }\n   392→    if secret.tags:\n   393→        result[\"Tags\"] = [{\"Key\": k, \"Value\": v} for k, v in secret.tags.items()]\n   394→    if secret.deleted_date is not None:\n   395→        result[\"DeletedDate\"] = secret.deleted_date\n   396→    # Version IDs to stages mapping\n   397→    if secret.versions:\n   398→        result[\"VersionIdsToStages\"] = {v.version_id: v.stages for v in secret.versions.values()}\n   399→    return result\n   400→\n   401→\n   402→def _json_response(data: dict, status_code: int = 200) -> Response:\n   403→    \"\"\"Return a JSON response.\"\"\"\n   404→    return Response(\n   405→        content=json.dumps(data, default=str),\n   406→        status_code=status_code,\n   407→        media_type=\"application/x-amz-json-1.1\",\n   408→    )\n   409→\n   410→\n   411→def _error_response(code: str, message: str, status_code: int = 400) -> Response:\n   412→    \"\"\"Return an error response in Secrets Manager format.\"\"\"\n   413→    error_body = {\"__type\": code, \"Message\": message}\n   414→    return _json_response(error_body, status_code=status_code)\n   415→\n   416→\n   417→# ------------------------------------------------------------------\n   418→# Action dispatch table\n   419→# ------------------------------------------------------------------\n   420→\n   421→\n   422→_ACTION_HANDLERS: dict[str, Any] = {\n   423→    \"CreateSecret\": _handle_create_secret,\n   424→    \"GetSecretValue\": _handle_get_secret_value,\n   425→    \"PutSecretValue\": _handle_put_secret_value,\n   426→    \"UpdateSecret\": _handle_update_secret,\n   427→    \"DeleteSecret\": _handle_delete_secret,\n   428→    \"DescribeSecret\": _handle_describe_secret,\n   429→    \"ListSecrets\": _handle_list_secrets,\n   430→    \"RestoreSecret\": _handle_restore_secret,\n   431→    \"TagResource\": _handle_tag_resource,\n   432→    \"UntagResource\": _handle_untag_resource,\n   433→    \"ListSecretVersionIds\": _handle_list_secret_version_ids,\n   434→    \"GetResourcePolicy\": _handle_get_resource_policy,\n   435→}\n   436→\n   437→\n   438→# ------------------------------------------------------------------\n   439→# App factory\n   440→# ------------------------------------------------------------------\n   441→\n   442→\n   443→def create_secretsmanager_app() -> FastAPI:\n   444→    \"\"\"Create a FastAPI application that speaks the Secrets Manager wire protocol.\"\"\"\n   445→    app = FastAPI(title=\"LDK Secrets Manager\")\n   446→    app.add_middleware(RequestLoggingMiddleware, logger=_logger, service_name=\"secretsmanager\")\n   447→    state = _SecretsState()\n   448→\n   449→    @app.post(\"/\")\n   450→    async def dispatch(request: Request) -> Response:\n   451→        target = request.headers.get(\"x-amz-target\", \"\")\n   452→        body = await _parse_request_body(request)\n   453→        action = _resolve_action(target, body)\n   454→\n   455→        handler = _ACTION_HANDLERS.get(action)\n   456→        if handler is None:\n   457→            _logger.warning(\"Unknown Secrets Manager action: %s\", action)\n   458→            return _error_response(\n   459→                \"InvalidAction\",\n   460→                f\"lws: Secrets Manager operation '{action}' is not yet implemented\",\n   461→            )\n   462→\n   463→        return await handler(state, body)\n   464→\n   465→    return app\n   466→\n   467→\n   468→async def _parse_request_body(request: Request) -> dict:\n   469→    \"\"\"Parse the JSON request body.\"\"\"\n   470→    body_bytes = await request.body()\n   471→    if not body_bytes:\n   472→        return {}\n   473→    try:\n   474→        return json.loads(body_bytes)\n   475→    except json.JSONDecodeError:\n   476→        return {}\n   477→\n   478→\n   479→def _resolve_action(target: str, body: dict) -> str:\n   480→    \"\"\"Resolve the API action from the target header or body.\"\"\"\n   481→    if target:\n   482→        # X-Amz-Target format: secretsmanager.CreateSecret\n   483→        return target.rsplit(\".\", 1)[-1] if \".\" in target else target\n   484→    return body.get(\"Action\", \"\")\n   485→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"954e8da2-169c-43ac-b49b-6ef5dcb38b43","timestamp":"2026-02-10T23:20:23.720Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services/src/lws/providers/secretsmanager/routes.py","content":"\"\"\"Secrets Manager HTTP routes.\n\nImplements the Secrets Manager wire protocol that AWS SDKs and Terraform use,\nusing JSON request/response format with X-Amz-Target header dispatch.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport json\nimport time\nimport uuid\nfrom typing import Any\n\nfrom fastapi import FastAPI, Request, Response\n\nfrom lws.logging.logger import get_logger\nfrom lws.logging.middleware import RequestLoggingMiddleware\n\n_logger = get_logger(\"ldk.secretsmanager\")\n\n_ACCOUNT_ID = \"000000000000\"\n_REGION = \"us-east-1\"\n\n\n# ------------------------------------------------------------------\n# In-memory state\n# ------------------------------------------------------------------\n\n\nclass _SecretVersion:\n    \"\"\"A single version of a secret.\"\"\"\n\n    def __init__(\n        self,\n        version_id: str,\n        secret_string: str | None = None,\n        secret_binary: str | None = None,\n        stages: list[str] | None = None,\n    ) -> None:\n        self.version_id = version_id\n        self.secret_string = secret_string\n        self.secret_binary = secret_binary\n        self.stages = stages or [\"AWSCURRENT\"]\n        self.created_date: float = time.time()\n\n\nclass _Secret:\n    \"\"\"Represents a Secrets Manager secret.\"\"\"\n\n    def __init__(\n        self,\n        name: str,\n        description: str = \"\",\n        tags: dict[str, str] | None = None,\n    ) -> None:\n        self.name = name\n        self.arn = f\"arn:aws:secretsmanager:{_REGION}:{_ACCOUNT_ID}:secret:{name}\"\n        self.description = description\n        self.tags: dict[str, str] = tags or {}\n        self.versions: dict[str, _SecretVersion] = {}\n        self.current_version_id: str | None = None\n        self.deleted_date: float | None = None\n        self.created_date: float = time.time()\n        self.last_changed_date: float = time.time()\n\n\nclass _SecretsState:\n    \"\"\"In-memory store for Secrets Manager secrets.\"\"\"\n\n    def __init__(self) -> None:\n        self._secrets: dict[str, _Secret] = {}\n\n\n# ------------------------------------------------------------------\n# Action handlers\n# ------------------------------------------------------------------\n\n\nasync def _handle_create_secret(state: _SecretsState, body: dict) -> Response:\n    name = body.get(\"Name\", \"\")\n    description = body.get(\"Description\", \"\")\n    secret_string = body.get(\"SecretString\")\n    secret_binary = body.get(\"SecretBinary\")\n    tags_list = body.get(\"Tags\", [])\n    tags = {t[\"Key\"]: t[\"Value\"] for t in tags_list} if tags_list else {}\n\n    if name in state._secrets:\n        existing = state._secrets[name]\n        if existing.deleted_date is not None:\n            # Restore soft-deleted secret\n            existing.deleted_date = None\n            existing.description = description\n            existing.tags = tags\n        else:\n            return _error_response(\n                \"ResourceExistsException\",\n                f\"The secret {name} already exists.\",\n            )\n\n    secret = _Secret(name=name, description=description, tags=tags)\n    state._secrets[name] = secret\n\n    version_id: str | None = None\n    if secret_string is not None or secret_binary is not None:\n        version_id = str(uuid.uuid4())\n        version = _SecretVersion(\n            version_id=version_id,\n            secret_string=secret_string,\n            secret_binary=secret_binary,\n            stages=[\"AWSCURRENT\"],\n        )\n        secret.versions[version_id] = version\n        secret.current_version_id = version_id\n\n    result: dict[str, Any] = {\"ARN\": secret.arn, \"Name\": name}\n    if version_id:\n        result[\"VersionId\"] = version_id\n    return _json_response(result)\n\n\nasync def _handle_get_secret_value(state: _SecretsState, body: dict) -> Response:\n    secret_id = body.get(\"SecretId\", \"\")\n    version_id = body.get(\"VersionId\")\n    version_stage = body.get(\"VersionStage\", \"AWSCURRENT\")\n\n    secret = _find_secret(state, secret_id)\n    if secret is None or secret.deleted_date is not None:\n        return _error_response(\n            \"ResourceNotFoundException\",\n            f\"Secret {secret_id} not found.\",\n        )\n\n    version = _resolve_version(secret, version_id, version_stage)\n    if version is None:\n        return _error_response(\n            \"ResourceNotFoundException\",\n            f\"No version found for secret {secret_id}.\",\n        )\n\n    result: dict[str, Any] = {\n        \"ARN\": secret.arn,\n        \"Name\": secret.name,\n        \"VersionId\": version.version_id,\n        \"VersionStages\": version.stages,\n        \"CreatedDate\": version.created_date,\n    }\n    if version.secret_string is not None:\n        result[\"SecretString\"] = version.secret_string\n    if version.secret_binary is not None:\n        result[\"SecretBinary\"] = version.secret_binary\n    return _json_response(result)\n\n\nasync def _handle_put_secret_value(state: _SecretsState, body: dict) -> Response:\n    secret_id = body.get(\"SecretId\", \"\")\n    secret_string = body.get(\"SecretString\")\n    secret_binary = body.get(\"SecretBinary\")\n\n    secret = _find_secret(state, secret_id)\n    if secret is None or secret.deleted_date is not None:\n        return _error_response(\n            \"ResourceNotFoundException\",\n            f\"Secret {secret_id} not found.\",\n        )\n\n    # Move AWSCURRENT from old version\n    if secret.current_version_id and secret.current_version_id in secret.versions:\n        old = secret.versions[secret.current_version_id]\n        if \"AWSCURRENT\" in old.stages:\n            old.stages.remove(\"AWSCURRENT\")\n        if \"AWSPREVIOUS\" not in old.stages:\n            old.stages.append(\"AWSPREVIOUS\")\n\n    version_id = str(uuid.uuid4())\n    version = _SecretVersion(\n        version_id=version_id,\n        secret_string=secret_string,\n        secret_binary=secret_binary,\n        stages=[\"AWSCURRENT\"],\n    )\n    secret.versions[version_id] = version\n    secret.current_version_id = version_id\n    secret.last_changed_date = time.time()\n\n    return _json_response({\"ARN\": secret.arn, \"Name\": secret.name, \"VersionId\": version_id})\n\n\nasync def _handle_update_secret(state: _SecretsState, body: dict) -> Response:\n    secret_id = body.get(\"SecretId\", \"\")\n    description = body.get(\"Description\")\n    secret_string = body.get(\"SecretString\")\n    secret_binary = body.get(\"SecretBinary\")\n\n    secret = _find_secret(state, secret_id)\n    if secret is None or secret.deleted_date is not None:\n        return _error_response(\n            \"ResourceNotFoundException\",\n            f\"Secret {secret_id} not found.\",\n        )\n\n    if description is not None:\n        secret.description = description\n\n    version_id: str | None = None\n    if secret_string is not None or secret_binary is not None:\n        # Move AWSCURRENT from old version\n        if secret.current_version_id and secret.current_version_id in secret.versions:\n            old = secret.versions[secret.current_version_id]\n            if \"AWSCURRENT\" in old.stages:\n                old.stages.remove(\"AWSCURRENT\")\n            if \"AWSPREVIOUS\" not in old.stages:\n                old.stages.append(\"AWSPREVIOUS\")\n\n        version_id = str(uuid.uuid4())\n        version = _SecretVersion(\n            version_id=version_id,\n            secret_string=secret_string,\n            secret_binary=secret_binary,\n            stages=[\"AWSCURRENT\"],\n        )\n        secret.versions[version_id] = version\n        secret.current_version_id = version_id\n\n    secret.last_changed_date = time.time()\n    result: dict[str, Any] = {\"ARN\": secret.arn, \"Name\": secret.name}\n    if version_id:\n        result[\"VersionId\"] = version_id\n    return _json_response(result)\n\n\nasync def _handle_delete_secret(state: _SecretsState, body: dict) -> Response:\n    secret_id = body.get(\"SecretId\", \"\")\n    force_delete = body.get(\"ForceDeleteWithoutRecovery\", False)\n\n    secret = _find_secret(state, secret_id)\n    if secret is None:\n        return _error_response(\n            \"ResourceNotFoundException\",\n            f\"Secret {secret_id} not found.\",\n        )\n\n    if force_delete:\n        state._secrets.pop(secret.name, None)\n    else:\n        secret.deleted_date = time.time()\n\n    return _json_response(\n        {\n            \"ARN\": secret.arn,\n            \"Name\": secret.name,\n            \"DeletionDate\": secret.deleted_date or time.time(),\n        }\n    )\n\n\nasync def _handle_describe_secret(state: _SecretsState, body: dict) -> Response:\n    secret_id = body.get(\"SecretId\", \"\")\n    secret = _find_secret(state, secret_id)\n    if secret is None:\n        return _error_response(\n            \"ResourceNotFoundException\",\n            f\"Secret {secret_id} not found.\",\n        )\n    return _json_response(_format_secret_description(secret))\n\n\nasync def _handle_list_secrets(state: _SecretsState, body: dict) -> Response:\n    secrets = [\n        _format_secret_description(s) for s in state._secrets.values() if s.deleted_date is None\n    ]\n    return _json_response({\"SecretList\": secrets})\n\n\nasync def _handle_restore_secret(state: _SecretsState, body: dict) -> Response:\n    secret_id = body.get(\"SecretId\", \"\")\n    secret = _find_secret(state, secret_id)\n    if secret is None:\n        return _error_response(\n            \"ResourceNotFoundException\",\n            f\"Secret {secret_id} not found.\",\n        )\n    if secret.deleted_date is None:\n        return _error_response(\n            \"InvalidRequestException\",\n            f\"Secret {secret_id} is not scheduled for deletion.\",\n        )\n    secret.deleted_date = None\n    return _json_response({\"ARN\": secret.arn, \"Name\": secret.name})\n\n\nasync def _handle_tag_resource(state: _SecretsState, body: dict) -> Response:\n    secret_id = body.get(\"SecretId\", \"\")\n    tags_list = body.get(\"Tags\", [])\n\n    secret = _find_secret(state, secret_id)\n    if secret is None:\n        return _error_response(\n            \"ResourceNotFoundException\",\n            f\"Secret {secret_id} not found.\",\n        )\n\n    for tag in tags_list:\n        secret.tags[tag[\"Key\"]] = tag[\"Value\"]\n    return _json_response({})\n\n\nasync def _handle_untag_resource(state: _SecretsState, body: dict) -> Response:\n    secret_id = body.get(\"SecretId\", \"\")\n    tag_keys = body.get(\"TagKeys\", [])\n\n    secret = _find_secret(state, secret_id)\n    if secret is None:\n        return _error_response(\n            \"ResourceNotFoundException\",\n            f\"Secret {secret_id} not found.\",\n        )\n\n    for key in tag_keys:\n        secret.tags.pop(key, None)\n    return _json_response({})\n\n\nasync def _handle_get_resource_policy(state: _SecretsState, body: dict) -> Response:\n    secret_id = body.get(\"SecretId\", \"\")\n    secret = _find_secret(state, secret_id)\n    if secret is None:\n        return _error_response(\n            \"ResourceNotFoundException\",\n            f\"Secret {secret_id} not found.\",\n        )\n    return _json_response({\"ARN\": secret.arn, \"Name\": secret.name})\n\n\nasync def _handle_list_secret_version_ids(state: _SecretsState, body: dict) -> Response:\n    secret_id = body.get(\"SecretId\", \"\")\n    secret = _find_secret(state, secret_id)\n    if secret is None:\n        return _error_response(\n            \"ResourceNotFoundException\",\n            f\"Secret {secret_id} not found.\",\n        )\n\n    versions = [\n        {\n            \"VersionId\": v.version_id,\n            \"VersionStages\": v.stages,\n            \"CreatedDate\": v.created_date,\n        }\n        for v in secret.versions.values()\n    ]\n    return _json_response({\"ARN\": secret.arn, \"Name\": secret.name, \"Versions\": versions})\n\n\n# ------------------------------------------------------------------\n# Helpers\n# ------------------------------------------------------------------\n\n\ndef _find_secret(state: _SecretsState, secret_id: str) -> _Secret | None:\n    \"\"\"Find a secret by name or ARN.\"\"\"\n    if secret_id in state._secrets:\n        return state._secrets[secret_id]\n    for s in state._secrets.values():\n        if s.arn == secret_id:\n            return s\n    return None\n\n\ndef _resolve_version(\n    secret: _Secret,\n    version_id: str | None,\n    version_stage: str,\n) -> _SecretVersion | None:\n    \"\"\"Resolve a secret version by ID or stage.\"\"\"\n    if version_id:\n        return secret.versions.get(version_id)\n    for v in secret.versions.values():\n        if version_stage in v.stages:\n            return v\n    return None\n\n\ndef _format_secret_description(secret: _Secret) -> dict[str, Any]:\n    \"\"\"Format a secret for DescribeSecret / ListSecrets response.\"\"\"\n    result: dict[str, Any] = {\n        \"ARN\": secret.arn,\n        \"Name\": secret.name,\n        \"Description\": secret.description,\n        \"CreatedDate\": secret.created_date,\n        \"LastChangedDate\": secret.last_changed_date,\n    }\n    if secret.tags:\n        result[\"Tags\"] = [{\"Key\": k, \"Value\": v} for k, v in secret.tags.items()]\n    if secret.deleted_date is not None:\n        result[\"DeletedDate\"] = secret.deleted_date\n    # Version IDs to stages mapping\n    if secret.versions:\n        result[\"VersionIdsToStages\"] = {v.version_id: v.stages for v in secret.versions.values()}\n    return result\n\n\ndef _json_response(data: dict, status_code: int = 200) -> Response:\n    \"\"\"Return a JSON response.\"\"\"\n    return Response(\n        content=json.dumps(data, default=str),\n        status_code=status_code,\n        media_type=\"application/x-amz-json-1.1\",\n    )\n\n\ndef _error_response(code: str, message: str, status_code: int = 400) -> Response:\n    \"\"\"Return an error response in Secrets Manager format.\"\"\"\n    error_body = {\"__type\": code, \"Message\": message}\n    return _json_response(error_body, status_code=status_code)\n\n\n# ------------------------------------------------------------------\n# Action dispatch table\n# ------------------------------------------------------------------\n\n\n_ACTION_HANDLERS: dict[str, Any] = {\n    \"CreateSecret\": _handle_create_secret,\n    \"GetSecretValue\": _handle_get_secret_value,\n    \"PutSecretValue\": _handle_put_secret_value,\n    \"UpdateSecret\": _handle_update_secret,\n    \"DeleteSecret\": _handle_delete_secret,\n    \"DescribeSecret\": _handle_describe_secret,\n    \"ListSecrets\": _handle_list_secrets,\n    \"RestoreSecret\": _handle_restore_secret,\n    \"TagResource\": _handle_tag_resource,\n    \"UntagResource\": _handle_untag_resource,\n    \"ListSecretVersionIds\": _handle_list_secret_version_ids,\n    \"GetResourcePolicy\": _handle_get_resource_policy,\n}\n\n\n# ------------------------------------------------------------------\n# App factory\n# ------------------------------------------------------------------\n\n\ndef create_secretsmanager_app() -> FastAPI:\n    \"\"\"Create a FastAPI application that speaks the Secrets Manager wire protocol.\"\"\"\n    app = FastAPI(title=\"LDK Secrets Manager\")\n    app.add_middleware(RequestLoggingMiddleware, logger=_logger, service_name=\"secretsmanager\")\n    state = _SecretsState()\n\n    @app.post(\"/\")\n    async def dispatch(request: Request) -> Response:\n        target = request.headers.get(\"x-amz-target\", \"\")\n        body = await _parse_request_body(request)\n        action = _resolve_action(target, body)\n\n        handler = _ACTION_HANDLERS.get(action)\n        if handler is None:\n            _logger.warning(\"Unknown Secrets Manager action: %s\", action)\n            return _error_response(\n                \"InvalidAction\",\n                f\"lws: Secrets Manager operation '{action}' is not yet implemented\",\n            )\n\n        return await handler(state, body)\n\n    return app\n\n\nasync def _parse_request_body(request: Request) -> dict:\n    \"\"\"Parse the JSON request body.\"\"\"\n    body_bytes = await request.body()\n    if not body_bytes:\n        return {}\n    try:\n        return json.loads(body_bytes)\n    except json.JSONDecodeError:\n        return {}\n\n\ndef _resolve_action(target: str, body: dict) -> str:\n    \"\"\"Resolve the API action from the target header or body.\"\"\"\n    if target:\n        # X-Amz-Target format: secretsmanager.CreateSecret\n        return target.rsplit(\".\", 1)[-1] if \".\" in target else target\n    return body.get(\"Action\", \"\")\n","numLines":485,"startLine":1,"totalLines":485}},"sourceToolAssistantUUID":"2cf318b4-7e90-4814-83f9-1900e9d68daf"}
{"parentUuid":"954e8da2-169c-43ac-b49b-6ef5dcb38b43","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","message":{"model":"claude-opus-4-6","id":"msg_01Rc6hbAU62CYKRBiSnJcYAj","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01AAQV5NyZg7JPkNT71VHtf3","name":"Read","input":{"file_path":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services/src/lws/cli/ldk.py"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":5553,"cache_read_input_tokens":15470,"output_tokens":412,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":5553,"ephemeral_5m_input_tokens":0},"inference_geo":"","iterations":[]}},"requestId":"req_011CY1FCABup89maXRijdjwj","type":"assistant","uuid":"e00abf84-158f-42e1-b2fc-f413c82a0732","timestamp":"2026-02-10T23:20:24.294Z"}
{"parentUuid":"e00abf84-158f-42e1-b2fc-f413c82a0732","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"callback"},"parentToolUseID":"toolu_01AAQV5NyZg7JPkNT71VHtf3","toolUseID":"toolu_01AAQV5NyZg7JPkNT71VHtf3","timestamp":"2026-02-10T23:20:24.707Z","uuid":"122f2128-f4b4-40bf-97f9-f9935fdaa703"}
{"parentUuid":"e00abf84-158f-42e1-b2fc-f413c82a0732","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01AAQV5NyZg7JPkNT71VHtf3","type":"tool_result","content":"     1→\"\"\"LDK CLI entry point.\n     2→\n     3→Provides the ``ldk dev``, ``ldk invoke``, and ``ldk reset`` commands.\n     4→``ldk dev`` parses a CDK cloud assembly, builds the application graph,\n     5→starts local providers, and watches for file changes.\n     6→\"\"\"\n     7→\n     8→from __future__ import annotations\n     9→\n    10→import asyncio\n    11→import json\n    12→import logging\n    13→import shutil\n    14→from collections.abc import Callable\n    15→from pathlib import Path\n    16→from typing import Any\n    17→\n    18→import typer\n    19→import uvicorn\n    20→from rich.console import Console\n    21→from rich.syntax import Syntax\n    22→\n    23→from lws.cli.display import (\n    24→    print_banner,\n    25→    print_error,\n    26→    print_resource_summary,\n    27→    print_startup_complete,\n    28→)\n    29→from lws.config.loader import ConfigError, LdkConfig, load_config\n    30→from lws.graph.builder import AppGraph, NodeType, build_graph\n    31→from lws.interfaces import (\n    32→    ComputeConfig,\n    33→    GsiDefinition,\n    34→    ICompute,\n    35→    KeyAttribute,\n    36→    KeySchema,\n    37→    Provider,\n    38→    TableConfig,\n    39→)\n    40→from lws.parser.assembly import AppModel, parse_assembly\n    41→from lws.providers.apigateway.provider import ApiGatewayProvider, RouteConfig\n    42→from lws.providers.cognito.provider import CognitoProvider\n    43→from lws.providers.cognito.user_store import PasswordPolicy, UserPoolConfig\n    44→from lws.providers.dynamodb.provider import SqliteDynamoProvider\n    45→from lws.providers.dynamodb.routes import create_dynamodb_app\n    46→from lws.providers.ecs.provider import EcsProvider\n    47→from lws.providers.eventbridge.provider import (\n    48→    EventBridgeProvider,\n    49→    EventBusConfig,\n    50→    RuleConfig,\n    51→    RuleTarget,\n    52→)\n    53→from lws.providers.lambda_runtime.nodejs import NodeJsCompute\n    54→from lws.providers.lambda_runtime.python import PythonCompute\n    55→from lws.providers.s3.provider import S3Provider\n    56→from lws.providers.s3.routes import create_s3_app\n    57→from lws.providers.sns.provider import SnsProvider, TopicConfig\n    58→from lws.providers.sns.routes import create_sns_app\n    59→from lws.providers.sqs.provider import QueueConfig, RedrivePolicy, SqsProvider\n    60→from lws.providers.sqs.routes import create_sqs_app\n    61→from lws.providers.stepfunctions.provider import (\n    62→    StateMachineConfig,\n    63→    StepFunctionsProvider,\n    64→    WorkflowType,\n    65→)\n    66→from lws.runtime.env_builder import build_lambda_env\n    67→from lws.runtime.orchestrator import Orchestrator\n    68→from lws.runtime.sdk_env import build_sdk_env\n    69→from lws.runtime.synth import SynthError, ensure_synth\n    70→from lws.runtime.watcher import FileWatcher\n    71→\n    72→_console = Console()\n    73→\n    74→app = typer.Typer(name=\"ldk\", help=\"Local Development Kit - Run AWS CDK applications locally\")\n    75→\n    76→__version__ = \"0.4.0\"\n    77→\n    78→\n    79→@app.callback()\n    80→def main() -> None:\n    81→    \"\"\"LDK - Local Development Kit.\"\"\"\n    82→\n    83→\n    84→@app.command()\n    85→def dev(\n    86→    port: int = typer.Option(None, \"--port\", \"-p\", help=\"API Gateway listen port\"),\n    87→    no_persist: bool = typer.Option(False, \"--no-persist\", help=\"Disable data persistence\"),\n    88→    force_synth: bool = typer.Option(False, \"--force-synth\", help=\"Force CDK synth\"),\n    89→    log_level: str = typer.Option(\n    90→        None, \"--log-level\", \"-l\", help=\"Log level (debug/info/warning/error)\"\n    91→    ),\n    92→    project_dir: Path = typer.Option(\".\", \"--project-dir\", \"-d\", help=\"Project root directory\"),\n    93→    mode: str = typer.Option(None, \"--mode\", \"-m\", help=\"Project mode (cdk or terraform)\"),\n    94→) -> None:\n    95→    \"\"\"Start the local development environment.\"\"\"\n    96→    try:\n    97→        asyncio.run(_run_dev(project_dir, port, no_persist, force_synth, log_level, mode))\n    98→    except KeyboardInterrupt:\n    99→        pass\n   100→\n   101→\n   102→@app.command()\n   103→def invoke(\n   104→    function_name: str = typer.Option(..., \"--function-name\", \"-f\", help=\"Lambda function name\"),\n   105→    event: str = typer.Option(None, \"--event\", \"-e\", help=\"Inline JSON event payload\"),\n   106→    event_file: Path = typer.Option(None, \"--event-file\", help=\"Path to JSON event file\"),\n   107→    project_dir: Path = typer.Option(\".\", \"--project-dir\", \"-d\", help=\"Project root directory\"),\n   108→    port: int = typer.Option(None, \"--port\", \"-p\", help=\"Management API port\"),\n   109→) -> None:\n   110→    \"\"\"Invoke a Lambda function directly.\"\"\"\n   111→    asyncio.run(_run_invoke(function_name, event, event_file, project_dir, port))\n   112→\n   113→\n   114→async def _run_invoke(\n   115→    function_name: str,\n   116→    event_json: str | None,\n   117→    event_file: Path | None,\n   118→    project_dir: Path,\n   119→    port_override: int | None,\n   120→) -> None:\n   121→    \"\"\"Async implementation of the ``ldk invoke`` command.\"\"\"\n   122→    # Resolve event payload\n   123→    event_payload = _resolve_event_payload(event_json, event_file)\n   124→\n   125→    # Try connecting to running ldk dev via management API\n   126→    project_dir = project_dir.resolve()\n   127→    config = _load_config_quiet(project_dir)\n   128→    mgmt_port = port_override or config.port\n   129→\n   130→    if await _try_management_invoke(mgmt_port, function_name, event_payload):\n   131→        return\n   132→\n   133→    # Fallback: one-shot invocation\n   134→    _console.print(\"[dim]No running ldk dev found, performing one-shot invocation...[/dim]\")\n   135→    await _oneshot_invoke(project_dir, config, function_name, event_payload)\n   136→\n   137→\n   138→def _resolve_event_payload(event_json: str | None, event_file: Path | None) -> dict:\n   139→    \"\"\"Parse event payload from CLI args.\"\"\"\n   140→    if event_json is not None:\n   141→        try:\n   142→            return json.loads(event_json)\n   143→        except json.JSONDecodeError as exc:\n   144→            print_error(\"Invalid JSON in --event\", str(exc))\n   145→            raise typer.Exit(1)\n   146→\n   147→    if event_file is not None:\n   148→        if not event_file.exists():\n   149→            print_error(\"Event file not found\", str(event_file))\n   150→            raise typer.Exit(1)\n   151→        try:\n   152→            return json.loads(event_file.read_text())\n   153→        except json.JSONDecodeError as exc:\n   154→            print_error(\"Invalid JSON in event file\", str(exc))\n   155→            raise typer.Exit(1)\n   156→\n   157→    return {}\n   158→\n   159→\n   160→async def _try_management_invoke(port: int, function_name: str, event: dict) -> bool:\n   161→    \"\"\"Try to invoke via the management API. Return True if successful.\"\"\"\n   162→    try:\n   163→        import httpx\n   164→\n   165→        async with httpx.AsyncClient() as client:\n   166→            resp = await client.post(\n   167→                f\"http://localhost:{port}/_ldk/invoke\",\n   168→                json={\"function_name\": function_name, \"event\": event},\n   169→                timeout=30.0,\n   170→            )\n   171→            result = resp.json()\n   172→            formatted = json.dumps(result, indent=2)\n   173→            syntax = Syntax(formatted, \"json\", theme=\"monokai\")\n   174→            _console.print(syntax)\n   175→            return True\n   176→    except Exception:\n   177→        return False\n   178→\n   179→\n   180→async def _oneshot_invoke(\n   181→    project_dir: Path, config: LdkConfig, function_name: str, event: dict\n   182→) -> None:\n   183→    \"\"\"Perform a one-shot Lambda invocation without a running server.\"\"\"\n   184→    try:\n   185→        import uuid as _uuid\n   186→\n   187→        from lws.interfaces import InvocationResult, LambdaContext\n   188→\n   189→        cdk_out = project_dir / config.cdk_out_dir\n   190→        if not cdk_out.exists():\n   191→            print_error(\"CDK output not found\", f\"Run 'cdk synth' first in {project_dir}\")\n   192→            raise typer.Exit(1)\n   193→\n   194→        app_model = parse_assembly(cdk_out)\n   195→        func_def = next((f for f in app_model.functions if f.name == function_name), None)\n   196→        if func_def is None:\n   197→            print_error(\"Function not found\", f\"No function named '{function_name}'\")\n   198→            raise typer.Exit(1)\n   199→\n   200→        sdk_env = build_sdk_env({})\n   201→        func_env = build_lambda_env(\n   202→            function_name=func_def.name,\n   203→            function_env=func_def.environment,\n   204→            local_endpoints={},\n   205→            resolved_refs={},\n   206→        )\n   207→        compute_config = ComputeConfig(\n   208→            function_name=func_def.name,\n   209→            handler=func_def.handler,\n   210→            runtime=func_def.runtime,\n   211→            code_path=func_def.code_path or Path(\".\"),\n   212→            timeout=func_def.timeout,\n   213→            memory_size=func_def.memory,\n   214→            environment=func_env,\n   215→        )\n   216→        compute = NodeJsCompute(config=compute_config, sdk_env=sdk_env)\n   217→        await compute.start()\n   218→\n   219→        request_id = str(_uuid.uuid4())\n   220→        context = LambdaContext(\n   221→            function_name=function_name,\n   222→            memory_limit_in_mb=compute_config.memory_size,\n   223→            timeout_seconds=compute_config.timeout,\n   224→            aws_request_id=request_id,\n   225→            invoked_function_arn=(\n   226→                f\"arn:aws:lambda:us-east-1:000000000000:function:{function_name}\"\n   227→            ),\n   228→        )\n   229→\n   230→        result: InvocationResult = await compute.invoke(event, context)\n   231→        await compute.stop()\n   232→\n   233→        output = result.payload if result.error is None else {\"error\": result.error}\n   234→        formatted = json.dumps(output, indent=2, default=str)\n   235→        syntax = Syntax(formatted, \"json\", theme=\"monokai\")\n   236→        _console.print(syntax)\n   237→\n   238→    except typer.Exit:\n   239→        raise\n   240→    except Exception as exc:\n   241→        print_error(\"Invocation failed\", str(exc))\n   242→        raise typer.Exit(1)\n   243→\n   244→\n   245→@app.command()\n   246→def reset(\n   247→    yes: bool = typer.Option(False, \"--yes\", \"-y\", help=\"Skip confirmation prompt\"),\n   248→    project_dir: Path = typer.Option(\".\", \"--project-dir\", \"-d\", help=\"Project root directory\"),\n   249→    port: int = typer.Option(None, \"--port\", \"-p\", help=\"Management API port\"),\n   250→) -> None:\n   251→    \"\"\"Reset all LDK local state (databases, queues, etc.).\"\"\"\n   252→    project_dir = project_dir.resolve()\n   253→    config = _load_config_quiet(project_dir)\n   254→    data_dir = project_dir / config.data_dir\n   255→\n   256→    if not data_dir.exists():\n   257→        _console.print(\"[dim]No data directory found. Nothing to reset.[/dim]\")\n   258→        return\n   259→\n   260→    # List contents to be deleted\n   261→    items = list(data_dir.iterdir())\n   262→    if not items:\n   263→        _console.print(\"[dim]Data directory is empty. Nothing to reset.[/dim]\")\n   264→        return\n   265→\n   266→    _console.print(f\"[bold]Will delete all files under:[/bold] {data_dir}\")\n   267→    for item in items:\n   268→        kind = \"dir\" if item.is_dir() else \"file\"\n   269→        _console.print(f\"  [dim]{kind}:[/dim] {item.name}\")\n   270→\n   271→    if not yes:\n   272→        confirm = typer.confirm(\"Are you sure you want to delete all local state?\")\n   273→        if not confirm:\n   274→            _console.print(\"[dim]Aborted.[/dim]\")\n   275→            return\n   276→\n   277→    # Delete contents\n   278→    deleted_count = 0\n   279→    for item in items:\n   280→        if item.is_dir():\n   281→            shutil.rmtree(item)\n   282→        else:\n   283→            item.unlink()\n   284→        deleted_count += 1\n   285→\n   286→    _console.print(f\"[green]Deleted {deleted_count} item(s) from {data_dir}[/green]\")\n   287→\n   288→    # Notify running ldk dev if possible\n   289→    mgmt_port = port or config.port\n   290→    asyncio.run(_try_management_reset(mgmt_port))\n   291→\n   292→\n   293→async def _try_management_reset(port: int) -> None:\n   294→    \"\"\"Try to notify running ldk dev of the reset via management API.\"\"\"\n   295→    try:\n   296→        import httpx\n   297→\n   298→        async with httpx.AsyncClient() as client:\n   299→            resp = await client.post(\n   300→                f\"http://localhost:{port}/_ldk/reset\",\n   301→                timeout=5.0,\n   302→            )\n   303→            if resp.status_code == 200:\n   304→                _console.print(\"[dim]Notified running ldk dev of reset.[/dim]\")\n   305→    except Exception:\n   306→        pass  # Server not running, that's fine\n   307→\n   308→\n   309→def _load_config_quiet(project_dir: Path) -> LdkConfig:\n   310→    \"\"\"Load config without printing errors. Falls back to defaults.\"\"\"\n   311→    try:\n   312→        return load_config(project_dir)\n   313→    except ConfigError:\n   314→        return LdkConfig()\n   315→\n   316→\n   317→def _load_and_apply_config(\n   318→    project_dir: Path,\n   319→    port_override: int | None,\n   320→    no_persist: bool,\n   321→    log_level_override: str | None,\n   322→) -> LdkConfig:\n   323→    \"\"\"Load config and apply CLI overrides.\"\"\"\n   324→    try:\n   325→        config = load_config(project_dir)\n   326→    except ConfigError as exc:\n   327→        print_error(\"Configuration error\", str(exc))\n   328→        raise typer.Exit(1)\n   329→\n   330→    if port_override is not None:\n   331→        config.port = port_override\n   332→    if log_level_override is not None:\n   333→        config.log_level = log_level_override\n   334→    if no_persist:\n   335→        config.persist = False\n   336→\n   337→    logging.basicConfig(\n   338→        level=getattr(logging, config.log_level.upper(), logging.INFO),\n   339→        format=\"%(levelname)s %(name)s: %(message)s\",\n   340→    )\n   341→    return config\n   342→\n   343→\n   344→def _collect_extra_resources(app_model: AppModel) -> dict[str, list[str]]:\n   345→    \"\"\"Collect extra resource name lists from the app model for display.\"\"\"\n   346→    extras: dict[str, list[str]] = {}\n   347→    _RESOURCE_ATTRS = {\n   348→        \"queues\": (\"name\", \"queues\"),\n   349→        \"buckets\": (\"name\", \"buckets\"),\n   350→        \"topics\": (\"name\", \"topics\"),\n   351→        \"state_machines\": (\"name\", \"state_machines\"),\n   352→        \"ecs_services\": (\"service_name\", \"ecs_services\"),\n   353→        \"user_pools\": (\"user_pool_name\", \"user_pools\"),\n   354→    }\n   355→    for key, (attr, model_attr) in _RESOURCE_ATTRS.items():\n   356→        items = getattr(app_model, model_attr, [])\n   357→        if items:\n   358→            extras[key] = [getattr(item, attr, str(item)) for item in items]\n   359→    return extras\n   360→\n   361→\n   362→def _build_local_details(app_model: AppModel, port: int) -> dict[str, str]:\n   363→    \"\"\"Build a mapping of ``\"Type:Name\"`` to local detail strings.\"\"\"\n   364→    details: dict[str, str] = {}\n   365→\n   366→    _add_api_details(details, app_model)\n   367→    _add_resource_details(details, app_model)\n   368→    return details\n   369→\n   370→\n   371→def _add_api_details(details: dict[str, str], app_model: AppModel) -> None:\n   372→    \"\"\"Add API route and Lambda function details.\"\"\"\n   373→    for api_def in app_model.apis:\n   374→        for r in api_def.routes:\n   375→            details[f\"API Route:{r.path}\"] = (\n   376→                f\"lws apigateway test-invoke-method --resource {r.path} --http-method {r.method}\"\n   377→            )\n   378→    for f in app_model.functions:\n   379→        details[f\"Function:{f.name}\"] = f\"ldk invoke {f.name}\"\n   380→\n   381→\n   382→def _add_resource_details(details: dict[str, str], app_model: AppModel) -> None:\n   383→    \"\"\"Add service resource details (DynamoDB, SQS, S3, etc.).\"\"\"\n   384→    for t in app_model.tables:\n   385→        details[f\"Table:{t.name}\"] = f\"lws dynamodb scan --table-name {t.name}\"\n   386→    for q in app_model.queues:\n   387→        details[f\"Queue:{q.name}\"] = f\"lws sqs receive-message --queue-name {q.name}\"\n   388→    for b in app_model.buckets:\n   389→        details[f\"Bucket:{b.name}\"] = f\"lws s3api list-objects-v2 --bucket {b.name}\"\n   390→    for t in app_model.topics:\n   391→        details[f\"Topic:{t.name}\"] = f\"lws sns publish --topic-name {t.name} --message '...'\"\n   392→    for b in app_model.event_buses:\n   393→        details[f\"Event Bus:{b.name}\"] = f\"lws events list-rules --event-bus-name {b.name}\"\n   394→    for sm in app_model.state_machines:\n   395→        details[f\"State Machine:{sm.name}\"] = f\"lws stepfunctions start-execution --name {sm.name}\"\n   396→    for p in app_model.user_pools:\n   397→        details[f\"User Pool:{p.user_pool_name}\"] = (\n   398→            f\"lws cognito-idp sign-up --user-pool-name {p.user_pool_name}\"\n   399→        )\n   400→\n   401→\n   402→def _display_summary(app_model: AppModel, port: int) -> None:\n   403→    \"\"\"Print resource summary and startup-complete banner.\"\"\"\n   404→    routes_info = [\n   405→        {\"method\": r.method, \"path\": r.path, \"handler\": r.handler_name or \"\"}\n   406→        for api_def in app_model.apis\n   407→        for r in api_def.routes\n   408→    ]\n   409→    tables_info = [t.name for t in app_model.tables]\n   410→    functions_info = [f\"{f.name} ({f.runtime})\" for f in app_model.functions]\n   411→\n   412→    extra_resources = _collect_extra_resources(app_model)\n   413→    local_details = _build_local_details(app_model, port)\n   414→    print_resource_summary(\n   415→        routes_info, tables_info, functions_info, local_details=local_details, **extra_resources\n   416→    )\n   417→\n   418→    extra_counts = {f\"num_{k}\": len(v) for k, v in extra_resources.items()}\n   419→    print_startup_complete(\n   420→        port,\n   421→        num_routes=len(routes_info),\n   422→        num_tables=len(tables_info),\n   423→        num_functions=len(functions_info),\n   424→        **extra_counts,\n   425→    )\n   426→\n   427→\n   428→def _resolve_mode(project_dir: Path, config: LdkConfig, mode_override: str | None) -> str:\n   429→    \"\"\"Resolve the project mode from CLI flag, config, or auto-detection.\n   430→\n   431→    Returns ``\"cdk\"`` or ``\"terraform\"``.\n   432→    Raises ``typer.Exit(1)`` on error.\n   433→    \"\"\"\n   434→    from lws.terraform.detect import detect_project_type\n   435→\n   436→    mode = mode_override or config.mode\n   437→    if mode:\n   438→        if mode not in (\"cdk\", \"terraform\"):\n   439→            print_error(\"Invalid mode\", f\"Must be 'cdk' or 'terraform', got '{mode}'\")\n   440→            raise typer.Exit(1)\n   441→        return mode\n   442→\n   443→    detected = detect_project_type(project_dir)\n   444→    if detected == \"ambiguous\":\n   445→        print_error(\n   446→            \"Ambiguous project\",\n   447→            \"Both .tf files and cdk.out found. Use --mode cdk or --mode terraform.\",\n   448→        )\n   449→        raise typer.Exit(1)\n   450→    if detected == \"none\":\n   451→        print_error(\n   452→            \"No project found\",\n   453→            \"No .tf files or cdk.out directory found. \"\n   454→            \"Run from a CDK or Terraform project directory.\",\n   455→        )\n   456→        raise typer.Exit(1)\n   457→    return detected\n   458→\n   459→\n   460→async def _run_dev_terraform(project_dir: Path, config: LdkConfig) -> None:\n   461→    \"\"\"Run the dev server in Terraform mode.\n   462→\n   463→    Starts all service providers in always-on mode, generates the\n   464→    Terraform provider override file, and waits for shutdown.\n   465→    \"\"\"\n   466→    from lws.terraform.gitignore import ensure_gitignore\n   467→    from lws.terraform.override import cleanup_override, generate_override\n   468→\n   469→    port = config.port\n   470→    data_dir = project_dir / config.data_dir\n   471→    data_dir.mkdir(parents=True, exist_ok=True)\n   472→\n   473→    # Generate override file\n   474→    try:\n   475→        override_path = generate_override(port, project_dir)\n   476→    except FileExistsError as exc:\n   477→        print_error(\"Override file conflict\", str(exc))\n   478→        raise typer.Exit(1)\n   479→\n   480→    ensure_gitignore(project_dir)\n   481→\n   482→    # Create all providers in always-on mode (no app model)\n   483→    providers, ports = _create_terraform_providers(config, data_dir, project_dir)\n   484→\n   485→    orchestrator = Orchestrator()\n   486→\n   487→    # Enable WebSocket log streaming\n   488→    from lws.logging.logger import WebSocketLogHandler, set_ws_handler\n   489→\n   490→    ws_log_handler = WebSocketLogHandler()\n   491→    set_ws_handler(ws_log_handler)\n   492→\n   493→    # Build resource metadata so the CLI client can discover services\n   494→    resource_metadata: dict[str, Any] = {\n   495→        \"port\": port,\n   496→        \"services\": {\n   497→            svc_name: {\"port\": svc_port, \"resources\": []} for svc_name, svc_port in ports.items()\n   498→        },\n   499→    }\n   500→\n   501→    # Mount management API (no compute providers in terraform mode)\n   502→    _mount_management_api(providers, orchestrator, {}, port, resource_metadata)\n   503→\n   504→    for key in providers:\n   505→        pass  # All keys are already in the dict\n   506→\n   507→    startup_order = list(providers.keys())\n   508→\n   509→    try:\n   510→        await orchestrator.start(providers, startup_order)\n   511→    except Exception as exc:\n   512→        cleanup_override(project_dir)\n   513→        print_error(\"Failed to start providers\", str(exc))\n   514→        raise typer.Exit(1)\n   515→\n   516→    # Display summary\n   517→    _console.print()\n   518→    _console.print(\"[bold green]Terraform mode active[/bold green]\")\n   519→    _console.print(f\"  Override file: {override_path}\")\n   520→    _console.print()\n   521→    _console.print(\"[bold]Service endpoints:[/bold]\")\n   522→    for svc_name, svc_port in sorted(ports.items()):\n   523→        _console.print(f\"  {svc_name:20s} http://localhost:{svc_port}\")\n   524→    _console.print()\n   525→    _console.print(\"[dim]Run 'terraform init && terraform apply' to create resources.[/dim]\")\n   526→    _console.print(f\"  Dashboard: http://localhost:{config.port}/_ldk/gui\")\n   527→    _console.print()\n   528→\n   529→    try:\n   530→        await orchestrator.wait_for_shutdown()\n   531→    finally:\n   532→        cleanup_override(project_dir)\n   533→        set_ws_handler(None)\n   534→        await orchestrator.stop()\n   535→        typer.echo(\"Goodbye\")\n   536→\n   537→\n   538→def _create_terraform_providers(\n   539→    config: LdkConfig,\n   540→    data_dir: Path,\n   541→    project_dir: Path | None = None,\n   542→) -> tuple[dict[str, Provider], dict[str, int]]:\n   543→    \"\"\"Create all service providers for Terraform mode (no app model).\"\"\"\n   544→    providers: dict[str, Provider] = {}\n   545→\n   546→    port = config.port\n   547→    ports = {\n   548→        \"dynamodb\": port + 1,\n   549→        \"sqs\": port + 2,\n   550→        \"s3\": port + 3,\n   551→        \"sns\": port + 4,\n   552→        \"eventbridge\": port + 5,\n   553→        \"stepfunctions\": port + 6,\n   554→        \"cognito\": port + 7,\n   555→        \"apigateway\": port + 8,\n   556→        \"lambda\": port + 9,\n   557→        \"iam\": port + 10,\n   558→        \"sts\": port + 11,\n   559→        \"ssm\": port + 12,\n   560→        \"secretsmanager\": port + 13,\n   561→    }\n   562→\n   563→    dynamo_provider = SqliteDynamoProvider(data_dir=data_dir, tables=[])\n   564→    sqs_provider = SqsProvider()\n   565→    s3_provider = S3Provider(data_dir=data_dir)\n   566→    sns_provider = SnsProvider()\n   567→    eb_provider = EventBridgeProvider()\n   568→    sf_provider = StepFunctionsProvider()\n   569→\n   570→    pool_config = UserPoolConfig(\n   571→        user_pool_id=\"us-east-1_default\",\n   572→        user_pool_name=\"default\",\n   573→    )\n   574→    cognito_provider = CognitoProvider(data_dir=data_dir, config=pool_config)\n   575→\n   576→    _register_http_providers(\n   577→        providers,\n   578→        dynamo_provider=dynamo_provider,\n   579→        sqs_provider=sqs_provider,\n   580→        s3_provider=s3_provider,\n   581→        sns_provider=sns_provider,\n   582→        eb_provider=eb_provider,\n   583→        sf_provider=sf_provider,\n   584→        cognito_provider=cognito_provider,\n   585→        ports=ports,\n   586→    )\n   587→\n   588→    # Shared Lambda registry for Lambda management and API Gateway V2 proxy\n   589→    from lws.providers.lambda_runtime.routes import LambdaRegistry, create_lambda_management_app\n   590→\n   591→    lambda_registry = LambdaRegistry()\n   592→\n   593→    # Wire Lambda registry compute providers into Step Functions so SFN can\n   594→    # invoke Lambda functions that Terraform creates dynamically.\n   595→    sf_provider.set_compute_providers(lambda_registry._compute)\n   596→\n   597→    # Build SDK env so Lambda functions can reach local services\n   598→    local_endpoints: dict[str, str] = {\n   599→        \"dynamodb\": f\"http://127.0.0.1:{ports['dynamodb']}\",\n   600→        \"sqs\": f\"http://127.0.0.1:{ports['sqs']}\",\n   601→        \"s3\": f\"http://127.0.0.1:{ports['s3']}\",\n   602→        \"sns\": f\"http://127.0.0.1:{ports['sns']}\",\n   603→        \"events\": f\"http://127.0.0.1:{ports['eventbridge']}\",\n   604→        \"stepfunctions\": f\"http://127.0.0.1:{ports['stepfunctions']}\",\n   605→        \"cognito-idp\": f\"http://127.0.0.1:{ports['cognito']}\",\n   606→        \"ssm\": f\"http://127.0.0.1:{ports['ssm']}\",\n   607→        \"secretsmanager\": f\"http://127.0.0.1:{ports['secretsmanager']}\",\n   608→    }\n   609→    sdk_env = build_sdk_env(local_endpoints)\n   610→\n   611→    # Lambda management API\n   612→    providers[\"__lambda_http__\"] = _HttpServiceProvider(\n   613→        \"lambda-http\",\n   614→        lambda: create_lambda_management_app(lambda_registry, project_dir, sdk_env),\n   615→        ports[\"lambda\"],\n   616→    )\n   617→\n   618→    # API Gateway management API with V2 support and Lambda proxy\n   619→    from lws.providers.apigateway.routes import create_apigateway_management_app\n   620→\n   621→    providers[\"__apigateway_http__\"] = _HttpServiceProvider(\n   622→        \"apigateway-http\",\n   623→        lambda: create_apigateway_management_app(lambda_registry),\n   624→        ports[\"apigateway\"],\n   625→    )\n   626→\n   627→    # IAM stub\n   628→    from lws.providers.iam.routes import create_iam_app\n   629→\n   630→    providers[\"__iam_http__\"] = _HttpServiceProvider(\"iam-http\", create_iam_app, ports[\"iam\"])\n   631→\n   632→    # STS stub\n   633→    from lws.providers.sts.routes import create_sts_app\n   634→\n   635→    providers[\"__sts_http__\"] = _HttpServiceProvider(\"sts-http\", create_sts_app, ports[\"sts\"])\n   636→\n   637→    # SSM Parameter Store\n   638→    from lws.providers.ssm.routes import create_ssm_app\n   639→\n   640→    providers[\"__ssm_http__\"] = _HttpServiceProvider(\"ssm-http\", create_ssm_app, ports[\"ssm\"])\n   641→\n   642→    # Secrets Manager\n   643→    from lws.providers.secretsmanager.routes import create_secretsmanager_app\n   644→\n   645→    providers[\"__secretsmanager_http__\"] = _HttpServiceProvider(\n   646→        \"secretsmanager-http\", create_secretsmanager_app, ports[\"secretsmanager\"]\n   647→    )\n   648→\n   649→    return providers, ports\n   650→\n   651→\n   652→def _has_any_resources(app_model: AppModel) -> bool:\n   653→    \"\"\"Return True if the app model contains at least one resource.\"\"\"\n   654→    return bool(\n   655→        app_model.functions\n   656→        or app_model.tables\n   657→        or app_model.apis\n   658→        or app_model.queues\n   659→        or app_model.buckets\n   660→        or app_model.topics\n   661→        or app_model.event_buses\n   662→        or app_model.state_machines\n   663→        or app_model.ecs_services\n   664→        or app_model.user_pools\n   665→    )\n   666→\n   667→\n   668→async def _run_dev(\n   669→    project_dir: Path,\n   670→    port_override: int | None,\n   671→    no_persist: bool,\n   672→    force_synth: bool,\n   673→    log_level_override: str | None,\n   674→    mode_override: str | None = None,\n   675→) -> None:\n   676→    \"\"\"Async implementation of the ``ldk dev`` command.\"\"\"\n   677→    project_dir = project_dir.resolve()\n   678→    config = _load_and_apply_config(project_dir, port_override, no_persist, log_level_override)\n   679→    print_banner(__version__, project_dir.name)\n   680→\n   681→    # Resolve project mode\n   682→    resolved_mode = _resolve_mode(project_dir, config, mode_override)\n   683→    if resolved_mode == \"terraform\":\n   684→        await _run_dev_terraform(project_dir, config)\n   685→        return\n   686→\n   687→    try:\n   688→        cdk_out = await ensure_synth(project_dir, force=force_synth)\n   689→    except SynthError as exc:\n   690→        print_error(\"CDK synth failed\", str(exc))\n   691→        raise typer.Exit(1)\n   692→\n   693→    app_model = parse_assembly(cdk_out)\n   694→    if not _has_any_resources(app_model):\n   695→        print_error(\"No resources found in cloud assembly\", str(cdk_out))\n   696→        raise typer.Exit(1)\n   697→\n   698→    graph = build_graph(app_model)\n   699→    startup_order = graph.topological_sort()\n   700→\n   701→    data_dir = project_dir / config.data_dir\n   702→    data_dir.mkdir(parents=True, exist_ok=True)\n   703→    providers, compute_providers = _create_providers(app_model, graph, config, data_dir)\n   704→\n   705→    orchestrator = Orchestrator()\n   706→\n   707→    # Enable WebSocket log streaming\n   708→    from lws.logging.logger import WebSocketLogHandler, set_ws_handler\n   709→\n   710→    ws_log_handler = WebSocketLogHandler()\n   711→    set_ws_handler(ws_log_handler)\n   712→\n   713→    # Mount management API\n   714→    resource_metadata = _build_resource_metadata(app_model, config.port)\n   715→    _mount_management_api(\n   716→        providers, orchestrator, compute_providers, config.port, resource_metadata\n   717→    )\n   718→\n   719→    # Append non-graph provider keys (HTTP servers, management) to startup order.\n   720→    # This must happen after _mount_management_api so the fallback management\n   721→    # HTTP server (when no API Gateway exists) is included in the startup order.\n   722→    for key in providers:\n   723→        if key not in startup_order:\n   724→            startup_order.append(key)\n   725→\n   726→    try:\n   727→        await orchestrator.start(providers, startup_order)\n   728→    except Exception as exc:\n   729→        print_error(\"Failed to start providers\", str(exc))\n   730→        raise typer.Exit(1)\n   731→\n   732→    _display_summary(app_model, config.port)\n   733→    typer.echo(f\"  Dashboard: http://localhost:{config.port}/_ldk/gui\")\n   734→\n   735→    watcher = FileWatcher(\n   736→        watch_dir=project_dir,\n   737→        include_patterns=config.watch_include,\n   738→        exclude_patterns=config.watch_exclude,\n   739→    )\n   740→    watcher.on_change(lambda path: logging.getLogger(\"ldk.watcher\").info(\"Changed: %s\", path))\n   741→    watcher.start()\n   742→\n   743→    try:\n   744→        await orchestrator.wait_for_shutdown()\n   745→    finally:\n   746→        watcher.stop()\n   747→        set_ws_handler(None)\n   748→        await orchestrator.stop()\n   749→        typer.echo(\"Goodbye\")\n   750→\n   751→\n   752→def _create_dynamo_providers(\n   753→    app_model: AppModel,\n   754→    graph: AppGraph,\n   755→    data_dir: Path,\n   756→) -> tuple[SqliteDynamoProvider, dict[str, Provider]]:\n   757→    \"\"\"Create DynamoDB table providers from the app model.\n   758→\n   759→    Always returns a provider (even with no CDK tables) so the DynamoDB\n   760→    HTTP endpoint is available for Terraform/CLI table creation.\n   761→    \"\"\"\n   762→    providers: dict[str, Provider] = {}\n   763→    table_configs: list[TableConfig] = []\n   764→    for table in app_model.tables:\n   765→        ks = _build_key_schema(table.key_schema)\n   766→        gsi_defs = [_build_gsi(g) for g in table.gsi_definitions]\n   767→        table_configs.append(\n   768→            TableConfig(table_name=table.name, key_schema=ks, gsi_definitions=gsi_defs)\n   769→        )\n   770→\n   771→    dynamo_provider = SqliteDynamoProvider(data_dir=data_dir, tables=table_configs)\n   772→    for table in app_model.tables:\n   773→        node_id = _find_node_id(graph, NodeType.DYNAMODB_TABLE, table.name)\n   774→        if node_id:\n   775→            providers[node_id] = dynamo_provider\n   776→    return dynamo_provider, providers\n   777→\n   778→\n   779→def _create_compute_providers(\n   780→    app_model: AppModel,\n   781→    graph: AppGraph,\n   782→    local_endpoints: dict[str, str],\n   783→    sdk_env: dict[str, str],\n   784→) -> tuple[dict[str, ICompute], dict[str, Provider]]:\n   785→    \"\"\"Create Lambda compute providers from the app model (Node.js + Python).\"\"\"\n   786→    providers: dict[str, Provider] = {}\n   787→    compute_providers: dict[str, ICompute] = {}\n   788→    for func in app_model.functions:\n   789→        func_env = build_lambda_env(\n   790→            function_name=func.name,\n   791→            function_env=func.environment,\n   792→            local_endpoints=local_endpoints,\n   793→            resolved_refs={},\n   794→        )\n   795→        compute_config = ComputeConfig(\n   796→            function_name=func.name,\n   797→            handler=func.handler,\n   798→            runtime=func.runtime,\n   799→            code_path=func.code_path or Path(\".\"),\n   800→            timeout=func.timeout,\n   801→            memory_size=func.memory,\n   802→            environment=func_env,\n   803→        )\n   804→        if func.runtime.startswith(\"python\"):\n   805→            compute: ICompute = PythonCompute(config=compute_config, sdk_env=sdk_env)\n   806→        elif func.runtime.startswith(\"nodejs\"):\n   807→            compute = NodeJsCompute(config=compute_config, sdk_env=sdk_env)\n   808→        else:\n   809→            logging.getLogger(\"ldk.cli\").warning(\n   810→                \"Unsupported runtime %s for %s, skipping\", func.runtime, func.name\n   811→            )\n   812→            continue\n   813→        compute_providers[func.name] = compute\n   814→        node_id = _find_node_id(graph, NodeType.LAMBDA_FUNCTION, func.name)\n   815→        if node_id:\n   816→            providers[node_id] = compute\n   817→    return compute_providers, providers\n   818→\n   819→\n   820→def _create_api_providers(\n   821→    app_model: AppModel,\n   822→    graph: AppGraph,\n   823→    compute_providers: dict[str, ICompute],\n   824→    port: int,\n   825→) -> tuple[ApiGatewayProvider | None, dict[str, Provider]]:\n   826→    \"\"\"Create API Gateway providers from the app model.\"\"\"\n   827→    providers: dict[str, Provider] = {}\n   828→    api_provider: ApiGatewayProvider | None = None\n   829→    for api_def in app_model.apis:\n   830→        route_configs = [\n   831→            RouteConfig(method=r.method, path=r.path, handler_name=r.handler_name)\n   832→            for r in api_def.routes\n   833→            if r.handler_name and r.handler_name in compute_providers\n   834→        ]\n   835→        if route_configs:\n   836→            api_provider = ApiGatewayProvider(\n   837→                routes=route_configs, compute_providers=compute_providers, port=port\n   838→            )\n   839→            node_id = _find_node_id(graph, NodeType.API_GATEWAY, api_def.name)\n   840→            if node_id:\n   841→                providers[node_id] = api_provider\n   842→    return api_provider, providers\n   843→\n   844→\n   845→def _create_sqs_providers(\n   846→    app_model: AppModel,\n   847→    graph: AppGraph,\n   848→) -> tuple[SqsProvider, dict[str, Provider]]:\n   849→    \"\"\"Create SQS queue providers from the app model.\n   850→\n   851→    Always returns a provider (even with no CDK queues) so the SQS\n   852→    HTTP endpoint is available for Terraform/CLI queue creation.\n   853→    \"\"\"\n   854→    providers: dict[str, Provider] = {}\n   855→    queue_configs = []\n   856→    for q in app_model.queues:\n   857→        redrive = None\n   858→        if q.redrive_target:\n   859→            redrive = RedrivePolicy(\n   860→                dead_letter_queue_name=q.redrive_target, max_receive_count=q.max_receive_count\n   861→            )\n   862→        queue_configs.append(\n   863→            QueueConfig(\n   864→                queue_name=q.name,\n   865→                visibility_timeout=q.visibility_timeout,\n   866→                is_fifo=q.is_fifo,\n   867→                content_based_dedup=q.content_based_dedup,\n   868→                redrive_policy=redrive,\n   869→            )\n   870→        )\n   871→    sqs_provider = SqsProvider(queues=queue_configs if queue_configs else None)\n   872→    for q in app_model.queues:\n   873→        node_id = _find_node_id(graph, NodeType.SQS_QUEUE, q.name)\n   874→        if node_id:\n   875→            providers[node_id] = sqs_provider\n   876→    return sqs_provider, providers\n   877→\n   878→\n   879→def _create_s3_providers(\n   880→    app_model: AppModel,\n   881→    graph: AppGraph,\n   882→    data_dir: Path,\n   883→) -> tuple[S3Provider, dict[str, Provider]]:\n   884→    \"\"\"Create S3 bucket providers from the app model.\n   885→\n   886→    Always returns a provider (even with no CDK buckets) so the S3\n   887→    HTTP endpoint is available for Terraform/CLI bucket creation.\n   888→    \"\"\"\n   889→    providers: dict[str, Provider] = {}\n   890→    bucket_names = [b.name for b in app_model.buckets]\n   891→    s3_provider = S3Provider(data_dir=data_dir, buckets=bucket_names if bucket_names else None)\n   892→    for b in app_model.buckets:\n   893→        node_id = _find_node_id(graph, NodeType.S3_BUCKET, b.name)\n   894→        if node_id:\n   895→            providers[node_id] = s3_provider\n   896→    return s3_provider, providers\n   897→\n   898→\n   899→def _create_sns_providers(\n   900→    app_model: AppModel,\n   901→    graph: AppGraph,\n   902→) -> tuple[SnsProvider, dict[str, Provider]]:\n   903→    \"\"\"Create SNS topic providers from the app model.\n   904→\n   905→    Always returns a provider (even with no CDK topics) so the SNS\n   906→    HTTP endpoint is available for Terraform/CLI topic creation.\n   907→    \"\"\"\n   908→    providers: dict[str, Provider] = {}\n   909→    topic_configs = [\n   910→        TopicConfig(topic_name=t.name, topic_arn=t.topic_arn) for t in app_model.topics\n   911→    ]\n   912→    sns_provider = SnsProvider(topics=topic_configs if topic_configs else None)\n   913→    for t in app_model.topics:\n   914→        node_id = _find_node_id(graph, NodeType.SNS_TOPIC, t.name)\n   915→        if node_id:\n   916→            providers[node_id] = sns_provider\n   917→    return sns_provider, providers\n   918→\n   919→\n   920→def _create_eventbridge_providers(\n   921→    app_model: AppModel,\n   922→    graph: AppGraph,\n   923→) -> tuple[EventBridgeProvider, dict[str, Provider]]:\n   924→    \"\"\"Create EventBridge providers from the app model.\n   925→\n   926→    Always returns a provider (even with no CDK buses) so the EventBridge\n   927→    HTTP endpoint is available for Terraform/CLI event bus creation.\n   928→    \"\"\"\n   929→    providers: dict[str, Provider] = {}\n   930→    bus_configs = [\n   931→        EventBusConfig(bus_name=b.name, bus_arn=b.bus_arn) for b in app_model.event_buses\n   932→    ]\n   933→    rule_configs = []\n   934→    for r in app_model.event_rules:\n   935→        targets = [\n   936→            RuleTarget(target_id=t[\"target_id\"], arn=t[\"arn\"], input_path=t.get(\"input_path\"))\n   937→            for t in r.targets\n   938→        ]\n   939→        rule_configs.append(\n   940→            RuleConfig(\n   941→                rule_name=r.rule_name,\n   942→                event_bus_name=r.event_bus_name,\n   943→                event_pattern=r.event_pattern,\n   944→                schedule_expression=r.schedule_expression,\n   945→                targets=targets,\n   946→            )\n   947→        )\n   948→    eb_provider = EventBridgeProvider(\n   949→        buses=bus_configs if bus_configs else None,\n   950→        rules=rule_configs if rule_configs else None,\n   951→    )\n   952→    for b in app_model.event_buses:\n   953→        node_id = _find_node_id(graph, NodeType.EVENT_BUS, b.name)\n   954→        if node_id:\n   955→            providers[node_id] = eb_provider\n   956→    return eb_provider, providers\n   957→\n   958→\n   959→def _create_stepfunctions_providers(\n   960→    app_model: AppModel,\n   961→    graph: AppGraph,\n   962→) -> tuple[StepFunctionsProvider, dict[str, Provider]]:\n   963→    \"\"\"Create Step Functions providers from the app model.\n   964→\n   965→    Always returns a provider (even with no CDK state machines) so the\n   966→    Step Functions HTTP endpoint is available for Terraform/CLI creation.\n   967→    \"\"\"\n   968→    providers: dict[str, Provider] = {}\n   969→    sm_configs = []\n   970→    for sm in app_model.state_machines:\n   971→        wf_type = WorkflowType.EXPRESS if sm.workflow_type == \"EXPRESS\" else WorkflowType.STANDARD\n   972→        sm_configs.append(\n   973→            StateMachineConfig(\n   974→                name=sm.name,\n   975→                definition=sm.definition,\n   976→                workflow_type=wf_type,\n   977→                role_arn=sm.role_arn,\n   978→                definition_substitutions=sm.definition_substitutions,\n   979→            )\n   980→        )\n   981→    sf_provider = StepFunctionsProvider(\n   982→        state_machines=sm_configs if sm_configs else None,\n   983→    )\n   984→    for sm in app_model.state_machines:\n   985→        node_id = _find_node_id(graph, NodeType.STATE_MACHINE, sm.name)\n   986→        if node_id:\n   987→            providers[node_id] = sf_provider\n   988→    return sf_provider, providers\n   989→\n   990→\n   991→def _create_ecs_providers(\n   992→    app_model: AppModel,\n   993→    graph: AppGraph,\n   994→) -> tuple[EcsProvider, dict[str, Provider]]:\n   995→    \"\"\"Create ECS service providers from the app model.\n   996→\n   997→    Always returns a provider (even with no CDK services).\n   998→    \"\"\"\n   999→    providers: dict[str, Provider] = {}\n  1000→    ecs_provider = EcsProvider(\n  1001→        services=app_model.ecs_services if app_model.ecs_services else None,\n  1002→    )\n  1003→    for svc in app_model.ecs_services:\n  1004→        svc_name = getattr(svc, \"service_name\", str(id(svc)))\n  1005→        node_id = _find_node_id(graph, NodeType.ECS_SERVICE, svc_name)\n  1006→        if node_id:\n  1007→            providers[node_id] = ecs_provider\n  1008→    return ecs_provider, providers\n  1009→\n  1010→\n  1011→def _create_cognito_providers(\n  1012→    app_model: AppModel,\n  1013→    data_dir: Path,\n  1014→    compute_providers: dict[str, ICompute],\n  1015→) -> tuple[CognitoProvider, dict[str, Provider]]:\n  1016→    \"\"\"Create Cognito user pool providers from the app model.\n  1017→\n  1018→    Always returns a provider (even with no CDK user pools) so the\n  1019→    Cognito HTTP endpoint is available for Terraform/CLI user pool creation.\n  1020→    \"\"\"\n  1021→    providers: dict[str, Provider] = {}\n  1022→    if not app_model.user_pools:\n  1023→        pool_config = UserPoolConfig(\n  1024→            user_pool_id=\"us-east-1_default\",\n  1025→            user_pool_name=\"default\",\n  1026→        )\n  1027→        cognito_provider = CognitoProvider(data_dir=data_dir, config=pool_config)\n  1028→        return cognito_provider, providers\n  1029→    # Use the first user pool (multi-pool support can be added later)\n  1030→    pool = app_model.user_pools[0]\n  1031→    pw = pool.password_policy\n  1032→    password_policy = PasswordPolicy(\n  1033→        minimum_length=int(pw.get(\"MinimumLength\", 8)),\n  1034→        require_lowercase=bool(pw.get(\"RequireLowercase\", True)),\n  1035→        require_uppercase=bool(pw.get(\"RequireUppercase\", True)),\n  1036→        require_digits=bool(pw.get(\"RequireNumbers\", pw.get(\"RequireDigits\", True))),\n  1037→        require_symbols=bool(pw.get(\"RequireSymbols\", False)),\n  1038→    )\n  1039→    pool_config = UserPoolConfig(\n  1040→        user_pool_id=f\"us-east-1_{pool.logical_id}\",\n  1041→        user_pool_name=pool.user_pool_name,\n  1042→        password_policy=password_policy,\n  1043→        auto_confirm=pool.auto_confirm,\n  1044→        client_id=pool.client_id or \"local-client-id\",\n  1045→        pre_authentication_trigger=pool.pre_auth_trigger,\n  1046→        post_confirmation_trigger=pool.post_confirm_trigger,\n  1047→    )\n  1048→    trigger_funcs = {}\n  1049→    if pool.pre_auth_trigger and pool.pre_auth_trigger in compute_providers:\n  1050→        trigger_funcs[\"PreAuthentication\"] = compute_providers[pool.pre_auth_trigger]\n  1051→    if pool.post_confirm_trigger and pool.post_confirm_trigger in compute_providers:\n  1052→        trigger_funcs[\"PostConfirmation\"] = compute_providers[pool.post_confirm_trigger]\n  1053→    cognito_provider = CognitoProvider(\n  1054→        data_dir=data_dir, config=pool_config, trigger_functions=trigger_funcs or None\n  1055→    )\n  1056→    providers[f\"__cognito_{pool.logical_id}__\"] = cognito_provider\n  1057→    return cognito_provider, providers\n  1058→\n  1059→\n  1060→def _wire_remaining_providers(\n  1061→    app_model: AppModel,\n  1062→    graph: AppGraph,\n  1063→    providers: dict[str, Provider],\n  1064→    compute_providers: dict[str, ICompute],\n  1065→    sqs_provider: SqsProvider,\n  1066→    local_endpoints: dict[str, str],\n  1067→    data_dir: Path,\n  1068→    api_port: int,\n  1069→    *,\n  1070→    sns_port: int,\n  1071→    eb_port: int,\n  1072→    sf_port: int,\n  1073→    cognito_port: int,\n  1074→) -> tuple[\n  1075→    SnsProvider,\n  1076→    EventBridgeProvider,\n  1077→    StepFunctionsProvider,\n  1078→    CognitoProvider,\n  1079→]:\n  1080→    \"\"\"Wire messaging, cognito, and API Gateway providers.\"\"\"\n  1081→    sns_provider, sns_providers = _create_sns_providers(app_model, graph)\n  1082→    providers.update(sns_providers)\n  1083→    sns_provider.set_compute_providers(compute_providers)\n  1084→    sns_provider.set_queue_provider(sqs_provider)\n  1085→    local_endpoints[\"sns\"] = f\"http://127.0.0.1:{sns_port}\"\n  1086→\n  1087→    eb_provider, eb_providers = _create_eventbridge_providers(app_model, graph)\n  1088→    providers.update(eb_providers)\n  1089→    eb_provider.set_compute_providers(compute_providers)\n  1090→    local_endpoints[\"events\"] = f\"http://127.0.0.1:{eb_port}\"\n  1091→\n  1092→    sf_provider, sf_providers = _create_stepfunctions_providers(app_model, graph)\n  1093→    providers.update(sf_providers)\n  1094→    sf_provider.set_compute_providers(compute_providers)\n  1095→    local_endpoints[\"stepfunctions\"] = f\"http://127.0.0.1:{sf_port}\"\n  1096→\n  1097→    cognito_provider, cognito_providers = _create_cognito_providers(\n  1098→        app_model, data_dir, compute_providers\n  1099→    )\n  1100→    providers.update(cognito_providers)\n  1101→    local_endpoints[\"cognito-idp\"] = f\"http://127.0.0.1:{cognito_port}\"\n  1102→\n  1103→    api_provider, api_providers = _create_api_providers(\n  1104→        app_model, graph, compute_providers, api_port\n  1105→    )\n  1106→    providers.update(api_providers)\n  1107→\n  1108→    return sns_provider, eb_provider, sf_provider, cognito_provider\n  1109→\n  1110→\n  1111→def _create_providers(\n  1112→    app_model: AppModel,\n  1113→    graph: AppGraph,\n  1114→    config: LdkConfig,\n  1115→    data_dir: Path,\n  1116→) -> tuple[dict[str, Provider], dict[str, ICompute]]:\n  1117→    \"\"\"Instantiate providers from the parsed app model.\n  1118→\n  1119→    Returns a tuple of (provider map, compute_providers).\n  1120→    \"\"\"\n  1121→    providers: dict[str, Provider] = {}\n  1122→\n  1123→    # Port allocation: base+1 DynamoDB, +2 SQS, +3 S3, +4 SNS, +5 EventBridge,\n  1124→    # +6 Step Functions, +7 Cognito, +12 SSM, +13 Secrets Manager\n  1125→    dynamo_port = config.port + 1\n  1126→    sqs_port = config.port + 2\n  1127→    s3_port = config.port + 3\n  1128→    sns_port = config.port + 4\n  1129→    eb_port = config.port + 5\n  1130→    sf_port = config.port + 6\n  1131→    cognito_port = config.port + 7\n  1132→    ssm_port = config.port + 12\n  1133→    secretsmanager_port = config.port + 13\n  1134→\n  1135→    # 1. Storage providers (no deps)\n  1136→    dynamo_provider, dynamo_providers = _create_dynamo_providers(app_model, graph, data_dir)\n  1137→    providers.update(dynamo_providers)\n  1138→\n  1139→    sqs_provider, sqs_providers = _create_sqs_providers(app_model, graph)\n  1140→    providers.update(sqs_providers)\n  1141→\n  1142→    s3_provider, s3_providers = _create_s3_providers(app_model, graph, data_dir)\n  1143→    providers.update(s3_providers)\n  1144→\n  1145→    # 2. Build local_endpoints for SDK env redirection\n  1146→    local_endpoints: dict[str, str] = {}\n  1147→    local_endpoints[\"dynamodb\"] = f\"http://127.0.0.1:{dynamo_port}\"\n  1148→    local_endpoints[\"sqs\"] = f\"http://127.0.0.1:{sqs_port}\"\n  1149→    local_endpoints[\"s3\"] = f\"http://127.0.0.1:{s3_port}\"\n  1150→\n  1151→    # 3. Compute (Lambda — Node.js + Python)\n  1152→    sdk_env = build_sdk_env(local_endpoints)\n  1153→    compute_providers, compute_graph_providers = _create_compute_providers(\n  1154→        app_model, graph, local_endpoints, sdk_env\n  1155→    )\n  1156→    providers.update(compute_graph_providers)\n  1157→\n  1158→    # 4-6. Messaging, ECS, Cognito, API Gateway\n  1159→    sns_provider, eb_provider, sf_provider, cognito_provider = _wire_remaining_providers(\n  1160→        app_model,\n  1161→        graph,\n  1162→        providers,\n  1163→        compute_providers,\n  1164→        sqs_provider,\n  1165→        local_endpoints,\n  1166→        data_dir,\n  1167→        config.port,\n  1168→        sns_port=sns_port,\n  1169→        eb_port=eb_port,\n  1170→        sf_port=sf_port,\n  1171→        cognito_port=cognito_port,\n  1172→    )\n  1173→    ecs_provider, ecs_providers = _create_ecs_providers(app_model, graph)\n  1174→    providers.update(ecs_providers)\n  1175→\n  1176→    # 7. Add SSM and Secrets Manager endpoints, rebuild SDK env, update compute\n  1177→    local_endpoints[\"ssm\"] = f\"http://127.0.0.1:{ssm_port}\"\n  1178→    local_endpoints[\"secretsmanager\"] = f\"http://127.0.0.1:{secretsmanager_port}\"\n  1179→    sdk_env = build_sdk_env(local_endpoints)\n  1180→    for compute in compute_providers.values():\n  1181→        if hasattr(compute, \"_sdk_env\"):\n  1182→            compute._sdk_env = sdk_env\n  1183→\n  1184→    # 8. Create HTTP servers for each active service\n  1185→    _register_http_providers(\n  1186→        providers,\n  1187→        dynamo_provider=dynamo_provider,\n  1188→        sqs_provider=sqs_provider,\n  1189→        s3_provider=s3_provider,\n  1190→        sns_provider=sns_provider,\n  1191→        eb_provider=eb_provider,\n  1192→        sf_provider=sf_provider,\n  1193→        cognito_provider=cognito_provider,\n  1194→        ports={\n  1195→            \"dynamodb\": dynamo_port,\n  1196→            \"sqs\": sqs_port,\n  1197→            \"s3\": s3_port,\n  1198→            \"sns\": sns_port,\n  1199→            \"eventbridge\": eb_port,\n  1200→            \"stepfunctions\": sf_port,\n  1201→            \"cognito\": cognito_port,\n  1202→        },\n  1203→    )\n  1204→\n  1205→    # 9. SSM Parameter Store and Secrets Manager\n  1206→    from lws.providers.secretsmanager.routes import create_secretsmanager_app\n  1207→    from lws.providers.ssm.routes import create_ssm_app\n  1208→\n  1209→    providers[\"__ssm_http__\"] = _HttpServiceProvider(\n  1210→        \"ssm-http\", create_ssm_app, ssm_port\n  1211→    )\n  1212→    providers[\"__secretsmanager_http__\"] = _HttpServiceProvider(\n  1213→        \"secretsmanager-http\", create_secretsmanager_app, secretsmanager_port\n  1214→    )\n  1215→\n  1216→    return providers, compute_providers\n  1217→\n  1218→\n  1219→def _register_http_providers(\n  1220→    providers: dict[str, Provider],\n  1221→    *,\n  1222→    dynamo_provider: SqliteDynamoProvider,\n  1223→    sqs_provider: SqsProvider,\n  1224→    s3_provider: S3Provider,\n  1225→    sns_provider: SnsProvider,\n  1226→    eb_provider: EventBridgeProvider,\n  1227→    sf_provider: StepFunctionsProvider,\n  1228→    cognito_provider: CognitoProvider,\n  1229→    ports: dict[str, int],\n  1230→) -> None:\n  1231→    \"\"\"Register HTTP service providers for each active backend.\"\"\"\n  1232→    from lws.providers.cognito.routes import create_cognito_app\n  1233→    from lws.providers.eventbridge.routes import create_eventbridge_app\n  1234→    from lws.providers.stepfunctions.routes import create_stepfunctions_app\n  1235→\n  1236→    http_services: list[tuple[str, Any, Callable[[], Any]]] = []\n  1237→    http_services.append(\n  1238→        (\"dynamodb\", ports[\"dynamodb\"], lambda p=dynamo_provider: create_dynamodb_app(p))\n  1239→    )\n  1240→    http_services.append(\n  1241→        (\"sqs\", ports[\"sqs\"], lambda p=sqs_provider, pt=ports[\"sqs\"]: create_sqs_app(p, pt))\n  1242→    )\n  1243→    http_services.append((\"s3\", ports[\"s3\"], lambda p=s3_provider: create_s3_app(p)))\n  1244→    http_services.append((\"sns\", ports[\"sns\"], lambda p=sns_provider: create_sns_app(p)))\n  1245→    http_services.append(\n  1246→        (\"eventbridge\", ports[\"eventbridge\"], lambda p=eb_provider: create_eventbridge_app(p))\n  1247→    )\n  1248→    http_services.append(\n  1249→        (\n  1250→            \"stepfunctions\",\n  1251→            ports[\"stepfunctions\"],\n  1252→            lambda p=sf_provider: create_stepfunctions_app(p),\n  1253→        )\n  1254→    )\n  1255→    http_services.append(\n  1256→        (\"cognito\", ports[\"cognito\"], lambda p=cognito_provider: create_cognito_app(p))\n  1257→    )\n  1258→\n  1259→    for svc_name, port, factory in http_services:\n  1260→        providers[f\"__{svc_name}_http__\"] = _HttpServiceProvider(f\"{svc_name}-http\", factory, port)\n  1261→\n  1262→\n  1263→class _HttpServiceProvider(Provider):\n  1264→    \"\"\"Generic wrapper that runs any FastAPI app as a uvicorn-served Provider.\"\"\"\n  1265→\n  1266→    def __init__(self, service_name: str, app_factory: Callable[[], Any], port: int) -> None:\n  1267→        self._service_name = service_name\n  1268→        self._app_factory = app_factory\n  1269→        self._port = port\n  1270→        self._server: uvicorn.Server | None = None\n  1271→        self._task: asyncio.Task | None = None  # type: ignore[type-arg]\n  1272→\n  1273→    @property\n  1274→    def name(self) -> str:\n  1275→        return self._service_name\n  1276→\n  1277→    async def start(self) -> None:\n  1278→        http_app = self._app_factory()\n  1279→        uvi_config = uvicorn.Config(\n  1280→            app=http_app,\n  1281→            host=\"0.0.0.0\",\n  1282→            port=self._port,\n  1283→            log_level=\"warning\",\n  1284→        )\n  1285→        self._server = uvicorn.Server(uvi_config)\n  1286→        self._task = asyncio.create_task(self._server.serve())\n  1287→        # Wait for the server to actually bind before reporting as started\n  1288→        for _ in range(50):\n  1289→            if self._server.started:\n  1290→                break\n  1291→            await asyncio.sleep(0.1)\n  1292→\n  1293→    async def stop(self) -> None:\n  1294→        if self._server is not None:\n  1295→            self._server.should_exit = True\n  1296→        if self._task is not None:\n  1297→            await self._task\n  1298→            self._task = None\n  1299→        self._server = None\n  1300→\n  1301→    async def health_check(self) -> bool:\n  1302→        return self._server is not None\n  1303→\n  1304→\n  1305→def _build_resource_metadata(app_model: AppModel, port: int) -> dict[str, Any]:\n  1306→    \"\"\"Build resource metadata for the ``/_ldk/resources`` endpoint.\"\"\"\n  1307→    metadata: dict[str, Any] = {\"port\": port, \"services\": {}}\n  1308→    services = metadata[\"services\"]\n  1309→    ports = _service_ports(port)\n  1310→\n  1311→    _add_api_metadata(services, app_model, port)\n  1312→    _add_service_metadata(services, app_model, ports)\n  1313→    return metadata\n  1314→\n  1315→\n  1316→def _service_ports(port: int) -> dict[str, int]:\n  1317→    \"\"\"Return a mapping of service name to port number.\"\"\"\n  1318→    return {\n  1319→        \"dynamodb\": port + 1,\n  1320→        \"sqs\": port + 2,\n  1321→        \"s3\": port + 3,\n  1322→        \"sns\": port + 4,\n  1323→        \"events\": port + 5,\n  1324→        \"stepfunctions\": port + 6,\n  1325→        \"cognito-idp\": port + 7,\n  1326→        \"ssm\": port + 12,\n  1327→        \"secretsmanager\": port + 13,\n  1328→    }\n  1329→\n  1330→\n  1331→def _add_api_metadata(services: dict[str, Any], app_model: AppModel, port: int) -> None:\n  1332→    \"\"\"Add API Gateway metadata to services.\"\"\"\n  1333→    if not app_model.apis:\n  1334→        return\n  1335→    routes = []\n  1336→    for api_def in app_model.apis:\n  1337→        for r in api_def.routes:\n  1338→            routes.append(\n  1339→                {\n  1340→                    \"name\": api_def.name,\n  1341→                    \"path\": r.path,\n  1342→                    \"method\": r.method,\n  1343→                    \"handler\": r.handler_name or \"\",\n  1344→                }\n  1345→            )\n  1346→    services[\"apigateway\"] = {\"port\": port, \"resources\": routes}\n  1347→\n  1348→\n  1349→def _add_service_metadata(\n  1350→    services: dict[str, Any], app_model: AppModel, ports: dict[str, int]\n  1351→) -> None:\n  1352→    \"\"\"Add non-API service metadata to services.\"\"\"\n  1353→    if app_model.functions:\n  1354→        services[\"lambda\"] = {\n  1355→            \"resources\": [\n  1356→                {\n  1357→                    \"name\": f.name,\n  1358→                    \"runtime\": f.runtime,\n  1359→                    \"arn\": f\"arn:aws:lambda:us-east-1:000000000000:function:{f.name}\",\n  1360→                }\n  1361→                for f in app_model.functions\n  1362→            ],\n  1363→        }\n  1364→    if app_model.tables:\n  1365→        services[\"dynamodb\"] = {\n  1366→            \"port\": ports[\"dynamodb\"],\n  1367→            \"resources\": [{\"name\": t.name} for t in app_model.tables],\n  1368→        }\n  1369→    if app_model.queues:\n  1370→        sqs_port = ports[\"sqs\"]\n  1371→        services[\"sqs\"] = {\n  1372→            \"port\": sqs_port,\n  1373→            \"resources\": [\n  1374→                {\n  1375→                    \"name\": q.name,\n  1376→                    \"queue_url\": f\"http://localhost:{sqs_port}/000000000000/{q.name}\",\n  1377→                }\n  1378→                for q in app_model.queues\n  1379→            ],\n  1380→        }\n  1381→    if app_model.buckets:\n  1382→        services[\"s3\"] = {\n  1383→            \"port\": ports[\"s3\"],\n  1384→            \"resources\": [{\"name\": b.name} for b in app_model.buckets],\n  1385→        }\n  1386→    if app_model.topics:\n  1387→        services[\"sns\"] = {\n  1388→            \"port\": ports[\"sns\"],\n  1389→            \"resources\": [\n  1390→                {\n  1391→                    \"name\": t.name,\n  1392→                    \"arn\": t.topic_arn or f\"arn:aws:sns:us-east-1:000000000000:{t.name}\",\n  1393→                }\n  1394→                for t in app_model.topics\n  1395→            ],\n  1396→        }\n  1397→    if app_model.event_buses:\n  1398→        services[\"events\"] = {\n  1399→            \"port\": ports[\"events\"],\n  1400→            \"resources\": [\n  1401→                {\n  1402→                    \"name\": b.name,\n  1403→                    \"arn\": b.bus_arn or f\"arn:aws:events:us-east-1:000000000000:event-bus/{b.name}\",\n  1404→                }\n  1405→                for b in app_model.event_buses\n  1406→            ],\n  1407→        }\n  1408→    if app_model.state_machines:\n  1409→        services[\"stepfunctions\"] = {\n  1410→            \"port\": ports[\"stepfunctions\"],\n  1411→            \"resources\": [\n  1412→                {\n  1413→                    \"name\": sm.name,\n  1414→                    \"arn\": f\"arn:aws:states:us-east-1:000000000000:stateMachine:{sm.name}\",\n  1415→                }\n  1416→                for sm in app_model.state_machines\n  1417→            ],\n  1418→        }\n  1419→    if app_model.user_pools:\n  1420→        services[\"cognito-idp\"] = {\n  1421→            \"port\": ports[\"cognito-idp\"],\n  1422→            \"resources\": [\n  1423→                {\"name\": p.user_pool_name, \"user_pool_id\": f\"us-east-1_{p.logical_id}\"}\n  1424→                for p in app_model.user_pools\n  1425→            ],\n  1426→        }\n  1427→\n  1428→\n  1429→def _mount_management_api(\n  1430→    providers: dict[str, Provider],\n  1431→    orchestrator: Orchestrator,\n  1432→    compute_providers: dict[str, ICompute],\n  1433→    port: int,\n  1434→    resource_metadata: dict[str, Any] | None = None,\n  1435→) -> None:\n  1436→    \"\"\"Mount the management API router on the API Gateway app or create a standalone one.\"\"\"\n  1437→    from fastapi import FastAPI\n  1438→\n  1439→    from lws.api.management import create_management_router\n  1440→\n  1441→    mgmt_router = create_management_router(\n  1442→        orchestrator, compute_providers, providers, resource_metadata=resource_metadata\n  1443→    )\n  1444→\n  1445→    # Try to find an existing API Gateway provider to mount on\n  1446→    for key, prov in providers.items():\n  1447→        if isinstance(prov, ApiGatewayProvider):\n  1448→            prov.app.include_router(mgmt_router)\n  1449→            return\n  1450→\n  1451→    # No API Gateway — create a standalone FastAPI app for management\n  1452→    mgmt_app = FastAPI(title=\"LDK Management\")\n  1453→    mgmt_app.include_router(mgmt_router)\n  1454→    providers[\"__management_http__\"] = _HttpServiceProvider(\n  1455→        \"management-http\", lambda: mgmt_app, port\n  1456→    )\n  1457→\n  1458→\n  1459→def _find_node_id(graph: AppGraph, node_type: NodeType, name: str) -> str | None:\n  1460→    \"\"\"Find a graph node ID by type and name.\"\"\"\n  1461→    for nid, node in graph.nodes.items():\n  1462→        if node.node_type == node_type and nid == name:\n  1463→            return nid\n  1464→    # Fallback: check config\n  1465→    for nid, node in graph.nodes.items():\n  1466→        if node.node_type == node_type:\n  1467→            if node.config.get(\"table_name\") == name or node.config.get(\"handler\") == name:\n  1468→                return nid\n  1469→    return name\n  1470→\n  1471→\n  1472→def _build_key_schema(raw_schema: list[dict[str, str]]) -> KeySchema:\n  1473→    \"\"\"Convert raw key schema dicts to a KeySchema dataclass.\"\"\"\n  1474→    pk: KeyAttribute | None = None\n  1475→    sk: KeyAttribute | None = None\n  1476→    for ks in raw_schema:\n  1477→        attr = KeyAttribute(name=ks.get(\"attribute_name\", \"pk\"), type=ks.get(\"type\", \"S\"))\n  1478→        if ks.get(\"key_type\") == \"RANGE\":\n  1479→            sk = attr\n  1480→        else:\n  1481→            pk = attr\n  1482→    if pk is None:\n  1483→        pk = KeyAttribute(name=\"pk\", type=\"S\")\n  1484→    return KeySchema(partition_key=pk, sort_key=sk)\n  1485→\n  1486→\n  1487→def _build_gsi(raw_gsi: dict) -> GsiDefinition:\n  1488→    \"\"\"Convert a raw GSI dict to a GsiDefinition dataclass.\"\"\"\n  1489→    index_name = raw_gsi.get(\"index_name\", raw_gsi.get(\"IndexName\", \"gsi\"))\n  1490→    ks_raw = raw_gsi.get(\"key_schema\", [])\n  1491→    ks = _build_key_schema(ks_raw)\n  1492→    projection = raw_gsi.get(\"projection_type\", \"ALL\")\n  1493→    return GsiDefinition(index_name=index_name, key_schema=ks, projection_type=projection)\n  1494→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"35f5a797-756b-4d71-bebf-8da557bd6c98","timestamp":"2026-02-10T23:20:24.706Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services/src/lws/cli/ldk.py","content":"\"\"\"LDK CLI entry point.\n\nProvides the ``ldk dev``, ``ldk invoke``, and ``ldk reset`` commands.\n``ldk dev`` parses a CDK cloud assembly, builds the application graph,\nstarts local providers, and watches for file changes.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport asyncio\nimport json\nimport logging\nimport shutil\nfrom collections.abc import Callable\nfrom pathlib import Path\nfrom typing import Any\n\nimport typer\nimport uvicorn\nfrom rich.console import Console\nfrom rich.syntax import Syntax\n\nfrom lws.cli.display import (\n    print_banner,\n    print_error,\n    print_resource_summary,\n    print_startup_complete,\n)\nfrom lws.config.loader import ConfigError, LdkConfig, load_config\nfrom lws.graph.builder import AppGraph, NodeType, build_graph\nfrom lws.interfaces import (\n    ComputeConfig,\n    GsiDefinition,\n    ICompute,\n    KeyAttribute,\n    KeySchema,\n    Provider,\n    TableConfig,\n)\nfrom lws.parser.assembly import AppModel, parse_assembly\nfrom lws.providers.apigateway.provider import ApiGatewayProvider, RouteConfig\nfrom lws.providers.cognito.provider import CognitoProvider\nfrom lws.providers.cognito.user_store import PasswordPolicy, UserPoolConfig\nfrom lws.providers.dynamodb.provider import SqliteDynamoProvider\nfrom lws.providers.dynamodb.routes import create_dynamodb_app\nfrom lws.providers.ecs.provider import EcsProvider\nfrom lws.providers.eventbridge.provider import (\n    EventBridgeProvider,\n    EventBusConfig,\n    RuleConfig,\n    RuleTarget,\n)\nfrom lws.providers.lambda_runtime.nodejs import NodeJsCompute\nfrom lws.providers.lambda_runtime.python import PythonCompute\nfrom lws.providers.s3.provider import S3Provider\nfrom lws.providers.s3.routes import create_s3_app\nfrom lws.providers.sns.provider import SnsProvider, TopicConfig\nfrom lws.providers.sns.routes import create_sns_app\nfrom lws.providers.sqs.provider import QueueConfig, RedrivePolicy, SqsProvider\nfrom lws.providers.sqs.routes import create_sqs_app\nfrom lws.providers.stepfunctions.provider import (\n    StateMachineConfig,\n    StepFunctionsProvider,\n    WorkflowType,\n)\nfrom lws.runtime.env_builder import build_lambda_env\nfrom lws.runtime.orchestrator import Orchestrator\nfrom lws.runtime.sdk_env import build_sdk_env\nfrom lws.runtime.synth import SynthError, ensure_synth\nfrom lws.runtime.watcher import FileWatcher\n\n_console = Console()\n\napp = typer.Typer(name=\"ldk\", help=\"Local Development Kit - Run AWS CDK applications locally\")\n\n__version__ = \"0.4.0\"\n\n\n@app.callback()\ndef main() -> None:\n    \"\"\"LDK - Local Development Kit.\"\"\"\n\n\n@app.command()\ndef dev(\n    port: int = typer.Option(None, \"--port\", \"-p\", help=\"API Gateway listen port\"),\n    no_persist: bool = typer.Option(False, \"--no-persist\", help=\"Disable data persistence\"),\n    force_synth: bool = typer.Option(False, \"--force-synth\", help=\"Force CDK synth\"),\n    log_level: str = typer.Option(\n        None, \"--log-level\", \"-l\", help=\"Log level (debug/info/warning/error)\"\n    ),\n    project_dir: Path = typer.Option(\".\", \"--project-dir\", \"-d\", help=\"Project root directory\"),\n    mode: str = typer.Option(None, \"--mode\", \"-m\", help=\"Project mode (cdk or terraform)\"),\n) -> None:\n    \"\"\"Start the local development environment.\"\"\"\n    try:\n        asyncio.run(_run_dev(project_dir, port, no_persist, force_synth, log_level, mode))\n    except KeyboardInterrupt:\n        pass\n\n\n@app.command()\ndef invoke(\n    function_name: str = typer.Option(..., \"--function-name\", \"-f\", help=\"Lambda function name\"),\n    event: str = typer.Option(None, \"--event\", \"-e\", help=\"Inline JSON event payload\"),\n    event_file: Path = typer.Option(None, \"--event-file\", help=\"Path to JSON event file\"),\n    project_dir: Path = typer.Option(\".\", \"--project-dir\", \"-d\", help=\"Project root directory\"),\n    port: int = typer.Option(None, \"--port\", \"-p\", help=\"Management API port\"),\n) -> None:\n    \"\"\"Invoke a Lambda function directly.\"\"\"\n    asyncio.run(_run_invoke(function_name, event, event_file, project_dir, port))\n\n\nasync def _run_invoke(\n    function_name: str,\n    event_json: str | None,\n    event_file: Path | None,\n    project_dir: Path,\n    port_override: int | None,\n) -> None:\n    \"\"\"Async implementation of the ``ldk invoke`` command.\"\"\"\n    # Resolve event payload\n    event_payload = _resolve_event_payload(event_json, event_file)\n\n    # Try connecting to running ldk dev via management API\n    project_dir = project_dir.resolve()\n    config = _load_config_quiet(project_dir)\n    mgmt_port = port_override or config.port\n\n    if await _try_management_invoke(mgmt_port, function_name, event_payload):\n        return\n\n    # Fallback: one-shot invocation\n    _console.print(\"[dim]No running ldk dev found, performing one-shot invocation...[/dim]\")\n    await _oneshot_invoke(project_dir, config, function_name, event_payload)\n\n\ndef _resolve_event_payload(event_json: str | None, event_file: Path | None) -> dict:\n    \"\"\"Parse event payload from CLI args.\"\"\"\n    if event_json is not None:\n        try:\n            return json.loads(event_json)\n        except json.JSONDecodeError as exc:\n            print_error(\"Invalid JSON in --event\", str(exc))\n            raise typer.Exit(1)\n\n    if event_file is not None:\n        if not event_file.exists():\n            print_error(\"Event file not found\", str(event_file))\n            raise typer.Exit(1)\n        try:\n            return json.loads(event_file.read_text())\n        except json.JSONDecodeError as exc:\n            print_error(\"Invalid JSON in event file\", str(exc))\n            raise typer.Exit(1)\n\n    return {}\n\n\nasync def _try_management_invoke(port: int, function_name: str, event: dict) -> bool:\n    \"\"\"Try to invoke via the management API. Return True if successful.\"\"\"\n    try:\n        import httpx\n\n        async with httpx.AsyncClient() as client:\n            resp = await client.post(\n                f\"http://localhost:{port}/_ldk/invoke\",\n                json={\"function_name\": function_name, \"event\": event},\n                timeout=30.0,\n            )\n            result = resp.json()\n            formatted = json.dumps(result, indent=2)\n            syntax = Syntax(formatted, \"json\", theme=\"monokai\")\n            _console.print(syntax)\n            return True\n    except Exception:\n        return False\n\n\nasync def _oneshot_invoke(\n    project_dir: Path, config: LdkConfig, function_name: str, event: dict\n) -> None:\n    \"\"\"Perform a one-shot Lambda invocation without a running server.\"\"\"\n    try:\n        import uuid as _uuid\n\n        from lws.interfaces import InvocationResult, LambdaContext\n\n        cdk_out = project_dir / config.cdk_out_dir\n        if not cdk_out.exists():\n            print_error(\"CDK output not found\", f\"Run 'cdk synth' first in {project_dir}\")\n            raise typer.Exit(1)\n\n        app_model = parse_assembly(cdk_out)\n        func_def = next((f for f in app_model.functions if f.name == function_name), None)\n        if func_def is None:\n            print_error(\"Function not found\", f\"No function named '{function_name}'\")\n            raise typer.Exit(1)\n\n        sdk_env = build_sdk_env({})\n        func_env = build_lambda_env(\n            function_name=func_def.name,\n            function_env=func_def.environment,\n            local_endpoints={},\n            resolved_refs={},\n        )\n        compute_config = ComputeConfig(\n            function_name=func_def.name,\n            handler=func_def.handler,\n            runtime=func_def.runtime,\n            code_path=func_def.code_path or Path(\".\"),\n            timeout=func_def.timeout,\n            memory_size=func_def.memory,\n            environment=func_env,\n        )\n        compute = NodeJsCompute(config=compute_config, sdk_env=sdk_env)\n        await compute.start()\n\n        request_id = str(_uuid.uuid4())\n        context = LambdaContext(\n            function_name=function_name,\n            memory_limit_in_mb=compute_config.memory_size,\n            timeout_seconds=compute_config.timeout,\n            aws_request_id=request_id,\n            invoked_function_arn=(\n                f\"arn:aws:lambda:us-east-1:000000000000:function:{function_name}\"\n            ),\n        )\n\n        result: InvocationResult = await compute.invoke(event, context)\n        await compute.stop()\n\n        output = result.payload if result.error is None else {\"error\": result.error}\n        formatted = json.dumps(output, indent=2, default=str)\n        syntax = Syntax(formatted, \"json\", theme=\"monokai\")\n        _console.print(syntax)\n\n    except typer.Exit:\n        raise\n    except Exception as exc:\n        print_error(\"Invocation failed\", str(exc))\n        raise typer.Exit(1)\n\n\n@app.command()\ndef reset(\n    yes: bool = typer.Option(False, \"--yes\", \"-y\", help=\"Skip confirmation prompt\"),\n    project_dir: Path = typer.Option(\".\", \"--project-dir\", \"-d\", help=\"Project root directory\"),\n    port: int = typer.Option(None, \"--port\", \"-p\", help=\"Management API port\"),\n) -> None:\n    \"\"\"Reset all LDK local state (databases, queues, etc.).\"\"\"\n    project_dir = project_dir.resolve()\n    config = _load_config_quiet(project_dir)\n    data_dir = project_dir / config.data_dir\n\n    if not data_dir.exists():\n        _console.print(\"[dim]No data directory found. Nothing to reset.[/dim]\")\n        return\n\n    # List contents to be deleted\n    items = list(data_dir.iterdir())\n    if not items:\n        _console.print(\"[dim]Data directory is empty. Nothing to reset.[/dim]\")\n        return\n\n    _console.print(f\"[bold]Will delete all files under:[/bold] {data_dir}\")\n    for item in items:\n        kind = \"dir\" if item.is_dir() else \"file\"\n        _console.print(f\"  [dim]{kind}:[/dim] {item.name}\")\n\n    if not yes:\n        confirm = typer.confirm(\"Are you sure you want to delete all local state?\")\n        if not confirm:\n            _console.print(\"[dim]Aborted.[/dim]\")\n            return\n\n    # Delete contents\n    deleted_count = 0\n    for item in items:\n        if item.is_dir():\n            shutil.rmtree(item)\n        else:\n            item.unlink()\n        deleted_count += 1\n\n    _console.print(f\"[green]Deleted {deleted_count} item(s) from {data_dir}[/green]\")\n\n    # Notify running ldk dev if possible\n    mgmt_port = port or config.port\n    asyncio.run(_try_management_reset(mgmt_port))\n\n\nasync def _try_management_reset(port: int) -> None:\n    \"\"\"Try to notify running ldk dev of the reset via management API.\"\"\"\n    try:\n        import httpx\n\n        async with httpx.AsyncClient() as client:\n            resp = await client.post(\n                f\"http://localhost:{port}/_ldk/reset\",\n                timeout=5.0,\n            )\n            if resp.status_code == 200:\n                _console.print(\"[dim]Notified running ldk dev of reset.[/dim]\")\n    except Exception:\n        pass  # Server not running, that's fine\n\n\ndef _load_config_quiet(project_dir: Path) -> LdkConfig:\n    \"\"\"Load config without printing errors. Falls back to defaults.\"\"\"\n    try:\n        return load_config(project_dir)\n    except ConfigError:\n        return LdkConfig()\n\n\ndef _load_and_apply_config(\n    project_dir: Path,\n    port_override: int | None,\n    no_persist: bool,\n    log_level_override: str | None,\n) -> LdkConfig:\n    \"\"\"Load config and apply CLI overrides.\"\"\"\n    try:\n        config = load_config(project_dir)\n    except ConfigError as exc:\n        print_error(\"Configuration error\", str(exc))\n        raise typer.Exit(1)\n\n    if port_override is not None:\n        config.port = port_override\n    if log_level_override is not None:\n        config.log_level = log_level_override\n    if no_persist:\n        config.persist = False\n\n    logging.basicConfig(\n        level=getattr(logging, config.log_level.upper(), logging.INFO),\n        format=\"%(levelname)s %(name)s: %(message)s\",\n    )\n    return config\n\n\ndef _collect_extra_resources(app_model: AppModel) -> dict[str, list[str]]:\n    \"\"\"Collect extra resource name lists from the app model for display.\"\"\"\n    extras: dict[str, list[str]] = {}\n    _RESOURCE_ATTRS = {\n        \"queues\": (\"name\", \"queues\"),\n        \"buckets\": (\"name\", \"buckets\"),\n        \"topics\": (\"name\", \"topics\"),\n        \"state_machines\": (\"name\", \"state_machines\"),\n        \"ecs_services\": (\"service_name\", \"ecs_services\"),\n        \"user_pools\": (\"user_pool_name\", \"user_pools\"),\n    }\n    for key, (attr, model_attr) in _RESOURCE_ATTRS.items():\n        items = getattr(app_model, model_attr, [])\n        if items:\n            extras[key] = [getattr(item, attr, str(item)) for item in items]\n    return extras\n\n\ndef _build_local_details(app_model: AppModel, port: int) -> dict[str, str]:\n    \"\"\"Build a mapping of ``\"Type:Name\"`` to local detail strings.\"\"\"\n    details: dict[str, str] = {}\n\n    _add_api_details(details, app_model)\n    _add_resource_details(details, app_model)\n    return details\n\n\ndef _add_api_details(details: dict[str, str], app_model: AppModel) -> None:\n    \"\"\"Add API route and Lambda function details.\"\"\"\n    for api_def in app_model.apis:\n        for r in api_def.routes:\n            details[f\"API Route:{r.path}\"] = (\n                f\"lws apigateway test-invoke-method --resource {r.path} --http-method {r.method}\"\n            )\n    for f in app_model.functions:\n        details[f\"Function:{f.name}\"] = f\"ldk invoke {f.name}\"\n\n\ndef _add_resource_details(details: dict[str, str], app_model: AppModel) -> None:\n    \"\"\"Add service resource details (DynamoDB, SQS, S3, etc.).\"\"\"\n    for t in app_model.tables:\n        details[f\"Table:{t.name}\"] = f\"lws dynamodb scan --table-name {t.name}\"\n    for q in app_model.queues:\n        details[f\"Queue:{q.name}\"] = f\"lws sqs receive-message --queue-name {q.name}\"\n    for b in app_model.buckets:\n        details[f\"Bucket:{b.name}\"] = f\"lws s3api list-objects-v2 --bucket {b.name}\"\n    for t in app_model.topics:\n        details[f\"Topic:{t.name}\"] = f\"lws sns publish --topic-name {t.name} --message '...'\"\n    for b in app_model.event_buses:\n        details[f\"Event Bus:{b.name}\"] = f\"lws events list-rules --event-bus-name {b.name}\"\n    for sm in app_model.state_machines:\n        details[f\"State Machine:{sm.name}\"] = f\"lws stepfunctions start-execution --name {sm.name}\"\n    for p in app_model.user_pools:\n        details[f\"User Pool:{p.user_pool_name}\"] = (\n            f\"lws cognito-idp sign-up --user-pool-name {p.user_pool_name}\"\n        )\n\n\ndef _display_summary(app_model: AppModel, port: int) -> None:\n    \"\"\"Print resource summary and startup-complete banner.\"\"\"\n    routes_info = [\n        {\"method\": r.method, \"path\": r.path, \"handler\": r.handler_name or \"\"}\n        for api_def in app_model.apis\n        for r in api_def.routes\n    ]\n    tables_info = [t.name for t in app_model.tables]\n    functions_info = [f\"{f.name} ({f.runtime})\" for f in app_model.functions]\n\n    extra_resources = _collect_extra_resources(app_model)\n    local_details = _build_local_details(app_model, port)\n    print_resource_summary(\n        routes_info, tables_info, functions_info, local_details=local_details, **extra_resources\n    )\n\n    extra_counts = {f\"num_{k}\": len(v) for k, v in extra_resources.items()}\n    print_startup_complete(\n        port,\n        num_routes=len(routes_info),\n        num_tables=len(tables_info),\n        num_functions=len(functions_info),\n        **extra_counts,\n    )\n\n\ndef _resolve_mode(project_dir: Path, config: LdkConfig, mode_override: str | None) -> str:\n    \"\"\"Resolve the project mode from CLI flag, config, or auto-detection.\n\n    Returns ``\"cdk\"`` or ``\"terraform\"``.\n    Raises ``typer.Exit(1)`` on error.\n    \"\"\"\n    from lws.terraform.detect import detect_project_type\n\n    mode = mode_override or config.mode\n    if mode:\n        if mode not in (\"cdk\", \"terraform\"):\n            print_error(\"Invalid mode\", f\"Must be 'cdk' or 'terraform', got '{mode}'\")\n            raise typer.Exit(1)\n        return mode\n\n    detected = detect_project_type(project_dir)\n    if detected == \"ambiguous\":\n        print_error(\n            \"Ambiguous project\",\n            \"Both .tf files and cdk.out found. Use --mode cdk or --mode terraform.\",\n        )\n        raise typer.Exit(1)\n    if detected == \"none\":\n        print_error(\n            \"No project found\",\n            \"No .tf files or cdk.out directory found. \"\n            \"Run from a CDK or Terraform project directory.\",\n        )\n        raise typer.Exit(1)\n    return detected\n\n\nasync def _run_dev_terraform(project_dir: Path, config: LdkConfig) -> None:\n    \"\"\"Run the dev server in Terraform mode.\n\n    Starts all service providers in always-on mode, generates the\n    Terraform provider override file, and waits for shutdown.\n    \"\"\"\n    from lws.terraform.gitignore import ensure_gitignore\n    from lws.terraform.override import cleanup_override, generate_override\n\n    port = config.port\n    data_dir = project_dir / config.data_dir\n    data_dir.mkdir(parents=True, exist_ok=True)\n\n    # Generate override file\n    try:\n        override_path = generate_override(port, project_dir)\n    except FileExistsError as exc:\n        print_error(\"Override file conflict\", str(exc))\n        raise typer.Exit(1)\n\n    ensure_gitignore(project_dir)\n\n    # Create all providers in always-on mode (no app model)\n    providers, ports = _create_terraform_providers(config, data_dir, project_dir)\n\n    orchestrator = Orchestrator()\n\n    # Enable WebSocket log streaming\n    from lws.logging.logger import WebSocketLogHandler, set_ws_handler\n\n    ws_log_handler = WebSocketLogHandler()\n    set_ws_handler(ws_log_handler)\n\n    # Build resource metadata so the CLI client can discover services\n    resource_metadata: dict[str, Any] = {\n        \"port\": port,\n        \"services\": {\n            svc_name: {\"port\": svc_port, \"resources\": []} for svc_name, svc_port in ports.items()\n        },\n    }\n\n    # Mount management API (no compute providers in terraform mode)\n    _mount_management_api(providers, orchestrator, {}, port, resource_metadata)\n\n    for key in providers:\n        pass  # All keys are already in the dict\n\n    startup_order = list(providers.keys())\n\n    try:\n        await orchestrator.start(providers, startup_order)\n    except Exception as exc:\n        cleanup_override(project_dir)\n        print_error(\"Failed to start providers\", str(exc))\n        raise typer.Exit(1)\n\n    # Display summary\n    _console.print()\n    _console.print(\"[bold green]Terraform mode active[/bold green]\")\n    _console.print(f\"  Override file: {override_path}\")\n    _console.print()\n    _console.print(\"[bold]Service endpoints:[/bold]\")\n    for svc_name, svc_port in sorted(ports.items()):\n        _console.print(f\"  {svc_name:20s} http://localhost:{svc_port}\")\n    _console.print()\n    _console.print(\"[dim]Run 'terraform init && terraform apply' to create resources.[/dim]\")\n    _console.print(f\"  Dashboard: http://localhost:{config.port}/_ldk/gui\")\n    _console.print()\n\n    try:\n        await orchestrator.wait_for_shutdown()\n    finally:\n        cleanup_override(project_dir)\n        set_ws_handler(None)\n        await orchestrator.stop()\n        typer.echo(\"Goodbye\")\n\n\ndef _create_terraform_providers(\n    config: LdkConfig,\n    data_dir: Path,\n    project_dir: Path | None = None,\n) -> tuple[dict[str, Provider], dict[str, int]]:\n    \"\"\"Create all service providers for Terraform mode (no app model).\"\"\"\n    providers: dict[str, Provider] = {}\n\n    port = config.port\n    ports = {\n        \"dynamodb\": port + 1,\n        \"sqs\": port + 2,\n        \"s3\": port + 3,\n        \"sns\": port + 4,\n        \"eventbridge\": port + 5,\n        \"stepfunctions\": port + 6,\n        \"cognito\": port + 7,\n        \"apigateway\": port + 8,\n        \"lambda\": port + 9,\n        \"iam\": port + 10,\n        \"sts\": port + 11,\n        \"ssm\": port + 12,\n        \"secretsmanager\": port + 13,\n    }\n\n    dynamo_provider = SqliteDynamoProvider(data_dir=data_dir, tables=[])\n    sqs_provider = SqsProvider()\n    s3_provider = S3Provider(data_dir=data_dir)\n    sns_provider = SnsProvider()\n    eb_provider = EventBridgeProvider()\n    sf_provider = StepFunctionsProvider()\n\n    pool_config = UserPoolConfig(\n        user_pool_id=\"us-east-1_default\",\n        user_pool_name=\"default\",\n    )\n    cognito_provider = CognitoProvider(data_dir=data_dir, config=pool_config)\n\n    _register_http_providers(\n        providers,\n        dynamo_provider=dynamo_provider,\n        sqs_provider=sqs_provider,\n        s3_provider=s3_provider,\n        sns_provider=sns_provider,\n        eb_provider=eb_provider,\n        sf_provider=sf_provider,\n        cognito_provider=cognito_provider,\n        ports=ports,\n    )\n\n    # Shared Lambda registry for Lambda management and API Gateway V2 proxy\n    from lws.providers.lambda_runtime.routes import LambdaRegistry, create_lambda_management_app\n\n    lambda_registry = LambdaRegistry()\n\n    # Wire Lambda registry compute providers into Step Functions so SFN can\n    # invoke Lambda functions that Terraform creates dynamically.\n    sf_provider.set_compute_providers(lambda_registry._compute)\n\n    # Build SDK env so Lambda functions can reach local services\n    local_endpoints: dict[str, str] = {\n        \"dynamodb\": f\"http://127.0.0.1:{ports['dynamodb']}\",\n        \"sqs\": f\"http://127.0.0.1:{ports['sqs']}\",\n        \"s3\": f\"http://127.0.0.1:{ports['s3']}\",\n        \"sns\": f\"http://127.0.0.1:{ports['sns']}\",\n        \"events\": f\"http://127.0.0.1:{ports['eventbridge']}\",\n        \"stepfunctions\": f\"http://127.0.0.1:{ports['stepfunctions']}\",\n        \"cognito-idp\": f\"http://127.0.0.1:{ports['cognito']}\",\n        \"ssm\": f\"http://127.0.0.1:{ports['ssm']}\",\n        \"secretsmanager\": f\"http://127.0.0.1:{ports['secretsmanager']}\",\n    }\n    sdk_env = build_sdk_env(local_endpoints)\n\n    # Lambda management API\n    providers[\"__lambda_http__\"] = _HttpServiceProvider(\n        \"lambda-http\",\n        lambda: create_lambda_management_app(lambda_registry, project_dir, sdk_env),\n        ports[\"lambda\"],\n    )\n\n    # API Gateway management API with V2 support and Lambda proxy\n    from lws.providers.apigateway.routes import create_apigateway_management_app\n\n    providers[\"__apigateway_http__\"] = _HttpServiceProvider(\n        \"apigateway-http\",\n        lambda: create_apigateway_management_app(lambda_registry),\n        ports[\"apigateway\"],\n    )\n\n    # IAM stub\n    from lws.providers.iam.routes import create_iam_app\n\n    providers[\"__iam_http__\"] = _HttpServiceProvider(\"iam-http\", create_iam_app, ports[\"iam\"])\n\n    # STS stub\n    from lws.providers.sts.routes import create_sts_app\n\n    providers[\"__sts_http__\"] = _HttpServiceProvider(\"sts-http\", create_sts_app, ports[\"sts\"])\n\n    # SSM Parameter Store\n    from lws.providers.ssm.routes import create_ssm_app\n\n    providers[\"__ssm_http__\"] = _HttpServiceProvider(\"ssm-http\", create_ssm_app, ports[\"ssm\"])\n\n    # Secrets Manager\n    from lws.providers.secretsmanager.routes import create_secretsmanager_app\n\n    providers[\"__secretsmanager_http__\"] = _HttpServiceProvider(\n        \"secretsmanager-http\", create_secretsmanager_app, ports[\"secretsmanager\"]\n    )\n\n    return providers, ports\n\n\ndef _has_any_resources(app_model: AppModel) -> bool:\n    \"\"\"Return True if the app model contains at least one resource.\"\"\"\n    return bool(\n        app_model.functions\n        or app_model.tables\n        or app_model.apis\n        or app_model.queues\n        or app_model.buckets\n        or app_model.topics\n        or app_model.event_buses\n        or app_model.state_machines\n        or app_model.ecs_services\n        or app_model.user_pools\n    )\n\n\nasync def _run_dev(\n    project_dir: Path,\n    port_override: int | None,\n    no_persist: bool,\n    force_synth: bool,\n    log_level_override: str | None,\n    mode_override: str | None = None,\n) -> None:\n    \"\"\"Async implementation of the ``ldk dev`` command.\"\"\"\n    project_dir = project_dir.resolve()\n    config = _load_and_apply_config(project_dir, port_override, no_persist, log_level_override)\n    print_banner(__version__, project_dir.name)\n\n    # Resolve project mode\n    resolved_mode = _resolve_mode(project_dir, config, mode_override)\n    if resolved_mode == \"terraform\":\n        await _run_dev_terraform(project_dir, config)\n        return\n\n    try:\n        cdk_out = await ensure_synth(project_dir, force=force_synth)\n    except SynthError as exc:\n        print_error(\"CDK synth failed\", str(exc))\n        raise typer.Exit(1)\n\n    app_model = parse_assembly(cdk_out)\n    if not _has_any_resources(app_model):\n        print_error(\"No resources found in cloud assembly\", str(cdk_out))\n        raise typer.Exit(1)\n\n    graph = build_graph(app_model)\n    startup_order = graph.topological_sort()\n\n    data_dir = project_dir / config.data_dir\n    data_dir.mkdir(parents=True, exist_ok=True)\n    providers, compute_providers = _create_providers(app_model, graph, config, data_dir)\n\n    orchestrator = Orchestrator()\n\n    # Enable WebSocket log streaming\n    from lws.logging.logger import WebSocketLogHandler, set_ws_handler\n\n    ws_log_handler = WebSocketLogHandler()\n    set_ws_handler(ws_log_handler)\n\n    # Mount management API\n    resource_metadata = _build_resource_metadata(app_model, config.port)\n    _mount_management_api(\n        providers, orchestrator, compute_providers, config.port, resource_metadata\n    )\n\n    # Append non-graph provider keys (HTTP servers, management) to startup order.\n    # This must happen after _mount_management_api so the fallback management\n    # HTTP server (when no API Gateway exists) is included in the startup order.\n    for key in providers:\n        if key not in startup_order:\n            startup_order.append(key)\n\n    try:\n        await orchestrator.start(providers, startup_order)\n    except Exception as exc:\n        print_error(\"Failed to start providers\", str(exc))\n        raise typer.Exit(1)\n\n    _display_summary(app_model, config.port)\n    typer.echo(f\"  Dashboard: http://localhost:{config.port}/_ldk/gui\")\n\n    watcher = FileWatcher(\n        watch_dir=project_dir,\n        include_patterns=config.watch_include,\n        exclude_patterns=config.watch_exclude,\n    )\n    watcher.on_change(lambda path: logging.getLogger(\"ldk.watcher\").info(\"Changed: %s\", path))\n    watcher.start()\n\n    try:\n        await orchestrator.wait_for_shutdown()\n    finally:\n        watcher.stop()\n        set_ws_handler(None)\n        await orchestrator.stop()\n        typer.echo(\"Goodbye\")\n\n\ndef _create_dynamo_providers(\n    app_model: AppModel,\n    graph: AppGraph,\n    data_dir: Path,\n) -> tuple[SqliteDynamoProvider, dict[str, Provider]]:\n    \"\"\"Create DynamoDB table providers from the app model.\n\n    Always returns a provider (even with no CDK tables) so the DynamoDB\n    HTTP endpoint is available for Terraform/CLI table creation.\n    \"\"\"\n    providers: dict[str, Provider] = {}\n    table_configs: list[TableConfig] = []\n    for table in app_model.tables:\n        ks = _build_key_schema(table.key_schema)\n        gsi_defs = [_build_gsi(g) for g in table.gsi_definitions]\n        table_configs.append(\n            TableConfig(table_name=table.name, key_schema=ks, gsi_definitions=gsi_defs)\n        )\n\n    dynamo_provider = SqliteDynamoProvider(data_dir=data_dir, tables=table_configs)\n    for table in app_model.tables:\n        node_id = _find_node_id(graph, NodeType.DYNAMODB_TABLE, table.name)\n        if node_id:\n            providers[node_id] = dynamo_provider\n    return dynamo_provider, providers\n\n\ndef _create_compute_providers(\n    app_model: AppModel,\n    graph: AppGraph,\n    local_endpoints: dict[str, str],\n    sdk_env: dict[str, str],\n) -> tuple[dict[str, ICompute], dict[str, Provider]]:\n    \"\"\"Create Lambda compute providers from the app model (Node.js + Python).\"\"\"\n    providers: dict[str, Provider] = {}\n    compute_providers: dict[str, ICompute] = {}\n    for func in app_model.functions:\n        func_env = build_lambda_env(\n            function_name=func.name,\n            function_env=func.environment,\n            local_endpoints=local_endpoints,\n            resolved_refs={},\n        )\n        compute_config = ComputeConfig(\n            function_name=func.name,\n            handler=func.handler,\n            runtime=func.runtime,\n            code_path=func.code_path or Path(\".\"),\n            timeout=func.timeout,\n            memory_size=func.memory,\n            environment=func_env,\n        )\n        if func.runtime.startswith(\"python\"):\n            compute: ICompute = PythonCompute(config=compute_config, sdk_env=sdk_env)\n        elif func.runtime.startswith(\"nodejs\"):\n            compute = NodeJsCompute(config=compute_config, sdk_env=sdk_env)\n        else:\n            logging.getLogger(\"ldk.cli\").warning(\n                \"Unsupported runtime %s for %s, skipping\", func.runtime, func.name\n            )\n            continue\n        compute_providers[func.name] = compute\n        node_id = _find_node_id(graph, NodeType.LAMBDA_FUNCTION, func.name)\n        if node_id:\n            providers[node_id] = compute\n    return compute_providers, providers\n\n\ndef _create_api_providers(\n    app_model: AppModel,\n    graph: AppGraph,\n    compute_providers: dict[str, ICompute],\n    port: int,\n) -> tuple[ApiGatewayProvider | None, dict[str, Provider]]:\n    \"\"\"Create API Gateway providers from the app model.\"\"\"\n    providers: dict[str, Provider] = {}\n    api_provider: ApiGatewayProvider | None = None\n    for api_def in app_model.apis:\n        route_configs = [\n            RouteConfig(method=r.method, path=r.path, handler_name=r.handler_name)\n            for r in api_def.routes\n            if r.handler_name and r.handler_name in compute_providers\n        ]\n        if route_configs:\n            api_provider = ApiGatewayProvider(\n                routes=route_configs, compute_providers=compute_providers, port=port\n            )\n            node_id = _find_node_id(graph, NodeType.API_GATEWAY, api_def.name)\n            if node_id:\n                providers[node_id] = api_provider\n    return api_provider, providers\n\n\ndef _create_sqs_providers(\n    app_model: AppModel,\n    graph: AppGraph,\n) -> tuple[SqsProvider, dict[str, Provider]]:\n    \"\"\"Create SQS queue providers from the app model.\n\n    Always returns a provider (even with no CDK queues) so the SQS\n    HTTP endpoint is available for Terraform/CLI queue creation.\n    \"\"\"\n    providers: dict[str, Provider] = {}\n    queue_configs = []\n    for q in app_model.queues:\n        redrive = None\n        if q.redrive_target:\n            redrive = RedrivePolicy(\n                dead_letter_queue_name=q.redrive_target, max_receive_count=q.max_receive_count\n            )\n        queue_configs.append(\n            QueueConfig(\n                queue_name=q.name,\n                visibility_timeout=q.visibility_timeout,\n                is_fifo=q.is_fifo,\n                content_based_dedup=q.content_based_dedup,\n                redrive_policy=redrive,\n            )\n        )\n    sqs_provider = SqsProvider(queues=queue_configs if queue_configs else None)\n    for q in app_model.queues:\n        node_id = _find_node_id(graph, NodeType.SQS_QUEUE, q.name)\n        if node_id:\n            providers[node_id] = sqs_provider\n    return sqs_provider, providers\n\n\ndef _create_s3_providers(\n    app_model: AppModel,\n    graph: AppGraph,\n    data_dir: Path,\n) -> tuple[S3Provider, dict[str, Provider]]:\n    \"\"\"Create S3 bucket providers from the app model.\n\n    Always returns a provider (even with no CDK buckets) so the S3\n    HTTP endpoint is available for Terraform/CLI bucket creation.\n    \"\"\"\n    providers: dict[str, Provider] = {}\n    bucket_names = [b.name for b in app_model.buckets]\n    s3_provider = S3Provider(data_dir=data_dir, buckets=bucket_names if bucket_names else None)\n    for b in app_model.buckets:\n        node_id = _find_node_id(graph, NodeType.S3_BUCKET, b.name)\n        if node_id:\n            providers[node_id] = s3_provider\n    return s3_provider, providers\n\n\ndef _create_sns_providers(\n    app_model: AppModel,\n    graph: AppGraph,\n) -> tuple[SnsProvider, dict[str, Provider]]:\n    \"\"\"Create SNS topic providers from the app model.\n\n    Always returns a provider (even with no CDK topics) so the SNS\n    HTTP endpoint is available for Terraform/CLI topic creation.\n    \"\"\"\n    providers: dict[str, Provider] = {}\n    topic_configs = [\n        TopicConfig(topic_name=t.name, topic_arn=t.topic_arn) for t in app_model.topics\n    ]\n    sns_provider = SnsProvider(topics=topic_configs if topic_configs else None)\n    for t in app_model.topics:\n        node_id = _find_node_id(graph, NodeType.SNS_TOPIC, t.name)\n        if node_id:\n            providers[node_id] = sns_provider\n    return sns_provider, providers\n\n\ndef _create_eventbridge_providers(\n    app_model: AppModel,\n    graph: AppGraph,\n) -> tuple[EventBridgeProvider, dict[str, Provider]]:\n    \"\"\"Create EventBridge providers from the app model.\n\n    Always returns a provider (even with no CDK buses) so the EventBridge\n    HTTP endpoint is available for Terraform/CLI event bus creation.\n    \"\"\"\n    providers: dict[str, Provider] = {}\n    bus_configs = [\n        EventBusConfig(bus_name=b.name, bus_arn=b.bus_arn) for b in app_model.event_buses\n    ]\n    rule_configs = []\n    for r in app_model.event_rules:\n        targets = [\n            RuleTarget(target_id=t[\"target_id\"], arn=t[\"arn\"], input_path=t.get(\"input_path\"))\n            for t in r.targets\n        ]\n        rule_configs.append(\n            RuleConfig(\n                rule_name=r.rule_name,\n                event_bus_name=r.event_bus_name,\n                event_pattern=r.event_pattern,\n                schedule_expression=r.schedule_expression,\n                targets=targets,\n            )\n        )\n    eb_provider = EventBridgeProvider(\n        buses=bus_configs if bus_configs else None,\n        rules=rule_configs if rule_configs else None,\n    )\n    for b in app_model.event_buses:\n        node_id = _find_node_id(graph, NodeType.EVENT_BUS, b.name)\n        if node_id:\n            providers[node_id] = eb_provider\n    return eb_provider, providers\n\n\ndef _create_stepfunctions_providers(\n    app_model: AppModel,\n    graph: AppGraph,\n) -> tuple[StepFunctionsProvider, dict[str, Provider]]:\n    \"\"\"Create Step Functions providers from the app model.\n\n    Always returns a provider (even with no CDK state machines) so the\n    Step Functions HTTP endpoint is available for Terraform/CLI creation.\n    \"\"\"\n    providers: dict[str, Provider] = {}\n    sm_configs = []\n    for sm in app_model.state_machines:\n        wf_type = WorkflowType.EXPRESS if sm.workflow_type == \"EXPRESS\" else WorkflowType.STANDARD\n        sm_configs.append(\n            StateMachineConfig(\n                name=sm.name,\n                definition=sm.definition,\n                workflow_type=wf_type,\n                role_arn=sm.role_arn,\n                definition_substitutions=sm.definition_substitutions,\n            )\n        )\n    sf_provider = StepFunctionsProvider(\n        state_machines=sm_configs if sm_configs else None,\n    )\n    for sm in app_model.state_machines:\n        node_id = _find_node_id(graph, NodeType.STATE_MACHINE, sm.name)\n        if node_id:\n            providers[node_id] = sf_provider\n    return sf_provider, providers\n\n\ndef _create_ecs_providers(\n    app_model: AppModel,\n    graph: AppGraph,\n) -> tuple[EcsProvider, dict[str, Provider]]:\n    \"\"\"Create ECS service providers from the app model.\n\n    Always returns a provider (even with no CDK services).\n    \"\"\"\n    providers: dict[str, Provider] = {}\n    ecs_provider = EcsProvider(\n        services=app_model.ecs_services if app_model.ecs_services else None,\n    )\n    for svc in app_model.ecs_services:\n        svc_name = getattr(svc, \"service_name\", str(id(svc)))\n        node_id = _find_node_id(graph, NodeType.ECS_SERVICE, svc_name)\n        if node_id:\n            providers[node_id] = ecs_provider\n    return ecs_provider, providers\n\n\ndef _create_cognito_providers(\n    app_model: AppModel,\n    data_dir: Path,\n    compute_providers: dict[str, ICompute],\n) -> tuple[CognitoProvider, dict[str, Provider]]:\n    \"\"\"Create Cognito user pool providers from the app model.\n\n    Always returns a provider (even with no CDK user pools) so the\n    Cognito HTTP endpoint is available for Terraform/CLI user pool creation.\n    \"\"\"\n    providers: dict[str, Provider] = {}\n    if not app_model.user_pools:\n        pool_config = UserPoolConfig(\n            user_pool_id=\"us-east-1_default\",\n            user_pool_name=\"default\",\n        )\n        cognito_provider = CognitoProvider(data_dir=data_dir, config=pool_config)\n        return cognito_provider, providers\n    # Use the first user pool (multi-pool support can be added later)\n    pool = app_model.user_pools[0]\n    pw = pool.password_policy\n    password_policy = PasswordPolicy(\n        minimum_length=int(pw.get(\"MinimumLength\", 8)),\n        require_lowercase=bool(pw.get(\"RequireLowercase\", True)),\n        require_uppercase=bool(pw.get(\"RequireUppercase\", True)),\n        require_digits=bool(pw.get(\"RequireNumbers\", pw.get(\"RequireDigits\", True))),\n        require_symbols=bool(pw.get(\"RequireSymbols\", False)),\n    )\n    pool_config = UserPoolConfig(\n        user_pool_id=f\"us-east-1_{pool.logical_id}\",\n        user_pool_name=pool.user_pool_name,\n        password_policy=password_policy,\n        auto_confirm=pool.auto_confirm,\n        client_id=pool.client_id or \"local-client-id\",\n        pre_authentication_trigger=pool.pre_auth_trigger,\n        post_confirmation_trigger=pool.post_confirm_trigger,\n    )\n    trigger_funcs = {}\n    if pool.pre_auth_trigger and pool.pre_auth_trigger in compute_providers:\n        trigger_funcs[\"PreAuthentication\"] = compute_providers[pool.pre_auth_trigger]\n    if pool.post_confirm_trigger and pool.post_confirm_trigger in compute_providers:\n        trigger_funcs[\"PostConfirmation\"] = compute_providers[pool.post_confirm_trigger]\n    cognito_provider = CognitoProvider(\n        data_dir=data_dir, config=pool_config, trigger_functions=trigger_funcs or None\n    )\n    providers[f\"__cognito_{pool.logical_id}__\"] = cognito_provider\n    return cognito_provider, providers\n\n\ndef _wire_remaining_providers(\n    app_model: AppModel,\n    graph: AppGraph,\n    providers: dict[str, Provider],\n    compute_providers: dict[str, ICompute],\n    sqs_provider: SqsProvider,\n    local_endpoints: dict[str, str],\n    data_dir: Path,\n    api_port: int,\n    *,\n    sns_port: int,\n    eb_port: int,\n    sf_port: int,\n    cognito_port: int,\n) -> tuple[\n    SnsProvider,\n    EventBridgeProvider,\n    StepFunctionsProvider,\n    CognitoProvider,\n]:\n    \"\"\"Wire messaging, cognito, and API Gateway providers.\"\"\"\n    sns_provider, sns_providers = _create_sns_providers(app_model, graph)\n    providers.update(sns_providers)\n    sns_provider.set_compute_providers(compute_providers)\n    sns_provider.set_queue_provider(sqs_provider)\n    local_endpoints[\"sns\"] = f\"http://127.0.0.1:{sns_port}\"\n\n    eb_provider, eb_providers = _create_eventbridge_providers(app_model, graph)\n    providers.update(eb_providers)\n    eb_provider.set_compute_providers(compute_providers)\n    local_endpoints[\"events\"] = f\"http://127.0.0.1:{eb_port}\"\n\n    sf_provider, sf_providers = _create_stepfunctions_providers(app_model, graph)\n    providers.update(sf_providers)\n    sf_provider.set_compute_providers(compute_providers)\n    local_endpoints[\"stepfunctions\"] = f\"http://127.0.0.1:{sf_port}\"\n\n    cognito_provider, cognito_providers = _create_cognito_providers(\n        app_model, data_dir, compute_providers\n    )\n    providers.update(cognito_providers)\n    local_endpoints[\"cognito-idp\"] = f\"http://127.0.0.1:{cognito_port}\"\n\n    api_provider, api_providers = _create_api_providers(\n        app_model, graph, compute_providers, api_port\n    )\n    providers.update(api_providers)\n\n    return sns_provider, eb_provider, sf_provider, cognito_provider\n\n\ndef _create_providers(\n    app_model: AppModel,\n    graph: AppGraph,\n    config: LdkConfig,\n    data_dir: Path,\n) -> tuple[dict[str, Provider], dict[str, ICompute]]:\n    \"\"\"Instantiate providers from the parsed app model.\n\n    Returns a tuple of (provider map, compute_providers).\n    \"\"\"\n    providers: dict[str, Provider] = {}\n\n    # Port allocation: base+1 DynamoDB, +2 SQS, +3 S3, +4 SNS, +5 EventBridge,\n    # +6 Step Functions, +7 Cognito, +12 SSM, +13 Secrets Manager\n    dynamo_port = config.port + 1\n    sqs_port = config.port + 2\n    s3_port = config.port + 3\n    sns_port = config.port + 4\n    eb_port = config.port + 5\n    sf_port = config.port + 6\n    cognito_port = config.port + 7\n    ssm_port = config.port + 12\n    secretsmanager_port = config.port + 13\n\n    # 1. Storage providers (no deps)\n    dynamo_provider, dynamo_providers = _create_dynamo_providers(app_model, graph, data_dir)\n    providers.update(dynamo_providers)\n\n    sqs_provider, sqs_providers = _create_sqs_providers(app_model, graph)\n    providers.update(sqs_providers)\n\n    s3_provider, s3_providers = _create_s3_providers(app_model, graph, data_dir)\n    providers.update(s3_providers)\n\n    # 2. Build local_endpoints for SDK env redirection\n    local_endpoints: dict[str, str] = {}\n    local_endpoints[\"dynamodb\"] = f\"http://127.0.0.1:{dynamo_port}\"\n    local_endpoints[\"sqs\"] = f\"http://127.0.0.1:{sqs_port}\"\n    local_endpoints[\"s3\"] = f\"http://127.0.0.1:{s3_port}\"\n\n    # 3. Compute (Lambda — Node.js + Python)\n    sdk_env = build_sdk_env(local_endpoints)\n    compute_providers, compute_graph_providers = _create_compute_providers(\n        app_model, graph, local_endpoints, sdk_env\n    )\n    providers.update(compute_graph_providers)\n\n    # 4-6. Messaging, ECS, Cognito, API Gateway\n    sns_provider, eb_provider, sf_provider, cognito_provider = _wire_remaining_providers(\n        app_model,\n        graph,\n        providers,\n        compute_providers,\n        sqs_provider,\n        local_endpoints,\n        data_dir,\n        config.port,\n        sns_port=sns_port,\n        eb_port=eb_port,\n        sf_port=sf_port,\n        cognito_port=cognito_port,\n    )\n    ecs_provider, ecs_providers = _create_ecs_providers(app_model, graph)\n    providers.update(ecs_providers)\n\n    # 7. Add SSM and Secrets Manager endpoints, rebuild SDK env, update compute\n    local_endpoints[\"ssm\"] = f\"http://127.0.0.1:{ssm_port}\"\n    local_endpoints[\"secretsmanager\"] = f\"http://127.0.0.1:{secretsmanager_port}\"\n    sdk_env = build_sdk_env(local_endpoints)\n    for compute in compute_providers.values():\n        if hasattr(compute, \"_sdk_env\"):\n            compute._sdk_env = sdk_env\n\n    # 8. Create HTTP servers for each active service\n    _register_http_providers(\n        providers,\n        dynamo_provider=dynamo_provider,\n        sqs_provider=sqs_provider,\n        s3_provider=s3_provider,\n        sns_provider=sns_provider,\n        eb_provider=eb_provider,\n        sf_provider=sf_provider,\n        cognito_provider=cognito_provider,\n        ports={\n            \"dynamodb\": dynamo_port,\n            \"sqs\": sqs_port,\n            \"s3\": s3_port,\n            \"sns\": sns_port,\n            \"eventbridge\": eb_port,\n            \"stepfunctions\": sf_port,\n            \"cognito\": cognito_port,\n        },\n    )\n\n    # 9. SSM Parameter Store and Secrets Manager\n    from lws.providers.secretsmanager.routes import create_secretsmanager_app\n    from lws.providers.ssm.routes import create_ssm_app\n\n    providers[\"__ssm_http__\"] = _HttpServiceProvider(\n        \"ssm-http\", create_ssm_app, ssm_port\n    )\n    providers[\"__secretsmanager_http__\"] = _HttpServiceProvider(\n        \"secretsmanager-http\", create_secretsmanager_app, secretsmanager_port\n    )\n\n    return providers, compute_providers\n\n\ndef _register_http_providers(\n    providers: dict[str, Provider],\n    *,\n    dynamo_provider: SqliteDynamoProvider,\n    sqs_provider: SqsProvider,\n    s3_provider: S3Provider,\n    sns_provider: SnsProvider,\n    eb_provider: EventBridgeProvider,\n    sf_provider: StepFunctionsProvider,\n    cognito_provider: CognitoProvider,\n    ports: dict[str, int],\n) -> None:\n    \"\"\"Register HTTP service providers for each active backend.\"\"\"\n    from lws.providers.cognito.routes import create_cognito_app\n    from lws.providers.eventbridge.routes import create_eventbridge_app\n    from lws.providers.stepfunctions.routes import create_stepfunctions_app\n\n    http_services: list[tuple[str, Any, Callable[[], Any]]] = []\n    http_services.append(\n        (\"dynamodb\", ports[\"dynamodb\"], lambda p=dynamo_provider: create_dynamodb_app(p))\n    )\n    http_services.append(\n        (\"sqs\", ports[\"sqs\"], lambda p=sqs_provider, pt=ports[\"sqs\"]: create_sqs_app(p, pt))\n    )\n    http_services.append((\"s3\", ports[\"s3\"], lambda p=s3_provider: create_s3_app(p)))\n    http_services.append((\"sns\", ports[\"sns\"], lambda p=sns_provider: create_sns_app(p)))\n    http_services.append(\n        (\"eventbridge\", ports[\"eventbridge\"], lambda p=eb_provider: create_eventbridge_app(p))\n    )\n    http_services.append(\n        (\n            \"stepfunctions\",\n            ports[\"stepfunctions\"],\n            lambda p=sf_provider: create_stepfunctions_app(p),\n        )\n    )\n    http_services.append(\n        (\"cognito\", ports[\"cognito\"], lambda p=cognito_provider: create_cognito_app(p))\n    )\n\n    for svc_name, port, factory in http_services:\n        providers[f\"__{svc_name}_http__\"] = _HttpServiceProvider(f\"{svc_name}-http\", factory, port)\n\n\nclass _HttpServiceProvider(Provider):\n    \"\"\"Generic wrapper that runs any FastAPI app as a uvicorn-served Provider.\"\"\"\n\n    def __init__(self, service_name: str, app_factory: Callable[[], Any], port: int) -> None:\n        self._service_name = service_name\n        self._app_factory = app_factory\n        self._port = port\n        self._server: uvicorn.Server | None = None\n        self._task: asyncio.Task | None = None  # type: ignore[type-arg]\n\n    @property\n    def name(self) -> str:\n        return self._service_name\n\n    async def start(self) -> None:\n        http_app = self._app_factory()\n        uvi_config = uvicorn.Config(\n            app=http_app,\n            host=\"0.0.0.0\",\n            port=self._port,\n            log_level=\"warning\",\n        )\n        self._server = uvicorn.Server(uvi_config)\n        self._task = asyncio.create_task(self._server.serve())\n        # Wait for the server to actually bind before reporting as started\n        for _ in range(50):\n            if self._server.started:\n                break\n            await asyncio.sleep(0.1)\n\n    async def stop(self) -> None:\n        if self._server is not None:\n            self._server.should_exit = True\n        if self._task is not None:\n            await self._task\n            self._task = None\n        self._server = None\n\n    async def health_check(self) -> bool:\n        return self._server is not None\n\n\ndef _build_resource_metadata(app_model: AppModel, port: int) -> dict[str, Any]:\n    \"\"\"Build resource metadata for the ``/_ldk/resources`` endpoint.\"\"\"\n    metadata: dict[str, Any] = {\"port\": port, \"services\": {}}\n    services = metadata[\"services\"]\n    ports = _service_ports(port)\n\n    _add_api_metadata(services, app_model, port)\n    _add_service_metadata(services, app_model, ports)\n    return metadata\n\n\ndef _service_ports(port: int) -> dict[str, int]:\n    \"\"\"Return a mapping of service name to port number.\"\"\"\n    return {\n        \"dynamodb\": port + 1,\n        \"sqs\": port + 2,\n        \"s3\": port + 3,\n        \"sns\": port + 4,\n        \"events\": port + 5,\n        \"stepfunctions\": port + 6,\n        \"cognito-idp\": port + 7,\n        \"ssm\": port + 12,\n        \"secretsmanager\": port + 13,\n    }\n\n\ndef _add_api_metadata(services: dict[str, Any], app_model: AppModel, port: int) -> None:\n    \"\"\"Add API Gateway metadata to services.\"\"\"\n    if not app_model.apis:\n        return\n    routes = []\n    for api_def in app_model.apis:\n        for r in api_def.routes:\n            routes.append(\n                {\n                    \"name\": api_def.name,\n                    \"path\": r.path,\n                    \"method\": r.method,\n                    \"handler\": r.handler_name or \"\",\n                }\n            )\n    services[\"apigateway\"] = {\"port\": port, \"resources\": routes}\n\n\ndef _add_service_metadata(\n    services: dict[str, Any], app_model: AppModel, ports: dict[str, int]\n) -> None:\n    \"\"\"Add non-API service metadata to services.\"\"\"\n    if app_model.functions:\n        services[\"lambda\"] = {\n            \"resources\": [\n                {\n                    \"name\": f.name,\n                    \"runtime\": f.runtime,\n                    \"arn\": f\"arn:aws:lambda:us-east-1:000000000000:function:{f.name}\",\n                }\n                for f in app_model.functions\n            ],\n        }\n    if app_model.tables:\n        services[\"dynamodb\"] = {\n            \"port\": ports[\"dynamodb\"],\n            \"resources\": [{\"name\": t.name} for t in app_model.tables],\n        }\n    if app_model.queues:\n        sqs_port = ports[\"sqs\"]\n        services[\"sqs\"] = {\n            \"port\": sqs_port,\n            \"resources\": [\n                {\n                    \"name\": q.name,\n                    \"queue_url\": f\"http://localhost:{sqs_port}/000000000000/{q.name}\",\n                }\n                for q in app_model.queues\n            ],\n        }\n    if app_model.buckets:\n        services[\"s3\"] = {\n            \"port\": ports[\"s3\"],\n            \"resources\": [{\"name\": b.name} for b in app_model.buckets],\n        }\n    if app_model.topics:\n        services[\"sns\"] = {\n            \"port\": ports[\"sns\"],\n            \"resources\": [\n                {\n                    \"name\": t.name,\n                    \"arn\": t.topic_arn or f\"arn:aws:sns:us-east-1:000000000000:{t.name}\",\n                }\n                for t in app_model.topics\n            ],\n        }\n    if app_model.event_buses:\n        services[\"events\"] = {\n            \"port\": ports[\"events\"],\n            \"resources\": [\n                {\n                    \"name\": b.name,\n                    \"arn\": b.bus_arn or f\"arn:aws:events:us-east-1:000000000000:event-bus/{b.name}\",\n                }\n                for b in app_model.event_buses\n            ],\n        }\n    if app_model.state_machines:\n        services[\"stepfunctions\"] = {\n            \"port\": ports[\"stepfunctions\"],\n            \"resources\": [\n                {\n                    \"name\": sm.name,\n                    \"arn\": f\"arn:aws:states:us-east-1:000000000000:stateMachine:{sm.name}\",\n                }\n                for sm in app_model.state_machines\n            ],\n        }\n    if app_model.user_pools:\n        services[\"cognito-idp\"] = {\n            \"port\": ports[\"cognito-idp\"],\n            \"resources\": [\n                {\"name\": p.user_pool_name, \"user_pool_id\": f\"us-east-1_{p.logical_id}\"}\n                for p in app_model.user_pools\n            ],\n        }\n\n\ndef _mount_management_api(\n    providers: dict[str, Provider],\n    orchestrator: Orchestrator,\n    compute_providers: dict[str, ICompute],\n    port: int,\n    resource_metadata: dict[str, Any] | None = None,\n) -> None:\n    \"\"\"Mount the management API router on the API Gateway app or create a standalone one.\"\"\"\n    from fastapi import FastAPI\n\n    from lws.api.management import create_management_router\n\n    mgmt_router = create_management_router(\n        orchestrator, compute_providers, providers, resource_metadata=resource_metadata\n    )\n\n    # Try to find an existing API Gateway provider to mount on\n    for key, prov in providers.items():\n        if isinstance(prov, ApiGatewayProvider):\n            prov.app.include_router(mgmt_router)\n            return\n\n    # No API Gateway — create a standalone FastAPI app for management\n    mgmt_app = FastAPI(title=\"LDK Management\")\n    mgmt_app.include_router(mgmt_router)\n    providers[\"__management_http__\"] = _HttpServiceProvider(\n        \"management-http\", lambda: mgmt_app, port\n    )\n\n\ndef _find_node_id(graph: AppGraph, node_type: NodeType, name: str) -> str | None:\n    \"\"\"Find a graph node ID by type and name.\"\"\"\n    for nid, node in graph.nodes.items():\n        if node.node_type == node_type and nid == name:\n            return nid\n    # Fallback: check config\n    for nid, node in graph.nodes.items():\n        if node.node_type == node_type:\n            if node.config.get(\"table_name\") == name or node.config.get(\"handler\") == name:\n                return nid\n    return name\n\n\ndef _build_key_schema(raw_schema: list[dict[str, str]]) -> KeySchema:\n    \"\"\"Convert raw key schema dicts to a KeySchema dataclass.\"\"\"\n    pk: KeyAttribute | None = None\n    sk: KeyAttribute | None = None\n    for ks in raw_schema:\n        attr = KeyAttribute(name=ks.get(\"attribute_name\", \"pk\"), type=ks.get(\"type\", \"S\"))\n        if ks.get(\"key_type\") == \"RANGE\":\n            sk = attr\n        else:\n            pk = attr\n    if pk is None:\n        pk = KeyAttribute(name=\"pk\", type=\"S\")\n    return KeySchema(partition_key=pk, sort_key=sk)\n\n\ndef _build_gsi(raw_gsi: dict) -> GsiDefinition:\n    \"\"\"Convert a raw GSI dict to a GsiDefinition dataclass.\"\"\"\n    index_name = raw_gsi.get(\"index_name\", raw_gsi.get(\"IndexName\", \"gsi\"))\n    ks_raw = raw_gsi.get(\"key_schema\", [])\n    ks = _build_key_schema(ks_raw)\n    projection = raw_gsi.get(\"projection_type\", \"ALL\")\n    return GsiDefinition(index_name=index_name, key_schema=ks, projection_type=projection)\n","numLines":1494,"startLine":1,"totalLines":1494}},"sourceToolAssistantUUID":"e00abf84-158f-42e1-b2fc-f413c82a0732"}
{"parentUuid":"35f5a797-756b-4d71-bebf-8da557bd6c98","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","message":{"model":"claude-opus-4-6","id":"msg_01EnEZN4do2x49h42UGYbLo3","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"Now I have a clear picture of all the files. Let me create the task list and start implementing the changes.","signature":"EpQCCkYICxgCKkArK/jVGDW1VKra9d9xYEcoWkgHxhpiPX//I7YTO60pxp8EqaQU1gHSD/B2yr8kMNnEcgpLCPYv4WfgYQpvujcqEgyZkX6FgARk8JwLwMgaDEBhKUU9ExHv2WMj2yIwC0Cz13MbGS0Suocd1yUVZ5Wme4hWy8TP1kaw2jSSWt8m/y6Zr2rFYeErvF/xBbIFKnwgjXBTJypWbHcptDp9UsSfjZZEGtq+Is5UM9s749bBGdkuW5C+4w7aUfyKi1MYCyq2AuxBXBnyp8LLqSMeT9OztOMnI9qgcF8m1Azj08moB6nxbPQ3BDB8dneYJHKIQ3TISRNC2aEXEeOV66yb9Xo5eaejN6B+DX87NocdGAE="}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":43345,"cache_read_input_tokens":21023,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":43345},"output_tokens":8,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CY1FCbyCsS6iLoPgtZi5n","type":"assistant","uuid":"de0dfa2a-bab8-4818-a51f-5f7edb758f5d","timestamp":"2026-02-10T23:20:27.642Z"}
{"parentUuid":"de0dfa2a-bab8-4818-a51f-5f7edb758f5d","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","message":{"model":"claude-opus-4-6","id":"msg_01EnEZN4do2x49h42UGYbLo3","type":"message","role":"assistant","content":[{"type":"text","text":"Now I have a clear picture of all files. Let me implement the changes."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":43345,"cache_read_input_tokens":21023,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":43345},"output_tokens":8,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CY1FCbyCsS6iLoPgtZi5n","type":"assistant","uuid":"9add6203-aaba-4a1b-afe8-a3522f7119e8","timestamp":"2026-02-10T23:20:28.239Z"}
{"parentUuid":"9add6203-aaba-4a1b-afe8-a3522f7119e8","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","message":{"model":"claude-opus-4-6","id":"msg_01EnEZN4do2x49h42UGYbLo3","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01TUQ88AsWy71UkDUk4YmA8w","name":"TaskCreate","input":{"subject":"Add SSM/SecretsManager dataclasses and collectors to assembly.py","description":"Add SsmParameter and SmSecret dataclasses, add fields to AppModel, add collector functions, update _process_stack and _build_resource_map","activeForm":"Adding SSM/SecretsManager to assembly parser"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":43345,"cache_read_input_tokens":21023,"output_tokens":200,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":43345,"ephemeral_5m_input_tokens":0},"inference_geo":"","iterations":[]}},"requestId":"req_011CY1FCbyCsS6iLoPgtZi5n","type":"assistant","uuid":"406fb3b4-6571-4334-a5d1-560b23b61990","timestamp":"2026-02-10T23:20:30.751Z"}
{"parentUuid":"406fb3b4-6571-4334-a5d1-560b23b61990","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01TUQ88AsWy71UkDUk4YmA8w","type":"tool_result","content":"Task #1 created successfully: Add SSM/SecretsManager dataclasses and collectors to assembly.py"}]},"uuid":"abed6a4a-5540-42f1-af3d-b164e8d812fe","timestamp":"2026-02-10T23:20:30.761Z","toolUseResult":{"task":{"id":"1","subject":"Add SSM/SecretsManager dataclasses and collectors to assembly.py"}},"sourceToolAssistantUUID":"406fb3b4-6571-4334-a5d1-560b23b61990"}
{"parentUuid":"abed6a4a-5540-42f1-af3d-b164e8d812fe","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","message":{"model":"claude-opus-4-6","id":"msg_013XBYRX58nDRj9M63UEycA5","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01PUNoZZgz1iEDgn4XqV7Evq","name":"TaskCreate","input":{"subject":"Add FQN mappings to tree_parser.py","description":"Add aws-cdk-lib.aws_ssm.StringParameter and aws-cdk-lib.aws_secretsmanager.Secret to FQN_CATEGORY_MAP","activeForm":"Adding FQN mappings"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":236,"cache_read_input_tokens":64368,"output_tokens":142,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":236,"ephemeral_5m_input_tokens":0},"inference_geo":"","iterations":[]}},"requestId":"req_011CY1FD4A44KMWDQtgyVj63","type":"assistant","uuid":"e4959d5e-0e36-44e3-8232-19d0d90f4dab","timestamp":"2026-02-10T23:20:35.048Z"}
{"parentUuid":"e4959d5e-0e36-44e3-8232-19d0d90f4dab","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01PUNoZZgz1iEDgn4XqV7Evq","type":"tool_result","content":"Task #2 created successfully: Add FQN mappings to tree_parser.py"}]},"uuid":"f3e1da79-b18f-41b4-be04-abeb9506ac0e","timestamp":"2026-02-10T23:20:35.053Z","toolUseResult":{"task":{"id":"2","subject":"Add FQN mappings to tree_parser.py"}},"sourceToolAssistantUUID":"e4959d5e-0e36-44e3-8232-19d0d90f4dab"}
{"parentUuid":"f3e1da79-b18f-41b4-be04-abeb9506ac0e","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","message":{"model":"claude-opus-4-6","id":"msg_015zBWShhFq5w85HioQjPhsQ","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_011cMNSV9vLgRHBmYLbZYZ39","name":"TaskCreate","input":{"subject":"Accept initial parameters in SSM routes.py","description":"Modify create_ssm_app() to accept initial_parameters and seed state","activeForm":"Updating SSM app factory"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":173,"cache_read_input_tokens":64604,"output_tokens":116,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":173,"ephemeral_5m_input_tokens":0},"inference_geo":"","iterations":[]}},"requestId":"req_011CY1FDNBWgPTA1tuQyAhQz","type":"assistant","uuid":"248258e8-4521-4a59-9530-42380c666663","timestamp":"2026-02-10T23:20:38.324Z"}
{"parentUuid":"248258e8-4521-4a59-9530-42380c666663","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_011cMNSV9vLgRHBmYLbZYZ39","type":"tool_result","content":"Task #3 created successfully: Accept initial parameters in SSM routes.py"}]},"uuid":"93c39fe9-ed4c-4d3f-9428-35a0eec620c8","timestamp":"2026-02-10T23:20:38.328Z","toolUseResult":{"task":{"id":"3","subject":"Accept initial parameters in SSM routes.py"}},"sourceToolAssistantUUID":"248258e8-4521-4a59-9530-42380c666663"}
{"parentUuid":"93c39fe9-ed4c-4d3f-9428-35a0eec620c8","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","message":{"model":"claude-opus-4-6","id":"msg_014AZvL7MJkdTJZeQxgp4Kzy","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01ADtphB9tdLAvhEXekZnxqC","name":"TaskCreate","input":{"subject":"Accept initial secrets in SecretsManager routes.py","description":"Modify create_secretsmanager_app() to accept initial_secrets and seed state","activeForm":"Updating SecretsManager app factory"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":144,"cache_read_input_tokens":64777,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":144},"output_tokens":24,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CY1FDcD7uBAkZBCSvRxcR","type":"assistant","uuid":"cec49714-f181-4be8-a0ec-dec6c52f842e","timestamp":"2026-02-10T23:20:40.803Z"}
{"parentUuid":"cec49714-f181-4be8-a0ec-dec6c52f842e","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01ADtphB9tdLAvhEXekZnxqC","type":"tool_result","content":"Task #4 created successfully: Accept initial secrets in SecretsManager routes.py"}]},"uuid":"aef24270-dfe9-4606-b3ef-51352086cfc6","timestamp":"2026-02-10T23:20:40.806Z","toolUseResult":{"task":{"id":"4","subject":"Accept initial secrets in SecretsManager routes.py"}},"sourceToolAssistantUUID":"cec49714-f181-4be8-a0ec-dec6c52f842e"}
{"parentUuid":"aef24270-dfe9-4606-b3ef-51352086cfc6","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","message":{"model":"claude-opus-4-6","id":"msg_017DnMSE3VGfEGbzB74UHbxL","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Mjg8J3fqcM98X9iEYjZwP2","name":"TaskCreate","input":{"subject":"Update ldk.py to pass parsed resources and add display details","description":"Pass AppModel SSM/SecretsManager data to providers in CDK mode, add display details for parameters and secrets","activeForm":"Updating ldk.py for SSM/SecretsManager"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":152,"cache_read_input_tokens":64921,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":152},"output_tokens":24,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CY1FDneBRNk2jPMSxWuu2","type":"assistant","uuid":"a9e9c001-5cfe-4528-b370-03cb5ecdcc50","timestamp":"2026-02-10T23:20:45.999Z"}
{"parentUuid":"a9e9c001-5cfe-4528-b370-03cb5ecdcc50","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Mjg8J3fqcM98X9iEYjZwP2","type":"tool_result","content":"Task #5 created successfully: Update ldk.py to pass parsed resources and add display details"}]},"uuid":"372e1a86-1739-4351-8145-4f5a62ca0428","timestamp":"2026-02-10T23:20:46.003Z","toolUseResult":{"task":{"id":"5","subject":"Update ldk.py to pass parsed resources and add display details"}},"sourceToolAssistantUUID":"a9e9c001-5cfe-4528-b370-03cb5ecdcc50"}
{"parentUuid":"372e1a86-1739-4351-8145-4f5a62ca0428","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","message":{"model":"claude-opus-4-6","id":"msg_01N38MtSfnRgNyzaSFvkcxx3","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Er7GwGBy6rk97pzCubGerp","name":"TaskCreate","input":{"subject":"Run tests and lint","description":"Run pytest and ruff to verify changes","activeForm":"Running tests and lint"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":168,"cache_read_input_tokens":65073,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":168},"output_tokens":24,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CY1FEBBVotZ2WNdZsVjeg","type":"assistant","uuid":"f1de8428-7f55-4de2-8ea0-44c61f9dae40","timestamp":"2026-02-10T23:20:48.590Z"}
{"parentUuid":"f1de8428-7f55-4de2-8ea0-44c61f9dae40","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Er7GwGBy6rk97pzCubGerp","type":"tool_result","content":"Task #6 created successfully: Run tests and lint"}]},"uuid":"2d954358-0872-4c6a-9853-a4adf0c31909","timestamp":"2026-02-10T23:20:48.596Z","toolUseResult":{"task":{"id":"6","subject":"Run tests and lint"}},"sourceToolAssistantUUID":"f1de8428-7f55-4de2-8ea0-44c61f9dae40"}
{"parentUuid":"2d954358-0872-4c6a-9853-a4adf0c31909","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","message":{"model":"claude-opus-4-6","id":"msg_013LPDBTZsrWE9KpQW1v3QHU","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_014FK4VrnNMmDFrXGwRHNvKg","name":"TaskUpdate","input":{"taskId":"1","status":"in_progress"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":123,"cache_read_input_tokens":65241,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":123},"output_tokens":26,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CY1FEN3c8iAk4ywgxCA23","type":"assistant","uuid":"35a72191-a300-4bba-baef-2072f5eb8f5e","timestamp":"2026-02-10T23:20:50.884Z"}
{"parentUuid":"35a72191-a300-4bba-baef-2072f5eb8f5e","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_014FK4VrnNMmDFrXGwRHNvKg","type":"tool_result","content":"Updated task #1 status"}]},"uuid":"beacbb72-55fe-4de8-ad71-e55125970983","timestamp":"2026-02-10T23:20:50.889Z","toolUseResult":{"success":true,"taskId":"1","updatedFields":["status"],"statusChange":{"from":"pending","to":"in_progress"}},"sourceToolAssistantUUID":"35a72191-a300-4bba-baef-2072f5eb8f5e"}
{"parentUuid":"beacbb72-55fe-4de8-ad71-e55125970983","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","message":{"model":"claude-opus-4-6","id":"msg_013UXt9j1FrtDouDXxasbFLb","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me implement all the changes. Starting with assembly.py — adding dataclasses, AppModel fields, collectors, and resource map entries:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":90,"cache_read_input_tokens":65364,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":90},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CY1FEXvRmpDyhwbuaVMfG","type":"assistant","uuid":"ec0701f3-9f9e-496f-b43f-f5ac91a1701a","timestamp":"2026-02-10T23:20:53.716Z"}
{"type":"file-history-snapshot","messageId":"00ab08a5-ad2d-4361-be6d-269fb5b9ff36","snapshot":{"messageId":"419d76bc-01da-47ab-8292-f6cf09dd2274","trackedFileBackups":{"src/lws/parser/assembly.py":{"backupFileName":"00df020cf1c04e6c@v1","version":1,"backupTime":"2026-02-10T23:21:01.336Z"}},"timestamp":"2026-02-10T23:20:18.621Z"},"isSnapshotUpdate":true}
{"parentUuid":"ec0701f3-9f9e-496f-b43f-f5ac91a1701a","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","message":{"model":"claude-opus-4-6","id":"msg_013UXt9j1FrtDouDXxasbFLb","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01EY38A83Ve1Z5UMSD1HBZqF","name":"Edit","input":{"replace_all":false,"file_path":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services/src/lws/parser/assembly.py","old_string":"@dataclass\nclass AppModel:\n    \"\"\"Complete parsed representation of a CDK application.\"\"\"\n\n    functions: list[LambdaFunction] = field(default_factory=list)\n    tables: list[DynamoTable] = field(default_factory=list)\n    apis: list[ApiDefinition] = field(default_factory=list)\n    queues: list[SqsQueue] = field(default_factory=list)\n    buckets: list[S3Bucket] = field(default_factory=list)\n    topics: list[SnsTopic] = field(default_factory=list)\n    event_buses: list[EventBus] = field(default_factory=list)\n    event_rules: list[EventRule] = field(default_factory=list)\n    state_machines: list[StateMachine] = field(default_factory=list)\n    user_pools: list[CognitoUserPool] = field(default_factory=list)\n    ecs_services: list[Any] = field(default_factory=list)","new_string":"@dataclass\nclass SsmParameter:\n    \"\"\"Parsed SSM Parameter Store parameter.\"\"\"\n\n    name: str\n    type: str  # \"String\", \"StringList\", \"SecureString\"\n    value: str\n    description: str = \"\"\n\n\n@dataclass\nclass SmSecret:\n    \"\"\"Parsed Secrets Manager secret.\"\"\"\n\n    name: str\n    description: str = \"\"\n    secret_string: str | None = None\n\n\n@dataclass\nclass AppModel:\n    \"\"\"Complete parsed representation of a CDK application.\"\"\"\n\n    functions: list[LambdaFunction] = field(default_factory=list)\n    tables: list[DynamoTable] = field(default_factory=list)\n    apis: list[ApiDefinition] = field(default_factory=list)\n    queues: list[SqsQueue] = field(default_factory=list)\n    buckets: list[S3Bucket] = field(default_factory=list)\n    topics: list[SnsTopic] = field(default_factory=list)\n    event_buses: list[EventBus] = field(default_factory=list)\n    event_rules: list[EventRule] = field(default_factory=list)\n    state_machines: list[StateMachine] = field(default_factory=list)\n    user_pools: list[CognitoUserPool] = field(default_factory=list)\n    ecs_services: list[Any] = field(default_factory=list)\n    ssm_parameters: list[SsmParameter] = field(default_factory=list)\n    secrets: list[SmSecret] = field(default_factory=list)"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":90,"cache_read_input_tokens":65364,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":90},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CY1FEXvRmpDyhwbuaVMfG","type":"assistant","uuid":"00ab08a5-ad2d-4361-be6d-269fb5b9ff36","timestamp":"2026-02-10T23:21:01.317Z"}
{"parentUuid":"00ab08a5-ad2d-4361-be6d-269fb5b9ff36","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"callback"},"parentToolUseID":"toolu_01EY38A83Ve1Z5UMSD1HBZqF","toolUseID":"toolu_01EY38A83Ve1Z5UMSD1HBZqF","timestamp":"2026-02-10T23:21:01.340Z","uuid":"67c2cdbf-b50a-4e49-9641-9fd9d1724a81"}
{"parentUuid":"00ab08a5-ad2d-4361-be6d-269fb5b9ff36","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01EY38A83Ve1Z5UMSD1HBZqF","type":"tool_result","content":"The file /Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services/src/lws/parser/assembly.py has been updated successfully."}]},"uuid":"ec2a923b-bf84-4d52-a37f-5fbc44d757ea","timestamp":"2026-02-10T23:21:01.339Z","toolUseResult":{"filePath":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services/src/lws/parser/assembly.py","oldString":"@dataclass\nclass AppModel:\n    \"\"\"Complete parsed representation of a CDK application.\"\"\"\n\n    functions: list[LambdaFunction] = field(default_factory=list)\n    tables: list[DynamoTable] = field(default_factory=list)\n    apis: list[ApiDefinition] = field(default_factory=list)\n    queues: list[SqsQueue] = field(default_factory=list)\n    buckets: list[S3Bucket] = field(default_factory=list)\n    topics: list[SnsTopic] = field(default_factory=list)\n    event_buses: list[EventBus] = field(default_factory=list)\n    event_rules: list[EventRule] = field(default_factory=list)\n    state_machines: list[StateMachine] = field(default_factory=list)\n    user_pools: list[CognitoUserPool] = field(default_factory=list)\n    ecs_services: list[Any] = field(default_factory=list)","newString":"@dataclass\nclass SsmParameter:\n    \"\"\"Parsed SSM Parameter Store parameter.\"\"\"\n\n    name: str\n    type: str  # \"String\", \"StringList\", \"SecureString\"\n    value: str\n    description: str = \"\"\n\n\n@dataclass\nclass SmSecret:\n    \"\"\"Parsed Secrets Manager secret.\"\"\"\n\n    name: str\n    description: str = \"\"\n    secret_string: str | None = None\n\n\n@dataclass\nclass AppModel:\n    \"\"\"Complete parsed representation of a CDK application.\"\"\"\n\n    functions: list[LambdaFunction] = field(default_factory=list)\n    tables: list[DynamoTable] = field(default_factory=list)\n    apis: list[ApiDefinition] = field(default_factory=list)\n    queues: list[SqsQueue] = field(default_factory=list)\n    buckets: list[S3Bucket] = field(default_factory=list)\n    topics: list[SnsTopic] = field(default_factory=list)\n    event_buses: list[EventBus] = field(default_factory=list)\n    event_rules: list[EventRule] = field(default_factory=list)\n    state_machines: list[StateMachine] = field(default_factory=list)\n    user_pools: list[CognitoUserPool] = field(default_factory=list)\n    ecs_services: list[Any] = field(default_factory=list)\n    ssm_parameters: list[SsmParameter] = field(default_factory=list)\n    secrets: list[SmSecret] = field(default_factory=list)","originalFile":"\"\"\"Assembly orchestrator -- top-level entry point for CDK output parsing.\n\nTies together tree parsing, template parsing, reference resolution and\nasset location to produce a single ``AppModel`` that the rest of the\nsystem can consume.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport json\nimport logging\nfrom dataclasses import dataclass, field\nfrom pathlib import Path\nfrom typing import Any\n\nfrom lws.parser.asset_parser import parse_assets\nfrom lws.parser.ref_resolver import RefResolver\nfrom lws.parser.template_parser import (\n    CfnResource,\n    extract_api_routes,\n    extract_dynamo_tables,\n    extract_lambda_functions,\n    parse_template,\n)\nfrom lws.parser.tree_parser import parse_tree\n\nlogger = logging.getLogger(__name__)\n\n# ---------------------------------------------------------------------------\n# Domain model dataclasses\n# ---------------------------------------------------------------------------\n\n\n@dataclass\nclass LambdaFunction:\n    \"\"\"Parsed Lambda function ready for local execution.\"\"\"\n\n    name: str\n    handler: str\n    runtime: str\n    code_path: Path | None = None\n    timeout: int = 30\n    memory: int = 128\n    environment: dict[str, str] = field(default_factory=dict)\n\n    @property\n    def logical_id(self) -> str:\n        return self.name\n\n\n@dataclass\nclass DynamoTable:\n    \"\"\"Parsed DynamoDB table definition.\"\"\"\n\n    name: str\n    key_schema: list[dict[str, str]] = field(default_factory=list)\n    gsi_definitions: list[dict[str, Any]] = field(default_factory=list)\n\n    @property\n    def logical_id(self) -> str:\n        return self.name\n\n    @property\n    def table_name(self) -> str:\n        return self.name\n\n\n@dataclass\nclass ApiRoute:\n    \"\"\"A single API Gateway route.\"\"\"\n\n    method: str\n    path: str\n    handler_name: str | None = None\n\n\n@dataclass\nclass ApiDefinition:\n    \"\"\"A collection of routes making up an API.\"\"\"\n\n    name: str = \"default\"\n    routes: list[ApiRoute] = field(default_factory=list)\n\n    @property\n    def logical_id(self) -> str:\n        return self.name\n\n\n@dataclass\nclass SqsQueue:\n    \"\"\"Parsed SQS queue definition.\"\"\"\n\n    name: str\n    is_fifo: bool = False\n    visibility_timeout: int = 30\n    content_based_dedup: bool = False\n    redrive_target: str | None = None\n    max_receive_count: int = 5\n\n\n@dataclass\nclass S3Bucket:\n    \"\"\"Parsed S3 bucket definition.\"\"\"\n\n    name: str\n\n\n@dataclass\nclass SnsTopic:\n    \"\"\"Parsed SNS topic definition.\"\"\"\n\n    name: str\n    topic_arn: str = \"\"\n\n\n@dataclass\nclass EventBus:\n    \"\"\"Parsed EventBridge event bus definition.\"\"\"\n\n    name: str\n    bus_arn: str = \"\"\n\n\n@dataclass\nclass EventRule:\n    \"\"\"Parsed EventBridge rule definition.\"\"\"\n\n    rule_name: str\n    event_bus_name: str = \"default\"\n    event_pattern: dict[str, Any] | None = None\n    schedule_expression: str | None = None\n    targets: list[dict[str, Any]] = field(default_factory=list)\n\n\n@dataclass\nclass StateMachine:\n    \"\"\"Parsed Step Functions state machine definition.\"\"\"\n\n    name: str\n    definition: str | dict[str, Any] = \"\"\n    workflow_type: str = \"STANDARD\"\n    role_arn: str = \"\"\n    definition_substitutions: dict[str, str] = field(default_factory=dict)\n\n\n@dataclass\nclass CognitoUserPool:\n    \"\"\"Parsed Cognito user pool definition.\"\"\"\n\n    logical_id: str\n    user_pool_name: str = \"default\"\n    auto_confirm: bool = True\n    password_policy: dict[str, Any] = field(default_factory=dict)\n    pre_auth_trigger: str | None = None\n    post_confirm_trigger: str | None = None\n    client_id: str = \"\"\n\n\n@dataclass\nclass AppModel:\n    \"\"\"Complete parsed representation of a CDK application.\"\"\"\n\n    functions: list[LambdaFunction] = field(default_factory=list)\n    tables: list[DynamoTable] = field(default_factory=list)\n    apis: list[ApiDefinition] = field(default_factory=list)\n    queues: list[SqsQueue] = field(default_factory=list)\n    buckets: list[S3Bucket] = field(default_factory=list)\n    topics: list[SnsTopic] = field(default_factory=list)\n    event_buses: list[EventBus] = field(default_factory=list)\n    event_rules: list[EventRule] = field(default_factory=list)\n    state_machines: list[StateMachine] = field(default_factory=list)\n    user_pools: list[CognitoUserPool] = field(default_factory=list)\n    ecs_services: list[Any] = field(default_factory=list)\n\n\n# ---------------------------------------------------------------------------\n# Orchestrator\n# ---------------------------------------------------------------------------\n\n\ndef parse_assembly(cdk_out_path: Path) -> AppModel:\n    \"\"\"Parse an entire CDK ``cdk.out`` directory into an :class:`AppModel`.\n\n    Parameters\n    ----------\n    cdk_out_path:\n        Path to the ``cdk.out`` directory produced by ``cdk synth``.\n\n    Returns\n    -------\n    AppModel\n    \"\"\"\n    manifest_path = cdk_out_path / \"manifest.json\"\n    if not manifest_path.exists():\n        logger.warning(\"No manifest.json found in %s\", cdk_out_path)\n        return AppModel()\n\n    with open(manifest_path, encoding=\"utf-8\") as fh:\n        manifest = json.load(fh)\n\n    # Parse assets (hash -> filesystem path)\n    asset_map = parse_assets(cdk_out_path)\n\n    # Parse tree.json if present\n    tree_path = cdk_out_path / \"tree.json\"\n    if tree_path.exists():\n        parse_tree(tree_path)  # Currently used for validation; future enrichment\n\n    # Collect all stack artifacts\n    model = AppModel()\n    for artifact_id, artifact in (manifest.get(\"artifacts\") or {}).items():\n        if artifact.get(\"type\") != \"aws:cloudformation:stack\":\n            continue\n        _process_stack(cdk_out_path, artifact_id, artifact, asset_map, model)\n\n    return model\n\n\ndef _process_stack(\n    cdk_out_path: Path,\n    artifact_id: str,\n    artifact: dict,\n    asset_map: dict[str, Path],\n    model: AppModel,\n) -> None:\n    \"\"\"Process a single CloudFormation stack artifact.\"\"\"\n    template_file = artifact.get(\"properties\", {}).get(\"templateFile\")\n    if not template_file:\n        logger.warning(\"Stack %s has no templateFile\", artifact_id)\n        return\n\n    template_path = cdk_out_path / template_file\n    if not template_path.exists():\n        logger.warning(\"Template not found: %s\", template_path)\n        return\n\n    resources = parse_template(template_path)\n    resource_type_map = {r.logical_id: r.resource_type for r in resources}\n    resource_map = _build_resource_map(resources)\n    resolver = RefResolver(resource_map=resource_map, resource_types=resource_type_map)\n\n    model.functions.extend(_collect_lambdas(resources, asset_map, cdk_out_path, resolver))\n    model.tables.extend(_collect_tables(resources, resolver))\n    api_def = _collect_api_routes(resources, resolver, artifact_id)\n    if api_def:\n        model.apis.append(api_def)\n    model.queues.extend(_collect_queues(resources, resolver))\n    model.buckets.extend(_collect_buckets(resources))\n    model.topics.extend(_collect_topics(resources, resolver))\n    model.event_buses.extend(_collect_event_buses(resources, resolver))\n    model.event_rules.extend(_collect_event_rules(resources, resolver))\n    model.state_machines.extend(_collect_state_machines(resources, resolver))\n    model.user_pools.extend(_collect_user_pools(resources, resolver))\n\n    # ECS needs the raw template dict\n    with open(template_path, encoding=\"utf-8\") as fh:\n        raw_template = json.load(fh)\n    ecs_services = _collect_ecs_services(raw_template)\n    model.ecs_services.extend(ecs_services)\n\n\ndef _build_resource_map(resources: list[CfnResource]) -> dict[str, str]:\n    \"\"\"Build a Ref resource_map so intrinsic ``Ref`` calls resolve to useful local values.\n\n    In real CloudFormation:\n    - ``Ref`` on an ``AWS::SQS::Queue`` returns the queue URL.\n    - ``Ref`` on an ``AWS::DynamoDB::Table`` returns the table name.\n\n    We reproduce this behaviour with deterministic local placeholders so that\n    Lambda environment variables like ``QUEUE_URL`` and ``TABLE_NAME`` resolve\n    to values the local providers can understand.\n    \"\"\"\n    resource_map: dict[str, str] = {}\n    for r in resources:\n        if r.resource_type == \"AWS::SQS::Queue\":\n            queue_name = r.properties.get(\"QueueName\", r.logical_id)\n            if isinstance(queue_name, str):\n                # Use ARN format so the SDK connects via AWS_ENDPOINT_URL_SQS\n                # rather than trying to resolve the QueueUrl as a hostname.\n                resource_map[r.logical_id] = f\"arn:ldk:sqs:local:000000000000:queue/{queue_name}\"\n        elif r.resource_type == \"AWS::DynamoDB::Table\":\n            # Ref returns the table name.\n            table_name = r.properties.get(\"TableName\", r.logical_id)\n            if isinstance(table_name, str):\n                resource_map[r.logical_id] = table_name\n        elif r.resource_type == \"AWS::S3::Bucket\":\n            # Ref returns the bucket name.\n            bucket_name = r.properties.get(\"BucketName\", r.logical_id)\n            if isinstance(bucket_name, str):\n                resource_map[r.logical_id] = bucket_name\n            else:\n                resource_map[r.logical_id] = r.logical_id\n        elif r.resource_type == \"AWS::SNS::Topic\":\n            # Ref returns the topic ARN.\n            topic_name = r.properties.get(\"TopicName\", r.logical_id)\n            if isinstance(topic_name, str):\n                resource_map[r.logical_id] = f\"arn:ldk:sns:local:000000000000:{topic_name}\"\n    return resource_map\n\n\ndef _collect_lambdas(\n    resources: list[CfnResource],\n    asset_map: dict[str, Path],\n    cdk_out_path: Path,\n    resolver: RefResolver,\n) -> list[LambdaFunction]:\n    \"\"\"Extract Lambda functions from parsed CloudFormation resources.\"\"\"\n    functions: list[LambdaFunction] = []\n    lambda_props_list = extract_lambda_functions(resources)\n    lambda_resources = [r for r in resources if r.resource_type == \"AWS::Lambda::Function\"]\n    for r, props in zip(lambda_resources, lambda_props_list):\n        code_path = _resolve_code_path(props.code_uri, asset_map, cdk_out_path, resolver)\n        env = {k: str(resolver.resolve(v)) for k, v in props.environment.items()}\n        functions.append(\n            LambdaFunction(\n                name=r.logical_id,\n                handler=props.handler or \"index.handler\",\n                runtime=props.runtime or \"python3.11\",\n                code_path=code_path,\n                timeout=props.timeout or 30,\n                memory=props.memory_size or 128,\n                environment=env,\n            )\n        )\n    return functions\n\n\ndef _collect_tables(\n    resources: list[CfnResource],\n    resolver: RefResolver,\n) -> list[DynamoTable]:\n    \"\"\"Extract DynamoDB tables from parsed CloudFormation resources.\"\"\"\n    tables: list[DynamoTable] = []\n    dynamo_props_list = extract_dynamo_tables(resources)\n    dynamo_resources = [r for r in resources if r.resource_type == \"AWS::DynamoDB::Table\"]\n    for r, props in zip(dynamo_resources, dynamo_props_list):\n        name = props.table_name or r.logical_id\n        if isinstance(name, dict):\n            name = str(resolver.resolve(name))\n        tables.append(\n            DynamoTable(\n                name=name,\n                key_schema=props.key_schema,\n                gsi_definitions=props.gsi_definitions,\n            )\n        )\n    return tables\n\n\ndef _collect_api_routes(\n    resources: list[CfnResource],\n    resolver: RefResolver,\n    artifact_id: str,\n) -> ApiDefinition | None:\n    \"\"\"Extract API Gateway routes from parsed CloudFormation resources.\"\"\"\n    api_routes = extract_api_routes(resources)\n    if not api_routes:\n        return None\n    routes: list[ApiRoute] = []\n    for route_props in api_routes:\n        handler_name = _find_handler_for_integration(\n            route_props.integration_uri, resources, resolver\n        )\n        routes.append(\n            ApiRoute(\n                method=route_props.http_method or \"ANY\",\n                path=route_props.resource_path or \"/\",\n                handler_name=handler_name,\n            )\n        )\n    return ApiDefinition(name=artifact_id, routes=routes)\n\n\ndef _resolve_code_from_s3_key(s3_key: str, asset_map: dict[str, Path]) -> Path | None:\n    \"\"\"Try to match an S3Key to an asset by hash.\"\"\"\n    asset_hash = s3_key.replace(\".zip\", \"\")\n    if asset_hash in asset_map:\n        return asset_map[asset_hash]\n    for hash_key, path in asset_map.items():\n        if hash_key in s3_key:\n            return path\n    return None\n\n\ndef _resolve_code_from_s3_bucket(\n    s3_bucket: dict, resolver: RefResolver, asset_map: dict[str, Path]\n) -> Path | None:\n    \"\"\"Try to match an S3Bucket ref to an asset.\"\"\"\n    resolved = str(resolver.resolve(s3_bucket))\n    for h, p in asset_map.items():\n        if h in resolved:\n            return p\n    return None\n\n\ndef _resolve_code_path(\n    code_uri: Any,\n    asset_map: dict[str, Path],\n    cdk_out_path: Path,\n    resolver: RefResolver,\n) -> Path | None:\n    \"\"\"Resolve a Lambda Code property to a local filesystem path.\"\"\"\n    if code_uri is None:\n        return None\n\n    if isinstance(code_uri, dict):\n        s3_key = code_uri.get(\"S3Key\")\n        if isinstance(s3_key, str):\n            result = _resolve_code_from_s3_key(s3_key, asset_map)\n            if result:\n                return result\n\n        s3_bucket = code_uri.get(\"S3Bucket\")\n        if isinstance(s3_bucket, dict):\n            result = _resolve_code_from_s3_bucket(s3_bucket, resolver, asset_map)\n            if result:\n                return result\n\n    if isinstance(code_uri, str):\n        candidate = cdk_out_path / code_uri\n        if candidate.exists():\n            return candidate\n\n    return None\n\n\ndef _find_handler_for_integration(\n    integration_uri: Any,\n    resources: list[CfnResource],\n    resolver: RefResolver,\n) -> str | None:\n    \"\"\"Try to match an API integration URI back to a Lambda logical ID.\"\"\"\n    if integration_uri is None:\n        return None\n\n    resolved = str(resolver.resolve(integration_uri))\n\n    # Look for a Lambda function logical ID in the resolved string\n    for r in resources:\n        if r.resource_type == \"AWS::Lambda::Function\":\n            if r.logical_id in resolved:\n                return r.logical_id\n\n    return None\n\n\n# ---------------------------------------------------------------------------\n# Collectors for new resource types\n# ---------------------------------------------------------------------------\n\n\ndef _collect_queues(\n    resources: list[CfnResource],\n    resolver: RefResolver,\n) -> list[SqsQueue]:\n    \"\"\"Extract SQS queues from parsed CloudFormation resources.\"\"\"\n    queues: list[SqsQueue] = []\n    for r in resources:\n        if r.resource_type != \"AWS::SQS::Queue\":\n            continue\n        props = r.properties\n        name = props.get(\"QueueName\", r.logical_id)\n        if isinstance(name, dict):\n            name = str(resolver.resolve(name))\n        is_fifo = bool(props.get(\"FifoQueue\", False))\n        vis = int(props.get(\"VisibilityTimeout\", 30))\n        dedup = bool(props.get(\"ContentBasedDeduplication\", False))\n        redrive = props.get(\"RedrivePolicy\")\n        redrive_target = None\n        max_receive = 5\n        if isinstance(redrive, dict):\n            dlq = redrive.get(\"deadLetterTargetArn\", \"\")\n            if isinstance(dlq, dict):\n                dlq = str(resolver.resolve(dlq))\n            redrive_target = str(dlq) if dlq else None\n            max_receive = int(redrive.get(\"maxReceiveCount\", 5))\n        queues.append(\n            SqsQueue(\n                name=name,\n                is_fifo=is_fifo,\n                visibility_timeout=vis,\n                content_based_dedup=dedup,\n                redrive_target=redrive_target,\n                max_receive_count=max_receive,\n            )\n        )\n    return queues\n\n\ndef _collect_buckets(resources: list[CfnResource]) -> list[S3Bucket]:\n    \"\"\"Extract S3 buckets from parsed CloudFormation resources.\"\"\"\n    buckets: list[S3Bucket] = []\n    for r in resources:\n        if r.resource_type != \"AWS::S3::Bucket\":\n            continue\n        name = r.properties.get(\"BucketName\", r.logical_id)\n        if isinstance(name, dict):\n            name = r.logical_id  # Can't resolve intrinsics for bucket names easily\n        buckets.append(S3Bucket(name=name))\n    return buckets\n\n\ndef _collect_topics(\n    resources: list[CfnResource],\n    resolver: RefResolver,\n) -> list[SnsTopic]:\n    \"\"\"Extract SNS topics from parsed CloudFormation resources.\"\"\"\n    topics: list[SnsTopic] = []\n    for r in resources:\n        if r.resource_type != \"AWS::SNS::Topic\":\n            continue\n        props = r.properties\n        name = props.get(\"TopicName\", r.logical_id)\n        if isinstance(name, dict):\n            name = str(resolver.resolve(name))\n        arn = f\"arn:aws:sns:us-east-1:000000000000:{name}\"\n        topics.append(SnsTopic(name=name, topic_arn=arn))\n    return topics\n\n\ndef _collect_event_buses(\n    resources: list[CfnResource],\n    resolver: RefResolver,\n) -> list[EventBus]:\n    \"\"\"Extract EventBridge event buses from parsed CloudFormation resources.\"\"\"\n    buses: list[EventBus] = []\n    for r in resources:\n        if r.resource_type != \"AWS::Events::EventBus\":\n            continue\n        props = r.properties\n        name = props.get(\"Name\", r.logical_id)\n        if isinstance(name, dict):\n            name = str(resolver.resolve(name))\n        arn = f\"arn:aws:events:us-east-1:000000000000:event-bus/{name}\"\n        buses.append(EventBus(name=name, bus_arn=arn))\n    return buses\n\n\ndef _collect_event_rules(\n    resources: list[CfnResource],\n    resolver: RefResolver,\n) -> list[EventRule]:\n    \"\"\"Extract EventBridge rules from parsed CloudFormation resources.\"\"\"\n    rules: list[EventRule] = []\n    for r in resources:\n        if r.resource_type != \"AWS::Events::Rule\":\n            continue\n        props = r.properties\n        rule_name = props.get(\"Name\", r.logical_id)\n        if isinstance(rule_name, dict):\n            rule_name = str(resolver.resolve(rule_name))\n        bus_name = props.get(\"EventBusName\", \"default\")\n        if isinstance(bus_name, dict):\n            bus_name = str(resolver.resolve(bus_name))\n        pattern = props.get(\"EventPattern\")\n        schedule = props.get(\"ScheduleExpression\")\n        raw_targets = props.get(\"Targets\", [])\n        targets: list[dict[str, Any]] = []\n        for t in raw_targets:\n            target_arn = t.get(\"Arn\", \"\")\n            if isinstance(target_arn, dict):\n                target_arn = str(resolver.resolve(target_arn))\n            targets.append(\n                {\n                    \"target_id\": t.get(\"Id\", \"\"),\n                    \"arn\": target_arn,\n                    \"input_path\": t.get(\"InputPath\"),\n                    \"input_template\": t.get(\"InputTransformer\", {}).get(\"InputTemplate\"),\n                }\n            )\n        rules.append(\n            EventRule(\n                rule_name=rule_name,\n                event_bus_name=bus_name,\n                event_pattern=pattern,\n                schedule_expression=schedule,\n                targets=targets,\n            )\n        )\n    return rules\n\n\ndef _resolve_sm_definition(definition: Any, resolver: RefResolver) -> Any:\n    \"\"\"Resolve a Step Functions DefinitionString that may use intrinsic functions.\"\"\"\n    if isinstance(definition, dict):\n        return resolver.resolve(definition)\n    return definition\n\n\ndef _resolve_substitutions(subs: dict[str, Any], resolver: RefResolver) -> dict[str, str]:\n    \"\"\"Resolve CloudFormation DefinitionSubstitutions to plain strings.\"\"\"\n    return {k: str(resolver.resolve(v)) if isinstance(v, dict) else str(v) for k, v in subs.items()}\n\n\ndef _collect_state_machines(\n    resources: list[CfnResource],\n    resolver: RefResolver,\n) -> list[StateMachine]:\n    \"\"\"Extract Step Functions state machines from parsed CloudFormation resources.\"\"\"\n    machines: list[StateMachine] = []\n    for r in resources:\n        if r.resource_type != \"AWS::StepFunctions::StateMachine\":\n            continue\n        props = r.properties\n        name = props.get(\"StateMachineName\", r.logical_id)\n        if isinstance(name, dict):\n            name = str(resolver.resolve(name))\n        definition = props.get(\"DefinitionString\", props.get(\"Definition\", \"\"))\n        definition = _resolve_sm_definition(definition, resolver)\n        role_arn = props.get(\"RoleArn\", \"\")\n        if isinstance(role_arn, dict):\n            role_arn = str(resolver.resolve(role_arn))\n        resolved_subs = _resolve_substitutions(props.get(\"DefinitionSubstitutions\", {}), resolver)\n        machines.append(\n            StateMachine(\n                name=name,\n                definition=definition,\n                workflow_type=props.get(\"StateMachineType\", \"STANDARD\"),\n                role_arn=role_arn,\n                definition_substitutions=resolved_subs,\n            )\n        )\n    return machines\n\n\ndef _collect_user_pools(\n    resources: list[CfnResource],\n    resolver: RefResolver,\n) -> list[CognitoUserPool]:\n    \"\"\"Extract Cognito user pools from parsed CloudFormation resources.\"\"\"\n    pools: list[CognitoUserPool] = []\n    # First pass: collect user pool clients to map pool -> client_id\n    client_map: dict[str, str] = {}\n    for r in resources:\n        if r.resource_type != \"AWS::Cognito::UserPoolClient\":\n            continue\n        pool_ref = r.properties.get(\"UserPoolId\", \"\")\n        if isinstance(pool_ref, dict):\n            pool_ref = str(resolver.resolve(pool_ref))\n        client_map[pool_ref] = r.logical_id\n\n    for r in resources:\n        if r.resource_type != \"AWS::Cognito::UserPool\":\n            continue\n        props = r.properties\n        name = props.get(\"UserPoolName\", r.logical_id)\n        if isinstance(name, dict):\n            name = str(resolver.resolve(name))\n        auto_confirm = True\n        lambda_config = props.get(\"LambdaConfig\", {})\n        pre_auth = lambda_config.get(\"PreAuthentication\")\n        if isinstance(pre_auth, dict):\n            pre_auth = str(resolver.resolve(pre_auth))\n        post_confirm = lambda_config.get(\"PostConfirmation\")\n        if isinstance(post_confirm, dict):\n            post_confirm = str(resolver.resolve(post_confirm))\n        pw_policy = props.get(\"Policies\", {}).get(\"PasswordPolicy\", {})\n        client_id = client_map.get(r.logical_id, \"\")\n        pools.append(\n            CognitoUserPool(\n                logical_id=r.logical_id,\n                user_pool_name=name,\n                auto_confirm=auto_confirm,\n                password_policy=pw_policy,\n                pre_auth_trigger=pre_auth,\n                post_confirm_trigger=post_confirm,\n                client_id=client_id,\n            )\n        )\n    return pools\n\n\ndef _collect_ecs_services(template: dict) -> list:\n    \"\"\"Extract ECS services from the raw CloudFormation template.\"\"\"\n    try:\n        from lws.providers.ecs.provider import parse_ecs_resources\n\n        return parse_ecs_resources(template)\n    except Exception:\n        logger.debug(\"Could not parse ECS resources\", exc_info=True)\n        return []\n","structuredPatch":[{"oldStart":157,"oldLines":6,"newStart":157,"newLines":25,"lines":[" "," "," @dataclass","+class SsmParameter:","+    \"\"\"Parsed SSM Parameter Store parameter.\"\"\"","+","+    name: str","+    type: str  # \"String\", \"StringList\", \"SecureString\"","+    value: str","+    description: str = \"\"","+","+","+@dataclass","+class SmSecret:","+    \"\"\"Parsed Secrets Manager secret.\"\"\"","+","+    name: str","+    description: str = \"\"","+    secret_string: str | None = None","+","+","+@dataclass"," class AppModel:","     \"\"\"Complete parsed representation of a CDK application.\"\"\""," "]},{"oldStart":171,"oldLines":6,"newStart":190,"newLines":8,"lines":["     state_machines: list[StateMachine] = field(default_factory=list)","     user_pools: list[CognitoUserPool] = field(default_factory=list)","     ecs_services: list[Any] = field(default_factory=list)","+    ssm_parameters: list[SsmParameter] = field(default_factory=list)","+    secrets: list[SmSecret] = field(default_factory=list)"," "," "," # ---------------------------------------------------------------------------"]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"00ab08a5-ad2d-4361-be6d-269fb5b9ff36"}
{"parentUuid":"ec2a923b-bf84-4d52-a37f-5fbc44d757ea","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","message":{"model":"claude-opus-4-6","id":"msg_01459vTrod1bWsoMiQ4gSmYG","type":"message","role":"assistant","content":[{"type":"text","text":"Now add SSM and SecretsManager to `_build_resource_map`:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":863,"cache_read_input_tokens":65454,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":863},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CY1FFJpfHXe37kdg63Ewf","type":"assistant","uuid":"e16bee8c-101a-45dc-9f33-be96c68d5c90","timestamp":"2026-02-10T23:21:05.011Z"}
{"parentUuid":"e16bee8c-101a-45dc-9f33-be96c68d5c90","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","message":{"model":"claude-opus-4-6","id":"msg_01459vTrod1bWsoMiQ4gSmYG","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01XwCBZSmtKaLaUMLBH4vyes","name":"Edit","input":{"replace_all":false,"file_path":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services/src/lws/parser/assembly.py","old_string":"        elif r.resource_type == \"AWS::SNS::Topic\":\n            # Ref returns the topic ARN.\n            topic_name = r.properties.get(\"TopicName\", r.logical_id)\n            if isinstance(topic_name, str):\n                resource_map[r.logical_id] = f\"arn:ldk:sns:local:000000000000:{topic_name}\"\n    return resource_map","new_string":"        elif r.resource_type == \"AWS::SNS::Topic\":\n            # Ref returns the topic ARN.\n            topic_name = r.properties.get(\"TopicName\", r.logical_id)\n            if isinstance(topic_name, str):\n                resource_map[r.logical_id] = f\"arn:ldk:sns:local:000000000000:{topic_name}\"\n        elif r.resource_type == \"AWS::SSM::Parameter\":\n            name = r.properties.get(\"Name\", r.logical_id)\n            if isinstance(name, str):\n                resource_map[r.logical_id] = name\n        elif r.resource_type == \"AWS::SecretsManager::Secret\":\n            name = r.properties.get(\"Name\", r.logical_id)\n            if isinstance(name, str):\n                resource_map[r.logical_id] = (\n                    f\"arn:aws:secretsmanager:us-east-1:000000000000:secret:{name}\"\n                )\n    return resource_map"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":863,"cache_read_input_tokens":65454,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":863},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CY1FFJpfHXe37kdg63Ewf","type":"assistant","uuid":"285e7607-91dd-42de-88b7-c9219ffef8ef","timestamp":"2026-02-10T23:21:09.518Z"}
{"parentUuid":"285e7607-91dd-42de-88b7-c9219ffef8ef","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"callback"},"parentToolUseID":"toolu_01XwCBZSmtKaLaUMLBH4vyes","toolUseID":"toolu_01XwCBZSmtKaLaUMLBH4vyes","timestamp":"2026-02-10T23:21:09.525Z","uuid":"da2a57a7-83aa-48a1-9517-96f0ec80172e"}
{"parentUuid":"285e7607-91dd-42de-88b7-c9219ffef8ef","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01XwCBZSmtKaLaUMLBH4vyes","type":"tool_result","content":"The file /Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services/src/lws/parser/assembly.py has been updated successfully."}]},"uuid":"ef7e445c-8d12-4167-9d04-ffdbf9221d50","timestamp":"2026-02-10T23:21:09.524Z","toolUseResult":{"filePath":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services/src/lws/parser/assembly.py","oldString":"        elif r.resource_type == \"AWS::SNS::Topic\":\n            # Ref returns the topic ARN.\n            topic_name = r.properties.get(\"TopicName\", r.logical_id)\n            if isinstance(topic_name, str):\n                resource_map[r.logical_id] = f\"arn:ldk:sns:local:000000000000:{topic_name}\"\n    return resource_map","newString":"        elif r.resource_type == \"AWS::SNS::Topic\":\n            # Ref returns the topic ARN.\n            topic_name = r.properties.get(\"TopicName\", r.logical_id)\n            if isinstance(topic_name, str):\n                resource_map[r.logical_id] = f\"arn:ldk:sns:local:000000000000:{topic_name}\"\n        elif r.resource_type == \"AWS::SSM::Parameter\":\n            name = r.properties.get(\"Name\", r.logical_id)\n            if isinstance(name, str):\n                resource_map[r.logical_id] = name\n        elif r.resource_type == \"AWS::SecretsManager::Secret\":\n            name = r.properties.get(\"Name\", r.logical_id)\n            if isinstance(name, str):\n                resource_map[r.logical_id] = (\n                    f\"arn:aws:secretsmanager:us-east-1:000000000000:secret:{name}\"\n                )\n    return resource_map","originalFile":"\"\"\"Assembly orchestrator -- top-level entry point for CDK output parsing.\n\nTies together tree parsing, template parsing, reference resolution and\nasset location to produce a single ``AppModel`` that the rest of the\nsystem can consume.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport json\nimport logging\nfrom dataclasses import dataclass, field\nfrom pathlib import Path\nfrom typing import Any\n\nfrom lws.parser.asset_parser import parse_assets\nfrom lws.parser.ref_resolver import RefResolver\nfrom lws.parser.template_parser import (\n    CfnResource,\n    extract_api_routes,\n    extract_dynamo_tables,\n    extract_lambda_functions,\n    parse_template,\n)\nfrom lws.parser.tree_parser import parse_tree\n\nlogger = logging.getLogger(__name__)\n\n# ---------------------------------------------------------------------------\n# Domain model dataclasses\n# ---------------------------------------------------------------------------\n\n\n@dataclass\nclass LambdaFunction:\n    \"\"\"Parsed Lambda function ready for local execution.\"\"\"\n\n    name: str\n    handler: str\n    runtime: str\n    code_path: Path | None = None\n    timeout: int = 30\n    memory: int = 128\n    environment: dict[str, str] = field(default_factory=dict)\n\n    @property\n    def logical_id(self) -> str:\n        return self.name\n\n\n@dataclass\nclass DynamoTable:\n    \"\"\"Parsed DynamoDB table definition.\"\"\"\n\n    name: str\n    key_schema: list[dict[str, str]] = field(default_factory=list)\n    gsi_definitions: list[dict[str, Any]] = field(default_factory=list)\n\n    @property\n    def logical_id(self) -> str:\n        return self.name\n\n    @property\n    def table_name(self) -> str:\n        return self.name\n\n\n@dataclass\nclass ApiRoute:\n    \"\"\"A single API Gateway route.\"\"\"\n\n    method: str\n    path: str\n    handler_name: str | None = None\n\n\n@dataclass\nclass ApiDefinition:\n    \"\"\"A collection of routes making up an API.\"\"\"\n\n    name: str = \"default\"\n    routes: list[ApiRoute] = field(default_factory=list)\n\n    @property\n    def logical_id(self) -> str:\n        return self.name\n\n\n@dataclass\nclass SqsQueue:\n    \"\"\"Parsed SQS queue definition.\"\"\"\n\n    name: str\n    is_fifo: bool = False\n    visibility_timeout: int = 30\n    content_based_dedup: bool = False\n    redrive_target: str | None = None\n    max_receive_count: int = 5\n\n\n@dataclass\nclass S3Bucket:\n    \"\"\"Parsed S3 bucket definition.\"\"\"\n\n    name: str\n\n\n@dataclass\nclass SnsTopic:\n    \"\"\"Parsed SNS topic definition.\"\"\"\n\n    name: str\n    topic_arn: str = \"\"\n\n\n@dataclass\nclass EventBus:\n    \"\"\"Parsed EventBridge event bus definition.\"\"\"\n\n    name: str\n    bus_arn: str = \"\"\n\n\n@dataclass\nclass EventRule:\n    \"\"\"Parsed EventBridge rule definition.\"\"\"\n\n    rule_name: str\n    event_bus_name: str = \"default\"\n    event_pattern: dict[str, Any] | None = None\n    schedule_expression: str | None = None\n    targets: list[dict[str, Any]] = field(default_factory=list)\n\n\n@dataclass\nclass StateMachine:\n    \"\"\"Parsed Step Functions state machine definition.\"\"\"\n\n    name: str\n    definition: str | dict[str, Any] = \"\"\n    workflow_type: str = \"STANDARD\"\n    role_arn: str = \"\"\n    definition_substitutions: dict[str, str] = field(default_factory=dict)\n\n\n@dataclass\nclass CognitoUserPool:\n    \"\"\"Parsed Cognito user pool definition.\"\"\"\n\n    logical_id: str\n    user_pool_name: str = \"default\"\n    auto_confirm: bool = True\n    password_policy: dict[str, Any] = field(default_factory=dict)\n    pre_auth_trigger: str | None = None\n    post_confirm_trigger: str | None = None\n    client_id: str = \"\"\n\n\n@dataclass\nclass SsmParameter:\n    \"\"\"Parsed SSM Parameter Store parameter.\"\"\"\n\n    name: str\n    type: str  # \"String\", \"StringList\", \"SecureString\"\n    value: str\n    description: str = \"\"\n\n\n@dataclass\nclass SmSecret:\n    \"\"\"Parsed Secrets Manager secret.\"\"\"\n\n    name: str\n    description: str = \"\"\n    secret_string: str | None = None\n\n\n@dataclass\nclass AppModel:\n    \"\"\"Complete parsed representation of a CDK application.\"\"\"\n\n    functions: list[LambdaFunction] = field(default_factory=list)\n    tables: list[DynamoTable] = field(default_factory=list)\n    apis: list[ApiDefinition] = field(default_factory=list)\n    queues: list[SqsQueue] = field(default_factory=list)\n    buckets: list[S3Bucket] = field(default_factory=list)\n    topics: list[SnsTopic] = field(default_factory=list)\n    event_buses: list[EventBus] = field(default_factory=list)\n    event_rules: list[EventRule] = field(default_factory=list)\n    state_machines: list[StateMachine] = field(default_factory=list)\n    user_pools: list[CognitoUserPool] = field(default_factory=list)\n    ecs_services: list[Any] = field(default_factory=list)\n    ssm_parameters: list[SsmParameter] = field(default_factory=list)\n    secrets: list[SmSecret] = field(default_factory=list)\n\n\n# ---------------------------------------------------------------------------\n# Orchestrator\n# ---------------------------------------------------------------------------\n\n\ndef parse_assembly(cdk_out_path: Path) -> AppModel:\n    \"\"\"Parse an entire CDK ``cdk.out`` directory into an :class:`AppModel`.\n\n    Parameters\n    ----------\n    cdk_out_path:\n        Path to the ``cdk.out`` directory produced by ``cdk synth``.\n\n    Returns\n    -------\n    AppModel\n    \"\"\"\n    manifest_path = cdk_out_path / \"manifest.json\"\n    if not manifest_path.exists():\n        logger.warning(\"No manifest.json found in %s\", cdk_out_path)\n        return AppModel()\n\n    with open(manifest_path, encoding=\"utf-8\") as fh:\n        manifest = json.load(fh)\n\n    # Parse assets (hash -> filesystem path)\n    asset_map = parse_assets(cdk_out_path)\n\n    # Parse tree.json if present\n    tree_path = cdk_out_path / \"tree.json\"\n    if tree_path.exists():\n        parse_tree(tree_path)  # Currently used for validation; future enrichment\n\n    # Collect all stack artifacts\n    model = AppModel()\n    for artifact_id, artifact in (manifest.get(\"artifacts\") or {}).items():\n        if artifact.get(\"type\") != \"aws:cloudformation:stack\":\n            continue\n        _process_stack(cdk_out_path, artifact_id, artifact, asset_map, model)\n\n    return model\n\n\ndef _process_stack(\n    cdk_out_path: Path,\n    artifact_id: str,\n    artifact: dict,\n    asset_map: dict[str, Path],\n    model: AppModel,\n) -> None:\n    \"\"\"Process a single CloudFormation stack artifact.\"\"\"\n    template_file = artifact.get(\"properties\", {}).get(\"templateFile\")\n    if not template_file:\n        logger.warning(\"Stack %s has no templateFile\", artifact_id)\n        return\n\n    template_path = cdk_out_path / template_file\n    if not template_path.exists():\n        logger.warning(\"Template not found: %s\", template_path)\n        return\n\n    resources = parse_template(template_path)\n    resource_type_map = {r.logical_id: r.resource_type for r in resources}\n    resource_map = _build_resource_map(resources)\n    resolver = RefResolver(resource_map=resource_map, resource_types=resource_type_map)\n\n    model.functions.extend(_collect_lambdas(resources, asset_map, cdk_out_path, resolver))\n    model.tables.extend(_collect_tables(resources, resolver))\n    api_def = _collect_api_routes(resources, resolver, artifact_id)\n    if api_def:\n        model.apis.append(api_def)\n    model.queues.extend(_collect_queues(resources, resolver))\n    model.buckets.extend(_collect_buckets(resources))\n    model.topics.extend(_collect_topics(resources, resolver))\n    model.event_buses.extend(_collect_event_buses(resources, resolver))\n    model.event_rules.extend(_collect_event_rules(resources, resolver))\n    model.state_machines.extend(_collect_state_machines(resources, resolver))\n    model.user_pools.extend(_collect_user_pools(resources, resolver))\n\n    # ECS needs the raw template dict\n    with open(template_path, encoding=\"utf-8\") as fh:\n        raw_template = json.load(fh)\n    ecs_services = _collect_ecs_services(raw_template)\n    model.ecs_services.extend(ecs_services)\n\n\ndef _build_resource_map(resources: list[CfnResource]) -> dict[str, str]:\n    \"\"\"Build a Ref resource_map so intrinsic ``Ref`` calls resolve to useful local values.\n\n    In real CloudFormation:\n    - ``Ref`` on an ``AWS::SQS::Queue`` returns the queue URL.\n    - ``Ref`` on an ``AWS::DynamoDB::Table`` returns the table name.\n\n    We reproduce this behaviour with deterministic local placeholders so that\n    Lambda environment variables like ``QUEUE_URL`` and ``TABLE_NAME`` resolve\n    to values the local providers can understand.\n    \"\"\"\n    resource_map: dict[str, str] = {}\n    for r in resources:\n        if r.resource_type == \"AWS::SQS::Queue\":\n            queue_name = r.properties.get(\"QueueName\", r.logical_id)\n            if isinstance(queue_name, str):\n                # Use ARN format so the SDK connects via AWS_ENDPOINT_URL_SQS\n                # rather than trying to resolve the QueueUrl as a hostname.\n                resource_map[r.logical_id] = f\"arn:ldk:sqs:local:000000000000:queue/{queue_name}\"\n        elif r.resource_type == \"AWS::DynamoDB::Table\":\n            # Ref returns the table name.\n            table_name = r.properties.get(\"TableName\", r.logical_id)\n            if isinstance(table_name, str):\n                resource_map[r.logical_id] = table_name\n        elif r.resource_type == \"AWS::S3::Bucket\":\n            # Ref returns the bucket name.\n            bucket_name = r.properties.get(\"BucketName\", r.logical_id)\n            if isinstance(bucket_name, str):\n                resource_map[r.logical_id] = bucket_name\n            else:\n                resource_map[r.logical_id] = r.logical_id\n        elif r.resource_type == \"AWS::SNS::Topic\":\n            # Ref returns the topic ARN.\n            topic_name = r.properties.get(\"TopicName\", r.logical_id)\n            if isinstance(topic_name, str):\n                resource_map[r.logical_id] = f\"arn:ldk:sns:local:000000000000:{topic_name}\"\n    return resource_map\n\n\ndef _collect_lambdas(\n    resources: list[CfnResource],\n    asset_map: dict[str, Path],\n    cdk_out_path: Path,\n    resolver: RefResolver,\n) -> list[LambdaFunction]:\n    \"\"\"Extract Lambda functions from parsed CloudFormation resources.\"\"\"\n    functions: list[LambdaFunction] = []\n    lambda_props_list = extract_lambda_functions(resources)\n    lambda_resources = [r for r in resources if r.resource_type == \"AWS::Lambda::Function\"]\n    for r, props in zip(lambda_resources, lambda_props_list):\n        code_path = _resolve_code_path(props.code_uri, asset_map, cdk_out_path, resolver)\n        env = {k: str(resolver.resolve(v)) for k, v in props.environment.items()}\n        functions.append(\n            LambdaFunction(\n                name=r.logical_id,\n                handler=props.handler or \"index.handler\",\n                runtime=props.runtime or \"python3.11\",\n                code_path=code_path,\n                timeout=props.timeout or 30,\n                memory=props.memory_size or 128,\n                environment=env,\n            )\n        )\n    return functions\n\n\ndef _collect_tables(\n    resources: list[CfnResource],\n    resolver: RefResolver,\n) -> list[DynamoTable]:\n    \"\"\"Extract DynamoDB tables from parsed CloudFormation resources.\"\"\"\n    tables: list[DynamoTable] = []\n    dynamo_props_list = extract_dynamo_tables(resources)\n    dynamo_resources = [r for r in resources if r.resource_type == \"AWS::DynamoDB::Table\"]\n    for r, props in zip(dynamo_resources, dynamo_props_list):\n        name = props.table_name or r.logical_id\n        if isinstance(name, dict):\n            name = str(resolver.resolve(name))\n        tables.append(\n            DynamoTable(\n                name=name,\n                key_schema=props.key_schema,\n                gsi_definitions=props.gsi_definitions,\n            )\n        )\n    return tables\n\n\ndef _collect_api_routes(\n    resources: list[CfnResource],\n    resolver: RefResolver,\n    artifact_id: str,\n) -> ApiDefinition | None:\n    \"\"\"Extract API Gateway routes from parsed CloudFormation resources.\"\"\"\n    api_routes = extract_api_routes(resources)\n    if not api_routes:\n        return None\n    routes: list[ApiRoute] = []\n    for route_props in api_routes:\n        handler_name = _find_handler_for_integration(\n            route_props.integration_uri, resources, resolver\n        )\n        routes.append(\n            ApiRoute(\n                method=route_props.http_method or \"ANY\",\n                path=route_props.resource_path or \"/\",\n                handler_name=handler_name,\n            )\n        )\n    return ApiDefinition(name=artifact_id, routes=routes)\n\n\ndef _resolve_code_from_s3_key(s3_key: str, asset_map: dict[str, Path]) -> Path | None:\n    \"\"\"Try to match an S3Key to an asset by hash.\"\"\"\n    asset_hash = s3_key.replace(\".zip\", \"\")\n    if asset_hash in asset_map:\n        return asset_map[asset_hash]\n    for hash_key, path in asset_map.items():\n        if hash_key in s3_key:\n            return path\n    return None\n\n\ndef _resolve_code_from_s3_bucket(\n    s3_bucket: dict, resolver: RefResolver, asset_map: dict[str, Path]\n) -> Path | None:\n    \"\"\"Try to match an S3Bucket ref to an asset.\"\"\"\n    resolved = str(resolver.resolve(s3_bucket))\n    for h, p in asset_map.items():\n        if h in resolved:\n            return p\n    return None\n\n\ndef _resolve_code_path(\n    code_uri: Any,\n    asset_map: dict[str, Path],\n    cdk_out_path: Path,\n    resolver: RefResolver,\n) -> Path | None:\n    \"\"\"Resolve a Lambda Code property to a local filesystem path.\"\"\"\n    if code_uri is None:\n        return None\n\n    if isinstance(code_uri, dict):\n        s3_key = code_uri.get(\"S3Key\")\n        if isinstance(s3_key, str):\n            result = _resolve_code_from_s3_key(s3_key, asset_map)\n            if result:\n                return result\n\n        s3_bucket = code_uri.get(\"S3Bucket\")\n        if isinstance(s3_bucket, dict):\n            result = _resolve_code_from_s3_bucket(s3_bucket, resolver, asset_map)\n            if result:\n                return result\n\n    if isinstance(code_uri, str):\n        candidate = cdk_out_path / code_uri\n        if candidate.exists():\n            return candidate\n\n    return None\n\n\ndef _find_handler_for_integration(\n    integration_uri: Any,\n    resources: list[CfnResource],\n    resolver: RefResolver,\n) -> str | None:\n    \"\"\"Try to match an API integration URI back to a Lambda logical ID.\"\"\"\n    if integration_uri is None:\n        return None\n\n    resolved = str(resolver.resolve(integration_uri))\n\n    # Look for a Lambda function logical ID in the resolved string\n    for r in resources:\n        if r.resource_type == \"AWS::Lambda::Function\":\n            if r.logical_id in resolved:\n                return r.logical_id\n\n    return None\n\n\n# ---------------------------------------------------------------------------\n# Collectors for new resource types\n# ---------------------------------------------------------------------------\n\n\ndef _collect_queues(\n    resources: list[CfnResource],\n    resolver: RefResolver,\n) -> list[SqsQueue]:\n    \"\"\"Extract SQS queues from parsed CloudFormation resources.\"\"\"\n    queues: list[SqsQueue] = []\n    for r in resources:\n        if r.resource_type != \"AWS::SQS::Queue\":\n            continue\n        props = r.properties\n        name = props.get(\"QueueName\", r.logical_id)\n        if isinstance(name, dict):\n            name = str(resolver.resolve(name))\n        is_fifo = bool(props.get(\"FifoQueue\", False))\n        vis = int(props.get(\"VisibilityTimeout\", 30))\n        dedup = bool(props.get(\"ContentBasedDeduplication\", False))\n        redrive = props.get(\"RedrivePolicy\")\n        redrive_target = None\n        max_receive = 5\n        if isinstance(redrive, dict):\n            dlq = redrive.get(\"deadLetterTargetArn\", \"\")\n            if isinstance(dlq, dict):\n                dlq = str(resolver.resolve(dlq))\n            redrive_target = str(dlq) if dlq else None\n            max_receive = int(redrive.get(\"maxReceiveCount\", 5))\n        queues.append(\n            SqsQueue(\n                name=name,\n                is_fifo=is_fifo,\n                visibility_timeout=vis,\n                content_based_dedup=dedup,\n                redrive_target=redrive_target,\n                max_receive_count=max_receive,\n            )\n        )\n    return queues\n\n\ndef _collect_buckets(resources: list[CfnResource]) -> list[S3Bucket]:\n    \"\"\"Extract S3 buckets from parsed CloudFormation resources.\"\"\"\n    buckets: list[S3Bucket] = []\n    for r in resources:\n        if r.resource_type != \"AWS::S3::Bucket\":\n            continue\n        name = r.properties.get(\"BucketName\", r.logical_id)\n        if isinstance(name, dict):\n            name = r.logical_id  # Can't resolve intrinsics for bucket names easily\n        buckets.append(S3Bucket(name=name))\n    return buckets\n\n\ndef _collect_topics(\n    resources: list[CfnResource],\n    resolver: RefResolver,\n) -> list[SnsTopic]:\n    \"\"\"Extract SNS topics from parsed CloudFormation resources.\"\"\"\n    topics: list[SnsTopic] = []\n    for r in resources:\n        if r.resource_type != \"AWS::SNS::Topic\":\n            continue\n        props = r.properties\n        name = props.get(\"TopicName\", r.logical_id)\n        if isinstance(name, dict):\n            name = str(resolver.resolve(name))\n        arn = f\"arn:aws:sns:us-east-1:000000000000:{name}\"\n        topics.append(SnsTopic(name=name, topic_arn=arn))\n    return topics\n\n\ndef _collect_event_buses(\n    resources: list[CfnResource],\n    resolver: RefResolver,\n) -> list[EventBus]:\n    \"\"\"Extract EventBridge event buses from parsed CloudFormation resources.\"\"\"\n    buses: list[EventBus] = []\n    for r in resources:\n        if r.resource_type != \"AWS::Events::EventBus\":\n            continue\n        props = r.properties\n        name = props.get(\"Name\", r.logical_id)\n        if isinstance(name, dict):\n            name = str(resolver.resolve(name))\n        arn = f\"arn:aws:events:us-east-1:000000000000:event-bus/{name}\"\n        buses.append(EventBus(name=name, bus_arn=arn))\n    return buses\n\n\ndef _collect_event_rules(\n    resources: list[CfnResource],\n    resolver: RefResolver,\n) -> list[EventRule]:\n    \"\"\"Extract EventBridge rules from parsed CloudFormation resources.\"\"\"\n    rules: list[EventRule] = []\n    for r in resources:\n        if r.resource_type != \"AWS::Events::Rule\":\n            continue\n        props = r.properties\n        rule_name = props.get(\"Name\", r.logical_id)\n        if isinstance(rule_name, dict):\n            rule_name = str(resolver.resolve(rule_name))\n        bus_name = props.get(\"EventBusName\", \"default\")\n        if isinstance(bus_name, dict):\n            bus_name = str(resolver.resolve(bus_name))\n        pattern = props.get(\"EventPattern\")\n        schedule = props.get(\"ScheduleExpression\")\n        raw_targets = props.get(\"Targets\", [])\n        targets: list[dict[str, Any]] = []\n        for t in raw_targets:\n            target_arn = t.get(\"Arn\", \"\")\n            if isinstance(target_arn, dict):\n                target_arn = str(resolver.resolve(target_arn))\n            targets.append(\n                {\n                    \"target_id\": t.get(\"Id\", \"\"),\n                    \"arn\": target_arn,\n                    \"input_path\": t.get(\"InputPath\"),\n                    \"input_template\": t.get(\"InputTransformer\", {}).get(\"InputTemplate\"),\n                }\n            )\n        rules.append(\n            EventRule(\n                rule_name=rule_name,\n                event_bus_name=bus_name,\n                event_pattern=pattern,\n                schedule_expression=schedule,\n                targets=targets,\n            )\n        )\n    return rules\n\n\ndef _resolve_sm_definition(definition: Any, resolver: RefResolver) -> Any:\n    \"\"\"Resolve a Step Functions DefinitionString that may use intrinsic functions.\"\"\"\n    if isinstance(definition, dict):\n        return resolver.resolve(definition)\n    return definition\n\n\ndef _resolve_substitutions(subs: dict[str, Any], resolver: RefResolver) -> dict[str, str]:\n    \"\"\"Resolve CloudFormation DefinitionSubstitutions to plain strings.\"\"\"\n    return {k: str(resolver.resolve(v)) if isinstance(v, dict) else str(v) for k, v in subs.items()}\n\n\ndef _collect_state_machines(\n    resources: list[CfnResource],\n    resolver: RefResolver,\n) -> list[StateMachine]:\n    \"\"\"Extract Step Functions state machines from parsed CloudFormation resources.\"\"\"\n    machines: list[StateMachine] = []\n    for r in resources:\n        if r.resource_type != \"AWS::StepFunctions::StateMachine\":\n            continue\n        props = r.properties\n        name = props.get(\"StateMachineName\", r.logical_id)\n        if isinstance(name, dict):\n            name = str(resolver.resolve(name))\n        definition = props.get(\"DefinitionString\", props.get(\"Definition\", \"\"))\n        definition = _resolve_sm_definition(definition, resolver)\n        role_arn = props.get(\"RoleArn\", \"\")\n        if isinstance(role_arn, dict):\n            role_arn = str(resolver.resolve(role_arn))\n        resolved_subs = _resolve_substitutions(props.get(\"DefinitionSubstitutions\", {}), resolver)\n        machines.append(\n            StateMachine(\n                name=name,\n                definition=definition,\n                workflow_type=props.get(\"StateMachineType\", \"STANDARD\"),\n                role_arn=role_arn,\n                definition_substitutions=resolved_subs,\n            )\n        )\n    return machines\n\n\ndef _collect_user_pools(\n    resources: list[CfnResource],\n    resolver: RefResolver,\n) -> list[CognitoUserPool]:\n    \"\"\"Extract Cognito user pools from parsed CloudFormation resources.\"\"\"\n    pools: list[CognitoUserPool] = []\n    # First pass: collect user pool clients to map pool -> client_id\n    client_map: dict[str, str] = {}\n    for r in resources:\n        if r.resource_type != \"AWS::Cognito::UserPoolClient\":\n            continue\n        pool_ref = r.properties.get(\"UserPoolId\", \"\")\n        if isinstance(pool_ref, dict):\n            pool_ref = str(resolver.resolve(pool_ref))\n        client_map[pool_ref] = r.logical_id\n\n    for r in resources:\n        if r.resource_type != \"AWS::Cognito::UserPool\":\n            continue\n        props = r.properties\n        name = props.get(\"UserPoolName\", r.logical_id)\n        if isinstance(name, dict):\n            name = str(resolver.resolve(name))\n        auto_confirm = True\n        lambda_config = props.get(\"LambdaConfig\", {})\n        pre_auth = lambda_config.get(\"PreAuthentication\")\n        if isinstance(pre_auth, dict):\n            pre_auth = str(resolver.resolve(pre_auth))\n        post_confirm = lambda_config.get(\"PostConfirmation\")\n        if isinstance(post_confirm, dict):\n            post_confirm = str(resolver.resolve(post_confirm))\n        pw_policy = props.get(\"Policies\", {}).get(\"PasswordPolicy\", {})\n        client_id = client_map.get(r.logical_id, \"\")\n        pools.append(\n            CognitoUserPool(\n                logical_id=r.logical_id,\n                user_pool_name=name,\n                auto_confirm=auto_confirm,\n                password_policy=pw_policy,\n                pre_auth_trigger=pre_auth,\n                post_confirm_trigger=post_confirm,\n                client_id=client_id,\n            )\n        )\n    return pools\n\n\ndef _collect_ecs_services(template: dict) -> list:\n    \"\"\"Extract ECS services from the raw CloudFormation template.\"\"\"\n    try:\n        from lws.providers.ecs.provider import parse_ecs_resources\n\n        return parse_ecs_resources(template)\n    except Exception:\n        logger.debug(\"Could not parse ECS resources\", exc_info=True)\n        return []\n","structuredPatch":[{"oldStart":316,"oldLines":6,"newStart":316,"newLines":16,"lines":["             topic_name = r.properties.get(\"TopicName\", r.logical_id)","             if isinstance(topic_name, str):","                 resource_map[r.logical_id] = f\"arn:ldk:sns:local:000000000000:{topic_name}\"","+        elif r.resource_type == \"AWS::SSM::Parameter\":","+            name = r.properties.get(\"Name\", r.logical_id)","+            if isinstance(name, str):","+                resource_map[r.logical_id] = name","+        elif r.resource_type == \"AWS::SecretsManager::Secret\":","+            name = r.properties.get(\"Name\", r.logical_id)","+            if isinstance(name, str):","+                resource_map[r.logical_id] = (","+                    f\"arn:aws:secretsmanager:us-east-1:000000000000:secret:{name}\"","+                )","     return resource_map"," "," "]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"285e7607-91dd-42de-88b7-c9219ffef8ef"}
{"parentUuid":"ef7e445c-8d12-4167-9d04-ffdbf9221d50","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","message":{"model":"claude-opus-4-6","id":"msg_013VWDUuwUHZj2YcC9ejoT6m","type":"message","role":"assistant","content":[{"type":"text","text":"Now add the collector calls in `_process_stack`:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":569,"cache_read_input_tokens":66317,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":569},"output_tokens":2,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CY1FFuv3F1gVWkBGCioKL","type":"assistant","uuid":"895cda92-4af1-429a-be87-06b8ee51a900","timestamp":"2026-02-10T23:21:13.199Z"}
{"parentUuid":"895cda92-4af1-429a-be87-06b8ee51a900","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","message":{"model":"claude-opus-4-6","id":"msg_013VWDUuwUHZj2YcC9ejoT6m","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_014nXtAgx5LFqGanEQkdybQg","name":"Edit","input":{"replace_all":false,"file_path":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services/src/lws/parser/assembly.py","old_string":"    model.user_pools.extend(_collect_user_pools(resources, resolver))\n\n    # ECS needs the raw template dict","new_string":"    model.user_pools.extend(_collect_user_pools(resources, resolver))\n    model.ssm_parameters.extend(_collect_ssm_parameters(resources, resolver))\n    model.secrets.extend(_collect_secrets(resources, resolver))\n\n    # ECS needs the raw template dict"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":569,"cache_read_input_tokens":66317,"output_tokens":253,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":569,"ephemeral_5m_input_tokens":0},"inference_geo":"","iterations":[]}},"requestId":"req_011CY1FFuv3F1gVWkBGCioKL","type":"assistant","uuid":"0a09fb3a-0a9f-4b64-9ba0-ce209bf76351","timestamp":"2026-02-10T23:21:15.919Z"}
{"parentUuid":"0a09fb3a-0a9f-4b64-9ba0-ce209bf76351","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"callback"},"parentToolUseID":"toolu_014nXtAgx5LFqGanEQkdybQg","toolUseID":"toolu_014nXtAgx5LFqGanEQkdybQg","timestamp":"2026-02-10T23:21:15.929Z","uuid":"d4af70b7-4a6b-42d5-9f81-19d52c74fd71"}
{"parentUuid":"0a09fb3a-0a9f-4b64-9ba0-ce209bf76351","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_014nXtAgx5LFqGanEQkdybQg","type":"tool_result","content":"The file /Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services/src/lws/parser/assembly.py has been updated successfully."}]},"uuid":"68203ff2-c0b3-4dcb-8112-19b7f8e8bda3","timestamp":"2026-02-10T23:21:15.928Z","toolUseResult":{"filePath":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services/src/lws/parser/assembly.py","oldString":"    model.user_pools.extend(_collect_user_pools(resources, resolver))\n\n    # ECS needs the raw template dict","newString":"    model.user_pools.extend(_collect_user_pools(resources, resolver))\n    model.ssm_parameters.extend(_collect_ssm_parameters(resources, resolver))\n    model.secrets.extend(_collect_secrets(resources, resolver))\n\n    # ECS needs the raw template dict","originalFile":"\"\"\"Assembly orchestrator -- top-level entry point for CDK output parsing.\n\nTies together tree parsing, template parsing, reference resolution and\nasset location to produce a single ``AppModel`` that the rest of the\nsystem can consume.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport json\nimport logging\nfrom dataclasses import dataclass, field\nfrom pathlib import Path\nfrom typing import Any\n\nfrom lws.parser.asset_parser import parse_assets\nfrom lws.parser.ref_resolver import RefResolver\nfrom lws.parser.template_parser import (\n    CfnResource,\n    extract_api_routes,\n    extract_dynamo_tables,\n    extract_lambda_functions,\n    parse_template,\n)\nfrom lws.parser.tree_parser import parse_tree\n\nlogger = logging.getLogger(__name__)\n\n# ---------------------------------------------------------------------------\n# Domain model dataclasses\n# ---------------------------------------------------------------------------\n\n\n@dataclass\nclass LambdaFunction:\n    \"\"\"Parsed Lambda function ready for local execution.\"\"\"\n\n    name: str\n    handler: str\n    runtime: str\n    code_path: Path | None = None\n    timeout: int = 30\n    memory: int = 128\n    environment: dict[str, str] = field(default_factory=dict)\n\n    @property\n    def logical_id(self) -> str:\n        return self.name\n\n\n@dataclass\nclass DynamoTable:\n    \"\"\"Parsed DynamoDB table definition.\"\"\"\n\n    name: str\n    key_schema: list[dict[str, str]] = field(default_factory=list)\n    gsi_definitions: list[dict[str, Any]] = field(default_factory=list)\n\n    @property\n    def logical_id(self) -> str:\n        return self.name\n\n    @property\n    def table_name(self) -> str:\n        return self.name\n\n\n@dataclass\nclass ApiRoute:\n    \"\"\"A single API Gateway route.\"\"\"\n\n    method: str\n    path: str\n    handler_name: str | None = None\n\n\n@dataclass\nclass ApiDefinition:\n    \"\"\"A collection of routes making up an API.\"\"\"\n\n    name: str = \"default\"\n    routes: list[ApiRoute] = field(default_factory=list)\n\n    @property\n    def logical_id(self) -> str:\n        return self.name\n\n\n@dataclass\nclass SqsQueue:\n    \"\"\"Parsed SQS queue definition.\"\"\"\n\n    name: str\n    is_fifo: bool = False\n    visibility_timeout: int = 30\n    content_based_dedup: bool = False\n    redrive_target: str | None = None\n    max_receive_count: int = 5\n\n\n@dataclass\nclass S3Bucket:\n    \"\"\"Parsed S3 bucket definition.\"\"\"\n\n    name: str\n\n\n@dataclass\nclass SnsTopic:\n    \"\"\"Parsed SNS topic definition.\"\"\"\n\n    name: str\n    topic_arn: str = \"\"\n\n\n@dataclass\nclass EventBus:\n    \"\"\"Parsed EventBridge event bus definition.\"\"\"\n\n    name: str\n    bus_arn: str = \"\"\n\n\n@dataclass\nclass EventRule:\n    \"\"\"Parsed EventBridge rule definition.\"\"\"\n\n    rule_name: str\n    event_bus_name: str = \"default\"\n    event_pattern: dict[str, Any] | None = None\n    schedule_expression: str | None = None\n    targets: list[dict[str, Any]] = field(default_factory=list)\n\n\n@dataclass\nclass StateMachine:\n    \"\"\"Parsed Step Functions state machine definition.\"\"\"\n\n    name: str\n    definition: str | dict[str, Any] = \"\"\n    workflow_type: str = \"STANDARD\"\n    role_arn: str = \"\"\n    definition_substitutions: dict[str, str] = field(default_factory=dict)\n\n\n@dataclass\nclass CognitoUserPool:\n    \"\"\"Parsed Cognito user pool definition.\"\"\"\n\n    logical_id: str\n    user_pool_name: str = \"default\"\n    auto_confirm: bool = True\n    password_policy: dict[str, Any] = field(default_factory=dict)\n    pre_auth_trigger: str | None = None\n    post_confirm_trigger: str | None = None\n    client_id: str = \"\"\n\n\n@dataclass\nclass SsmParameter:\n    \"\"\"Parsed SSM Parameter Store parameter.\"\"\"\n\n    name: str\n    type: str  # \"String\", \"StringList\", \"SecureString\"\n    value: str\n    description: str = \"\"\n\n\n@dataclass\nclass SmSecret:\n    \"\"\"Parsed Secrets Manager secret.\"\"\"\n\n    name: str\n    description: str = \"\"\n    secret_string: str | None = None\n\n\n@dataclass\nclass AppModel:\n    \"\"\"Complete parsed representation of a CDK application.\"\"\"\n\n    functions: list[LambdaFunction] = field(default_factory=list)\n    tables: list[DynamoTable] = field(default_factory=list)\n    apis: list[ApiDefinition] = field(default_factory=list)\n    queues: list[SqsQueue] = field(default_factory=list)\n    buckets: list[S3Bucket] = field(default_factory=list)\n    topics: list[SnsTopic] = field(default_factory=list)\n    event_buses: list[EventBus] = field(default_factory=list)\n    event_rules: list[EventRule] = field(default_factory=list)\n    state_machines: list[StateMachine] = field(default_factory=list)\n    user_pools: list[CognitoUserPool] = field(default_factory=list)\n    ecs_services: list[Any] = field(default_factory=list)\n    ssm_parameters: list[SsmParameter] = field(default_factory=list)\n    secrets: list[SmSecret] = field(default_factory=list)\n\n\n# ---------------------------------------------------------------------------\n# Orchestrator\n# ---------------------------------------------------------------------------\n\n\ndef parse_assembly(cdk_out_path: Path) -> AppModel:\n    \"\"\"Parse an entire CDK ``cdk.out`` directory into an :class:`AppModel`.\n\n    Parameters\n    ----------\n    cdk_out_path:\n        Path to the ``cdk.out`` directory produced by ``cdk synth``.\n\n    Returns\n    -------\n    AppModel\n    \"\"\"\n    manifest_path = cdk_out_path / \"manifest.json\"\n    if not manifest_path.exists():\n        logger.warning(\"No manifest.json found in %s\", cdk_out_path)\n        return AppModel()\n\n    with open(manifest_path, encoding=\"utf-8\") as fh:\n        manifest = json.load(fh)\n\n    # Parse assets (hash -> filesystem path)\n    asset_map = parse_assets(cdk_out_path)\n\n    # Parse tree.json if present\n    tree_path = cdk_out_path / \"tree.json\"\n    if tree_path.exists():\n        parse_tree(tree_path)  # Currently used for validation; future enrichment\n\n    # Collect all stack artifacts\n    model = AppModel()\n    for artifact_id, artifact in (manifest.get(\"artifacts\") or {}).items():\n        if artifact.get(\"type\") != \"aws:cloudformation:stack\":\n            continue\n        _process_stack(cdk_out_path, artifact_id, artifact, asset_map, model)\n\n    return model\n\n\ndef _process_stack(\n    cdk_out_path: Path,\n    artifact_id: str,\n    artifact: dict,\n    asset_map: dict[str, Path],\n    model: AppModel,\n) -> None:\n    \"\"\"Process a single CloudFormation stack artifact.\"\"\"\n    template_file = artifact.get(\"properties\", {}).get(\"templateFile\")\n    if not template_file:\n        logger.warning(\"Stack %s has no templateFile\", artifact_id)\n        return\n\n    template_path = cdk_out_path / template_file\n    if not template_path.exists():\n        logger.warning(\"Template not found: %s\", template_path)\n        return\n\n    resources = parse_template(template_path)\n    resource_type_map = {r.logical_id: r.resource_type for r in resources}\n    resource_map = _build_resource_map(resources)\n    resolver = RefResolver(resource_map=resource_map, resource_types=resource_type_map)\n\n    model.functions.extend(_collect_lambdas(resources, asset_map, cdk_out_path, resolver))\n    model.tables.extend(_collect_tables(resources, resolver))\n    api_def = _collect_api_routes(resources, resolver, artifact_id)\n    if api_def:\n        model.apis.append(api_def)\n    model.queues.extend(_collect_queues(resources, resolver))\n    model.buckets.extend(_collect_buckets(resources))\n    model.topics.extend(_collect_topics(resources, resolver))\n    model.event_buses.extend(_collect_event_buses(resources, resolver))\n    model.event_rules.extend(_collect_event_rules(resources, resolver))\n    model.state_machines.extend(_collect_state_machines(resources, resolver))\n    model.user_pools.extend(_collect_user_pools(resources, resolver))\n\n    # ECS needs the raw template dict\n    with open(template_path, encoding=\"utf-8\") as fh:\n        raw_template = json.load(fh)\n    ecs_services = _collect_ecs_services(raw_template)\n    model.ecs_services.extend(ecs_services)\n\n\ndef _build_resource_map(resources: list[CfnResource]) -> dict[str, str]:\n    \"\"\"Build a Ref resource_map so intrinsic ``Ref`` calls resolve to useful local values.\n\n    In real CloudFormation:\n    - ``Ref`` on an ``AWS::SQS::Queue`` returns the queue URL.\n    - ``Ref`` on an ``AWS::DynamoDB::Table`` returns the table name.\n\n    We reproduce this behaviour with deterministic local placeholders so that\n    Lambda environment variables like ``QUEUE_URL`` and ``TABLE_NAME`` resolve\n    to values the local providers can understand.\n    \"\"\"\n    resource_map: dict[str, str] = {}\n    for r in resources:\n        if r.resource_type == \"AWS::SQS::Queue\":\n            queue_name = r.properties.get(\"QueueName\", r.logical_id)\n            if isinstance(queue_name, str):\n                # Use ARN format so the SDK connects via AWS_ENDPOINT_URL_SQS\n                # rather than trying to resolve the QueueUrl as a hostname.\n                resource_map[r.logical_id] = f\"arn:ldk:sqs:local:000000000000:queue/{queue_name}\"\n        elif r.resource_type == \"AWS::DynamoDB::Table\":\n            # Ref returns the table name.\n            table_name = r.properties.get(\"TableName\", r.logical_id)\n            if isinstance(table_name, str):\n                resource_map[r.logical_id] = table_name\n        elif r.resource_type == \"AWS::S3::Bucket\":\n            # Ref returns the bucket name.\n            bucket_name = r.properties.get(\"BucketName\", r.logical_id)\n            if isinstance(bucket_name, str):\n                resource_map[r.logical_id] = bucket_name\n            else:\n                resource_map[r.logical_id] = r.logical_id\n        elif r.resource_type == \"AWS::SNS::Topic\":\n            # Ref returns the topic ARN.\n            topic_name = r.properties.get(\"TopicName\", r.logical_id)\n            if isinstance(topic_name, str):\n                resource_map[r.logical_id] = f\"arn:ldk:sns:local:000000000000:{topic_name}\"\n        elif r.resource_type == \"AWS::SSM::Parameter\":\n            name = r.properties.get(\"Name\", r.logical_id)\n            if isinstance(name, str):\n                resource_map[r.logical_id] = name\n        elif r.resource_type == \"AWS::SecretsManager::Secret\":\n            name = r.properties.get(\"Name\", r.logical_id)\n            if isinstance(name, str):\n                resource_map[r.logical_id] = (\n                    f\"arn:aws:secretsmanager:us-east-1:000000000000:secret:{name}\"\n                )\n    return resource_map\n\n\ndef _collect_lambdas(\n    resources: list[CfnResource],\n    asset_map: dict[str, Path],\n    cdk_out_path: Path,\n    resolver: RefResolver,\n) -> list[LambdaFunction]:\n    \"\"\"Extract Lambda functions from parsed CloudFormation resources.\"\"\"\n    functions: list[LambdaFunction] = []\n    lambda_props_list = extract_lambda_functions(resources)\n    lambda_resources = [r for r in resources if r.resource_type == \"AWS::Lambda::Function\"]\n    for r, props in zip(lambda_resources, lambda_props_list):\n        code_path = _resolve_code_path(props.code_uri, asset_map, cdk_out_path, resolver)\n        env = {k: str(resolver.resolve(v)) for k, v in props.environment.items()}\n        functions.append(\n            LambdaFunction(\n                name=r.logical_id,\n                handler=props.handler or \"index.handler\",\n                runtime=props.runtime or \"python3.11\",\n                code_path=code_path,\n                timeout=props.timeout or 30,\n                memory=props.memory_size or 128,\n                environment=env,\n            )\n        )\n    return functions\n\n\ndef _collect_tables(\n    resources: list[CfnResource],\n    resolver: RefResolver,\n) -> list[DynamoTable]:\n    \"\"\"Extract DynamoDB tables from parsed CloudFormation resources.\"\"\"\n    tables: list[DynamoTable] = []\n    dynamo_props_list = extract_dynamo_tables(resources)\n    dynamo_resources = [r for r in resources if r.resource_type == \"AWS::DynamoDB::Table\"]\n    for r, props in zip(dynamo_resources, dynamo_props_list):\n        name = props.table_name or r.logical_id\n        if isinstance(name, dict):\n            name = str(resolver.resolve(name))\n        tables.append(\n            DynamoTable(\n                name=name,\n                key_schema=props.key_schema,\n                gsi_definitions=props.gsi_definitions,\n            )\n        )\n    return tables\n\n\ndef _collect_api_routes(\n    resources: list[CfnResource],\n    resolver: RefResolver,\n    artifact_id: str,\n) -> ApiDefinition | None:\n    \"\"\"Extract API Gateway routes from parsed CloudFormation resources.\"\"\"\n    api_routes = extract_api_routes(resources)\n    if not api_routes:\n        return None\n    routes: list[ApiRoute] = []\n    for route_props in api_routes:\n        handler_name = _find_handler_for_integration(\n            route_props.integration_uri, resources, resolver\n        )\n        routes.append(\n            ApiRoute(\n                method=route_props.http_method or \"ANY\",\n                path=route_props.resource_path or \"/\",\n                handler_name=handler_name,\n            )\n        )\n    return ApiDefinition(name=artifact_id, routes=routes)\n\n\ndef _resolve_code_from_s3_key(s3_key: str, asset_map: dict[str, Path]) -> Path | None:\n    \"\"\"Try to match an S3Key to an asset by hash.\"\"\"\n    asset_hash = s3_key.replace(\".zip\", \"\")\n    if asset_hash in asset_map:\n        return asset_map[asset_hash]\n    for hash_key, path in asset_map.items():\n        if hash_key in s3_key:\n            return path\n    return None\n\n\ndef _resolve_code_from_s3_bucket(\n    s3_bucket: dict, resolver: RefResolver, asset_map: dict[str, Path]\n) -> Path | None:\n    \"\"\"Try to match an S3Bucket ref to an asset.\"\"\"\n    resolved = str(resolver.resolve(s3_bucket))\n    for h, p in asset_map.items():\n        if h in resolved:\n            return p\n    return None\n\n\ndef _resolve_code_path(\n    code_uri: Any,\n    asset_map: dict[str, Path],\n    cdk_out_path: Path,\n    resolver: RefResolver,\n) -> Path | None:\n    \"\"\"Resolve a Lambda Code property to a local filesystem path.\"\"\"\n    if code_uri is None:\n        return None\n\n    if isinstance(code_uri, dict):\n        s3_key = code_uri.get(\"S3Key\")\n        if isinstance(s3_key, str):\n            result = _resolve_code_from_s3_key(s3_key, asset_map)\n            if result:\n                return result\n\n        s3_bucket = code_uri.get(\"S3Bucket\")\n        if isinstance(s3_bucket, dict):\n            result = _resolve_code_from_s3_bucket(s3_bucket, resolver, asset_map)\n            if result:\n                return result\n\n    if isinstance(code_uri, str):\n        candidate = cdk_out_path / code_uri\n        if candidate.exists():\n            return candidate\n\n    return None\n\n\ndef _find_handler_for_integration(\n    integration_uri: Any,\n    resources: list[CfnResource],\n    resolver: RefResolver,\n) -> str | None:\n    \"\"\"Try to match an API integration URI back to a Lambda logical ID.\"\"\"\n    if integration_uri is None:\n        return None\n\n    resolved = str(resolver.resolve(integration_uri))\n\n    # Look for a Lambda function logical ID in the resolved string\n    for r in resources:\n        if r.resource_type == \"AWS::Lambda::Function\":\n            if r.logical_id in resolved:\n                return r.logical_id\n\n    return None\n\n\n# ---------------------------------------------------------------------------\n# Collectors for new resource types\n# ---------------------------------------------------------------------------\n\n\ndef _collect_queues(\n    resources: list[CfnResource],\n    resolver: RefResolver,\n) -> list[SqsQueue]:\n    \"\"\"Extract SQS queues from parsed CloudFormation resources.\"\"\"\n    queues: list[SqsQueue] = []\n    for r in resources:\n        if r.resource_type != \"AWS::SQS::Queue\":\n            continue\n        props = r.properties\n        name = props.get(\"QueueName\", r.logical_id)\n        if isinstance(name, dict):\n            name = str(resolver.resolve(name))\n        is_fifo = bool(props.get(\"FifoQueue\", False))\n        vis = int(props.get(\"VisibilityTimeout\", 30))\n        dedup = bool(props.get(\"ContentBasedDeduplication\", False))\n        redrive = props.get(\"RedrivePolicy\")\n        redrive_target = None\n        max_receive = 5\n        if isinstance(redrive, dict):\n            dlq = redrive.get(\"deadLetterTargetArn\", \"\")\n            if isinstance(dlq, dict):\n                dlq = str(resolver.resolve(dlq))\n            redrive_target = str(dlq) if dlq else None\n            max_receive = int(redrive.get(\"maxReceiveCount\", 5))\n        queues.append(\n            SqsQueue(\n                name=name,\n                is_fifo=is_fifo,\n                visibility_timeout=vis,\n                content_based_dedup=dedup,\n                redrive_target=redrive_target,\n                max_receive_count=max_receive,\n            )\n        )\n    return queues\n\n\ndef _collect_buckets(resources: list[CfnResource]) -> list[S3Bucket]:\n    \"\"\"Extract S3 buckets from parsed CloudFormation resources.\"\"\"\n    buckets: list[S3Bucket] = []\n    for r in resources:\n        if r.resource_type != \"AWS::S3::Bucket\":\n            continue\n        name = r.properties.get(\"BucketName\", r.logical_id)\n        if isinstance(name, dict):\n            name = r.logical_id  # Can't resolve intrinsics for bucket names easily\n        buckets.append(S3Bucket(name=name))\n    return buckets\n\n\ndef _collect_topics(\n    resources: list[CfnResource],\n    resolver: RefResolver,\n) -> list[SnsTopic]:\n    \"\"\"Extract SNS topics from parsed CloudFormation resources.\"\"\"\n    topics: list[SnsTopic] = []\n    for r in resources:\n        if r.resource_type != \"AWS::SNS::Topic\":\n            continue\n        props = r.properties\n        name = props.get(\"TopicName\", r.logical_id)\n        if isinstance(name, dict):\n            name = str(resolver.resolve(name))\n        arn = f\"arn:aws:sns:us-east-1:000000000000:{name}\"\n        topics.append(SnsTopic(name=name, topic_arn=arn))\n    return topics\n\n\ndef _collect_event_buses(\n    resources: list[CfnResource],\n    resolver: RefResolver,\n) -> list[EventBus]:\n    \"\"\"Extract EventBridge event buses from parsed CloudFormation resources.\"\"\"\n    buses: list[EventBus] = []\n    for r in resources:\n        if r.resource_type != \"AWS::Events::EventBus\":\n            continue\n        props = r.properties\n        name = props.get(\"Name\", r.logical_id)\n        if isinstance(name, dict):\n            name = str(resolver.resolve(name))\n        arn = f\"arn:aws:events:us-east-1:000000000000:event-bus/{name}\"\n        buses.append(EventBus(name=name, bus_arn=arn))\n    return buses\n\n\ndef _collect_event_rules(\n    resources: list[CfnResource],\n    resolver: RefResolver,\n) -> list[EventRule]:\n    \"\"\"Extract EventBridge rules from parsed CloudFormation resources.\"\"\"\n    rules: list[EventRule] = []\n    for r in resources:\n        if r.resource_type != \"AWS::Events::Rule\":\n            continue\n        props = r.properties\n        rule_name = props.get(\"Name\", r.logical_id)\n        if isinstance(rule_name, dict):\n            rule_name = str(resolver.resolve(rule_name))\n        bus_name = props.get(\"EventBusName\", \"default\")\n        if isinstance(bus_name, dict):\n            bus_name = str(resolver.resolve(bus_name))\n        pattern = props.get(\"EventPattern\")\n        schedule = props.get(\"ScheduleExpression\")\n        raw_targets = props.get(\"Targets\", [])\n        targets: list[dict[str, Any]] = []\n        for t in raw_targets:\n            target_arn = t.get(\"Arn\", \"\")\n            if isinstance(target_arn, dict):\n                target_arn = str(resolver.resolve(target_arn))\n            targets.append(\n                {\n                    \"target_id\": t.get(\"Id\", \"\"),\n                    \"arn\": target_arn,\n                    \"input_path\": t.get(\"InputPath\"),\n                    \"input_template\": t.get(\"InputTransformer\", {}).get(\"InputTemplate\"),\n                }\n            )\n        rules.append(\n            EventRule(\n                rule_name=rule_name,\n                event_bus_name=bus_name,\n                event_pattern=pattern,\n                schedule_expression=schedule,\n                targets=targets,\n            )\n        )\n    return rules\n\n\ndef _resolve_sm_definition(definition: Any, resolver: RefResolver) -> Any:\n    \"\"\"Resolve a Step Functions DefinitionString that may use intrinsic functions.\"\"\"\n    if isinstance(definition, dict):\n        return resolver.resolve(definition)\n    return definition\n\n\ndef _resolve_substitutions(subs: dict[str, Any], resolver: RefResolver) -> dict[str, str]:\n    \"\"\"Resolve CloudFormation DefinitionSubstitutions to plain strings.\"\"\"\n    return {k: str(resolver.resolve(v)) if isinstance(v, dict) else str(v) for k, v in subs.items()}\n\n\ndef _collect_state_machines(\n    resources: list[CfnResource],\n    resolver: RefResolver,\n) -> list[StateMachine]:\n    \"\"\"Extract Step Functions state machines from parsed CloudFormation resources.\"\"\"\n    machines: list[StateMachine] = []\n    for r in resources:\n        if r.resource_type != \"AWS::StepFunctions::StateMachine\":\n            continue\n        props = r.properties\n        name = props.get(\"StateMachineName\", r.logical_id)\n        if isinstance(name, dict):\n            name = str(resolver.resolve(name))\n        definition = props.get(\"DefinitionString\", props.get(\"Definition\", \"\"))\n        definition = _resolve_sm_definition(definition, resolver)\n        role_arn = props.get(\"RoleArn\", \"\")\n        if isinstance(role_arn, dict):\n            role_arn = str(resolver.resolve(role_arn))\n        resolved_subs = _resolve_substitutions(props.get(\"DefinitionSubstitutions\", {}), resolver)\n        machines.append(\n            StateMachine(\n                name=name,\n                definition=definition,\n                workflow_type=props.get(\"StateMachineType\", \"STANDARD\"),\n                role_arn=role_arn,\n                definition_substitutions=resolved_subs,\n            )\n        )\n    return machines\n\n\ndef _collect_user_pools(\n    resources: list[CfnResource],\n    resolver: RefResolver,\n) -> list[CognitoUserPool]:\n    \"\"\"Extract Cognito user pools from parsed CloudFormation resources.\"\"\"\n    pools: list[CognitoUserPool] = []\n    # First pass: collect user pool clients to map pool -> client_id\n    client_map: dict[str, str] = {}\n    for r in resources:\n        if r.resource_type != \"AWS::Cognito::UserPoolClient\":\n            continue\n        pool_ref = r.properties.get(\"UserPoolId\", \"\")\n        if isinstance(pool_ref, dict):\n            pool_ref = str(resolver.resolve(pool_ref))\n        client_map[pool_ref] = r.logical_id\n\n    for r in resources:\n        if r.resource_type != \"AWS::Cognito::UserPool\":\n            continue\n        props = r.properties\n        name = props.get(\"UserPoolName\", r.logical_id)\n        if isinstance(name, dict):\n            name = str(resolver.resolve(name))\n        auto_confirm = True\n        lambda_config = props.get(\"LambdaConfig\", {})\n        pre_auth = lambda_config.get(\"PreAuthentication\")\n        if isinstance(pre_auth, dict):\n            pre_auth = str(resolver.resolve(pre_auth))\n        post_confirm = lambda_config.get(\"PostConfirmation\")\n        if isinstance(post_confirm, dict):\n            post_confirm = str(resolver.resolve(post_confirm))\n        pw_policy = props.get(\"Policies\", {}).get(\"PasswordPolicy\", {})\n        client_id = client_map.get(r.logical_id, \"\")\n        pools.append(\n            CognitoUserPool(\n                logical_id=r.logical_id,\n                user_pool_name=name,\n                auto_confirm=auto_confirm,\n                password_policy=pw_policy,\n                pre_auth_trigger=pre_auth,\n                post_confirm_trigger=post_confirm,\n                client_id=client_id,\n            )\n        )\n    return pools\n\n\ndef _collect_ecs_services(template: dict) -> list:\n    \"\"\"Extract ECS services from the raw CloudFormation template.\"\"\"\n    try:\n        from lws.providers.ecs.provider import parse_ecs_resources\n\n        return parse_ecs_resources(template)\n    except Exception:\n        logger.debug(\"Could not parse ECS resources\", exc_info=True)\n        return []\n","structuredPatch":[{"oldStart":272,"oldLines":6,"newStart":272,"newLines":8,"lines":["     model.event_rules.extend(_collect_event_rules(resources, resolver))","     model.state_machines.extend(_collect_state_machines(resources, resolver))","     model.user_pools.extend(_collect_user_pools(resources, resolver))","+    model.ssm_parameters.extend(_collect_ssm_parameters(resources, resolver))","+    model.secrets.extend(_collect_secrets(resources, resolver))"," ","     # ECS needs the raw template dict","     with open(template_path, encoding=\"utf-8\") as fh:"]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"0a09fb3a-0a9f-4b64-9ba0-ce209bf76351"}
{"parentUuid":"68203ff2-c0b3-4dcb-8112-19b7f8e8bda3","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","message":{"model":"claude-opus-4-6","id":"msg_01E9MbRvW99fH8wW7FHt8oPn","type":"message","role":"assistant","content":[{"type":"text","text":"Now add the collector functions at the end of the file, before `_collect_ecs_services`:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":308,"cache_read_input_tokens":66886,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":308},"output_tokens":4,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CY1FGP7uMneeBQkccJL12","type":"assistant","uuid":"f3170ab8-4963-4f42-9778-08f2f90cf6ce","timestamp":"2026-02-10T23:21:18.014Z"}
{"parentUuid":"f3170ab8-4963-4f42-9778-08f2f90cf6ce","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","message":{"model":"claude-opus-4-6","id":"msg_01E9MbRvW99fH8wW7FHt8oPn","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01GYB6K3apvjJpmB7L3NXhq7","name":"Edit","input":{"replace_all":false,"file_path":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services/src/lws/parser/assembly.py","old_string":"def _collect_ecs_services(template: dict) -> list:","new_string":"def _collect_ssm_parameters(\n    resources: list[CfnResource],\n    resolver: RefResolver,\n) -> list[SsmParameter]:\n    \"\"\"Extract SSM parameters from parsed CloudFormation resources.\"\"\"\n    parameters: list[SsmParameter] = []\n    for r in resources:\n        if r.resource_type != \"AWS::SSM::Parameter\":\n            continue\n        props = r.properties\n        name = props.get(\"Name\", r.logical_id)\n        if isinstance(name, dict):\n            name = str(resolver.resolve(name))\n        param_type = props.get(\"Type\", \"String\")\n        value = props.get(\"Value\", \"\")\n        if isinstance(value, dict):\n            value = str(resolver.resolve(value))\n        description = props.get(\"Description\", \"\")\n        parameters.append(\n            SsmParameter(name=name, type=param_type, value=value, description=description)\n        )\n    return parameters\n\n\ndef _collect_secrets(\n    resources: list[CfnResource],\n    resolver: RefResolver,\n) -> list[SmSecret]:\n    \"\"\"Extract Secrets Manager secrets from parsed CloudFormation resources.\"\"\"\n    secrets: list[SmSecret] = []\n    for r in resources:\n        if r.resource_type != \"AWS::SecretsManager::Secret\":\n            continue\n        props = r.properties\n        name = props.get(\"Name\", r.logical_id)\n        if isinstance(name, dict):\n            name = str(resolver.resolve(name))\n        description = props.get(\"Description\", \"\")\n        secret_string = props.get(\"SecretString\")\n        if secret_string is None:\n            # Try GenerateSecretString.SecretStringTemplate\n            gen = props.get(\"GenerateSecretString\", {})\n            if isinstance(gen, dict):\n                secret_string = gen.get(\"SecretStringTemplate\")\n        if isinstance(secret_string, dict):\n            secret_string = str(resolver.resolve(secret_string))\n        secrets.append(SmSecret(name=name, description=description, secret_string=secret_string))\n    return secrets\n\n\ndef _collect_ecs_services(template: dict) -> list:"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":308,"cache_read_input_tokens":66886,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":308},"output_tokens":4,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CY1FGP7uMneeBQkccJL12","type":"assistant","uuid":"bd6958bc-177c-40ff-b322-604d7a8bd491","timestamp":"2026-02-10T23:21:24.476Z"}
{"parentUuid":"bd6958bc-177c-40ff-b322-604d7a8bd491","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"callback"},"parentToolUseID":"toolu_01GYB6K3apvjJpmB7L3NXhq7","toolUseID":"toolu_01GYB6K3apvjJpmB7L3NXhq7","timestamp":"2026-02-10T23:21:24.481Z","uuid":"de731553-5006-4710-b448-a78885fe3e71"}
{"parentUuid":"bd6958bc-177c-40ff-b322-604d7a8bd491","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01GYB6K3apvjJpmB7L3NXhq7","type":"tool_result","content":"The file /Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services/src/lws/parser/assembly.py has been updated successfully."}]},"uuid":"476ca3e5-4ffe-45aa-a328-4cfdb4ef7af5","timestamp":"2026-02-10T23:21:24.480Z","toolUseResult":{"filePath":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services/src/lws/parser/assembly.py","oldString":"def _collect_ecs_services(template: dict) -> list:","newString":"def _collect_ssm_parameters(\n    resources: list[CfnResource],\n    resolver: RefResolver,\n) -> list[SsmParameter]:\n    \"\"\"Extract SSM parameters from parsed CloudFormation resources.\"\"\"\n    parameters: list[SsmParameter] = []\n    for r in resources:\n        if r.resource_type != \"AWS::SSM::Parameter\":\n            continue\n        props = r.properties\n        name = props.get(\"Name\", r.logical_id)\n        if isinstance(name, dict):\n            name = str(resolver.resolve(name))\n        param_type = props.get(\"Type\", \"String\")\n        value = props.get(\"Value\", \"\")\n        if isinstance(value, dict):\n            value = str(resolver.resolve(value))\n        description = props.get(\"Description\", \"\")\n        parameters.append(\n            SsmParameter(name=name, type=param_type, value=value, description=description)\n        )\n    return parameters\n\n\ndef _collect_secrets(\n    resources: list[CfnResource],\n    resolver: RefResolver,\n) -> list[SmSecret]:\n    \"\"\"Extract Secrets Manager secrets from parsed CloudFormation resources.\"\"\"\n    secrets: list[SmSecret] = []\n    for r in resources:\n        if r.resource_type != \"AWS::SecretsManager::Secret\":\n            continue\n        props = r.properties\n        name = props.get(\"Name\", r.logical_id)\n        if isinstance(name, dict):\n            name = str(resolver.resolve(name))\n        description = props.get(\"Description\", \"\")\n        secret_string = props.get(\"SecretString\")\n        if secret_string is None:\n            # Try GenerateSecretString.SecretStringTemplate\n            gen = props.get(\"GenerateSecretString\", {})\n            if isinstance(gen, dict):\n                secret_string = gen.get(\"SecretStringTemplate\")\n        if isinstance(secret_string, dict):\n            secret_string = str(resolver.resolve(secret_string))\n        secrets.append(SmSecret(name=name, description=description, secret_string=secret_string))\n    return secrets\n\n\ndef _collect_ecs_services(template: dict) -> list:","originalFile":"\"\"\"Assembly orchestrator -- top-level entry point for CDK output parsing.\n\nTies together tree parsing, template parsing, reference resolution and\nasset location to produce a single ``AppModel`` that the rest of the\nsystem can consume.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport json\nimport logging\nfrom dataclasses import dataclass, field\nfrom pathlib import Path\nfrom typing import Any\n\nfrom lws.parser.asset_parser import parse_assets\nfrom lws.parser.ref_resolver import RefResolver\nfrom lws.parser.template_parser import (\n    CfnResource,\n    extract_api_routes,\n    extract_dynamo_tables,\n    extract_lambda_functions,\n    parse_template,\n)\nfrom lws.parser.tree_parser import parse_tree\n\nlogger = logging.getLogger(__name__)\n\n# ---------------------------------------------------------------------------\n# Domain model dataclasses\n# ---------------------------------------------------------------------------\n\n\n@dataclass\nclass LambdaFunction:\n    \"\"\"Parsed Lambda function ready for local execution.\"\"\"\n\n    name: str\n    handler: str\n    runtime: str\n    code_path: Path | None = None\n    timeout: int = 30\n    memory: int = 128\n    environment: dict[str, str] = field(default_factory=dict)\n\n    @property\n    def logical_id(self) -> str:\n        return self.name\n\n\n@dataclass\nclass DynamoTable:\n    \"\"\"Parsed DynamoDB table definition.\"\"\"\n\n    name: str\n    key_schema: list[dict[str, str]] = field(default_factory=list)\n    gsi_definitions: list[dict[str, Any]] = field(default_factory=list)\n\n    @property\n    def logical_id(self) -> str:\n        return self.name\n\n    @property\n    def table_name(self) -> str:\n        return self.name\n\n\n@dataclass\nclass ApiRoute:\n    \"\"\"A single API Gateway route.\"\"\"\n\n    method: str\n    path: str\n    handler_name: str | None = None\n\n\n@dataclass\nclass ApiDefinition:\n    \"\"\"A collection of routes making up an API.\"\"\"\n\n    name: str = \"default\"\n    routes: list[ApiRoute] = field(default_factory=list)\n\n    @property\n    def logical_id(self) -> str:\n        return self.name\n\n\n@dataclass\nclass SqsQueue:\n    \"\"\"Parsed SQS queue definition.\"\"\"\n\n    name: str\n    is_fifo: bool = False\n    visibility_timeout: int = 30\n    content_based_dedup: bool = False\n    redrive_target: str | None = None\n    max_receive_count: int = 5\n\n\n@dataclass\nclass S3Bucket:\n    \"\"\"Parsed S3 bucket definition.\"\"\"\n\n    name: str\n\n\n@dataclass\nclass SnsTopic:\n    \"\"\"Parsed SNS topic definition.\"\"\"\n\n    name: str\n    topic_arn: str = \"\"\n\n\n@dataclass\nclass EventBus:\n    \"\"\"Parsed EventBridge event bus definition.\"\"\"\n\n    name: str\n    bus_arn: str = \"\"\n\n\n@dataclass\nclass EventRule:\n    \"\"\"Parsed EventBridge rule definition.\"\"\"\n\n    rule_name: str\n    event_bus_name: str = \"default\"\n    event_pattern: dict[str, Any] | None = None\n    schedule_expression: str | None = None\n    targets: list[dict[str, Any]] = field(default_factory=list)\n\n\n@dataclass\nclass StateMachine:\n    \"\"\"Parsed Step Functions state machine definition.\"\"\"\n\n    name: str\n    definition: str | dict[str, Any] = \"\"\n    workflow_type: str = \"STANDARD\"\n    role_arn: str = \"\"\n    definition_substitutions: dict[str, str] = field(default_factory=dict)\n\n\n@dataclass\nclass CognitoUserPool:\n    \"\"\"Parsed Cognito user pool definition.\"\"\"\n\n    logical_id: str\n    user_pool_name: str = \"default\"\n    auto_confirm: bool = True\n    password_policy: dict[str, Any] = field(default_factory=dict)\n    pre_auth_trigger: str | None = None\n    post_confirm_trigger: str | None = None\n    client_id: str = \"\"\n\n\n@dataclass\nclass SsmParameter:\n    \"\"\"Parsed SSM Parameter Store parameter.\"\"\"\n\n    name: str\n    type: str  # \"String\", \"StringList\", \"SecureString\"\n    value: str\n    description: str = \"\"\n\n\n@dataclass\nclass SmSecret:\n    \"\"\"Parsed Secrets Manager secret.\"\"\"\n\n    name: str\n    description: str = \"\"\n    secret_string: str | None = None\n\n\n@dataclass\nclass AppModel:\n    \"\"\"Complete parsed representation of a CDK application.\"\"\"\n\n    functions: list[LambdaFunction] = field(default_factory=list)\n    tables: list[DynamoTable] = field(default_factory=list)\n    apis: list[ApiDefinition] = field(default_factory=list)\n    queues: list[SqsQueue] = field(default_factory=list)\n    buckets: list[S3Bucket] = field(default_factory=list)\n    topics: list[SnsTopic] = field(default_factory=list)\n    event_buses: list[EventBus] = field(default_factory=list)\n    event_rules: list[EventRule] = field(default_factory=list)\n    state_machines: list[StateMachine] = field(default_factory=list)\n    user_pools: list[CognitoUserPool] = field(default_factory=list)\n    ecs_services: list[Any] = field(default_factory=list)\n    ssm_parameters: list[SsmParameter] = field(default_factory=list)\n    secrets: list[SmSecret] = field(default_factory=list)\n\n\n# ---------------------------------------------------------------------------\n# Orchestrator\n# ---------------------------------------------------------------------------\n\n\ndef parse_assembly(cdk_out_path: Path) -> AppModel:\n    \"\"\"Parse an entire CDK ``cdk.out`` directory into an :class:`AppModel`.\n\n    Parameters\n    ----------\n    cdk_out_path:\n        Path to the ``cdk.out`` directory produced by ``cdk synth``.\n\n    Returns\n    -------\n    AppModel\n    \"\"\"\n    manifest_path = cdk_out_path / \"manifest.json\"\n    if not manifest_path.exists():\n        logger.warning(\"No manifest.json found in %s\", cdk_out_path)\n        return AppModel()\n\n    with open(manifest_path, encoding=\"utf-8\") as fh:\n        manifest = json.load(fh)\n\n    # Parse assets (hash -> filesystem path)\n    asset_map = parse_assets(cdk_out_path)\n\n    # Parse tree.json if present\n    tree_path = cdk_out_path / \"tree.json\"\n    if tree_path.exists():\n        parse_tree(tree_path)  # Currently used for validation; future enrichment\n\n    # Collect all stack artifacts\n    model = AppModel()\n    for artifact_id, artifact in (manifest.get(\"artifacts\") or {}).items():\n        if artifact.get(\"type\") != \"aws:cloudformation:stack\":\n            continue\n        _process_stack(cdk_out_path, artifact_id, artifact, asset_map, model)\n\n    return model\n\n\ndef _process_stack(\n    cdk_out_path: Path,\n    artifact_id: str,\n    artifact: dict,\n    asset_map: dict[str, Path],\n    model: AppModel,\n) -> None:\n    \"\"\"Process a single CloudFormation stack artifact.\"\"\"\n    template_file = artifact.get(\"properties\", {}).get(\"templateFile\")\n    if not template_file:\n        logger.warning(\"Stack %s has no templateFile\", artifact_id)\n        return\n\n    template_path = cdk_out_path / template_file\n    if not template_path.exists():\n        logger.warning(\"Template not found: %s\", template_path)\n        return\n\n    resources = parse_template(template_path)\n    resource_type_map = {r.logical_id: r.resource_type for r in resources}\n    resource_map = _build_resource_map(resources)\n    resolver = RefResolver(resource_map=resource_map, resource_types=resource_type_map)\n\n    model.functions.extend(_collect_lambdas(resources, asset_map, cdk_out_path, resolver))\n    model.tables.extend(_collect_tables(resources, resolver))\n    api_def = _collect_api_routes(resources, resolver, artifact_id)\n    if api_def:\n        model.apis.append(api_def)\n    model.queues.extend(_collect_queues(resources, resolver))\n    model.buckets.extend(_collect_buckets(resources))\n    model.topics.extend(_collect_topics(resources, resolver))\n    model.event_buses.extend(_collect_event_buses(resources, resolver))\n    model.event_rules.extend(_collect_event_rules(resources, resolver))\n    model.state_machines.extend(_collect_state_machines(resources, resolver))\n    model.user_pools.extend(_collect_user_pools(resources, resolver))\n    model.ssm_parameters.extend(_collect_ssm_parameters(resources, resolver))\n    model.secrets.extend(_collect_secrets(resources, resolver))\n\n    # ECS needs the raw template dict\n    with open(template_path, encoding=\"utf-8\") as fh:\n        raw_template = json.load(fh)\n    ecs_services = _collect_ecs_services(raw_template)\n    model.ecs_services.extend(ecs_services)\n\n\ndef _build_resource_map(resources: list[CfnResource]) -> dict[str, str]:\n    \"\"\"Build a Ref resource_map so intrinsic ``Ref`` calls resolve to useful local values.\n\n    In real CloudFormation:\n    - ``Ref`` on an ``AWS::SQS::Queue`` returns the queue URL.\n    - ``Ref`` on an ``AWS::DynamoDB::Table`` returns the table name.\n\n    We reproduce this behaviour with deterministic local placeholders so that\n    Lambda environment variables like ``QUEUE_URL`` and ``TABLE_NAME`` resolve\n    to values the local providers can understand.\n    \"\"\"\n    resource_map: dict[str, str] = {}\n    for r in resources:\n        if r.resource_type == \"AWS::SQS::Queue\":\n            queue_name = r.properties.get(\"QueueName\", r.logical_id)\n            if isinstance(queue_name, str):\n                # Use ARN format so the SDK connects via AWS_ENDPOINT_URL_SQS\n                # rather than trying to resolve the QueueUrl as a hostname.\n                resource_map[r.logical_id] = f\"arn:ldk:sqs:local:000000000000:queue/{queue_name}\"\n        elif r.resource_type == \"AWS::DynamoDB::Table\":\n            # Ref returns the table name.\n            table_name = r.properties.get(\"TableName\", r.logical_id)\n            if isinstance(table_name, str):\n                resource_map[r.logical_id] = table_name\n        elif r.resource_type == \"AWS::S3::Bucket\":\n            # Ref returns the bucket name.\n            bucket_name = r.properties.get(\"BucketName\", r.logical_id)\n            if isinstance(bucket_name, str):\n                resource_map[r.logical_id] = bucket_name\n            else:\n                resource_map[r.logical_id] = r.logical_id\n        elif r.resource_type == \"AWS::SNS::Topic\":\n            # Ref returns the topic ARN.\n            topic_name = r.properties.get(\"TopicName\", r.logical_id)\n            if isinstance(topic_name, str):\n                resource_map[r.logical_id] = f\"arn:ldk:sns:local:000000000000:{topic_name}\"\n        elif r.resource_type == \"AWS::SSM::Parameter\":\n            name = r.properties.get(\"Name\", r.logical_id)\n            if isinstance(name, str):\n                resource_map[r.logical_id] = name\n        elif r.resource_type == \"AWS::SecretsManager::Secret\":\n            name = r.properties.get(\"Name\", r.logical_id)\n            if isinstance(name, str):\n                resource_map[r.logical_id] = (\n                    f\"arn:aws:secretsmanager:us-east-1:000000000000:secret:{name}\"\n                )\n    return resource_map\n\n\ndef _collect_lambdas(\n    resources: list[CfnResource],\n    asset_map: dict[str, Path],\n    cdk_out_path: Path,\n    resolver: RefResolver,\n) -> list[LambdaFunction]:\n    \"\"\"Extract Lambda functions from parsed CloudFormation resources.\"\"\"\n    functions: list[LambdaFunction] = []\n    lambda_props_list = extract_lambda_functions(resources)\n    lambda_resources = [r for r in resources if r.resource_type == \"AWS::Lambda::Function\"]\n    for r, props in zip(lambda_resources, lambda_props_list):\n        code_path = _resolve_code_path(props.code_uri, asset_map, cdk_out_path, resolver)\n        env = {k: str(resolver.resolve(v)) for k, v in props.environment.items()}\n        functions.append(\n            LambdaFunction(\n                name=r.logical_id,\n                handler=props.handler or \"index.handler\",\n                runtime=props.runtime or \"python3.11\",\n                code_path=code_path,\n                timeout=props.timeout or 30,\n                memory=props.memory_size or 128,\n                environment=env,\n            )\n        )\n    return functions\n\n\ndef _collect_tables(\n    resources: list[CfnResource],\n    resolver: RefResolver,\n) -> list[DynamoTable]:\n    \"\"\"Extract DynamoDB tables from parsed CloudFormation resources.\"\"\"\n    tables: list[DynamoTable] = []\n    dynamo_props_list = extract_dynamo_tables(resources)\n    dynamo_resources = [r for r in resources if r.resource_type == \"AWS::DynamoDB::Table\"]\n    for r, props in zip(dynamo_resources, dynamo_props_list):\n        name = props.table_name or r.logical_id\n        if isinstance(name, dict):\n            name = str(resolver.resolve(name))\n        tables.append(\n            DynamoTable(\n                name=name,\n                key_schema=props.key_schema,\n                gsi_definitions=props.gsi_definitions,\n            )\n        )\n    return tables\n\n\ndef _collect_api_routes(\n    resources: list[CfnResource],\n    resolver: RefResolver,\n    artifact_id: str,\n) -> ApiDefinition | None:\n    \"\"\"Extract API Gateway routes from parsed CloudFormation resources.\"\"\"\n    api_routes = extract_api_routes(resources)\n    if not api_routes:\n        return None\n    routes: list[ApiRoute] = []\n    for route_props in api_routes:\n        handler_name = _find_handler_for_integration(\n            route_props.integration_uri, resources, resolver\n        )\n        routes.append(\n            ApiRoute(\n                method=route_props.http_method or \"ANY\",\n                path=route_props.resource_path or \"/\",\n                handler_name=handler_name,\n            )\n        )\n    return ApiDefinition(name=artifact_id, routes=routes)\n\n\ndef _resolve_code_from_s3_key(s3_key: str, asset_map: dict[str, Path]) -> Path | None:\n    \"\"\"Try to match an S3Key to an asset by hash.\"\"\"\n    asset_hash = s3_key.replace(\".zip\", \"\")\n    if asset_hash in asset_map:\n        return asset_map[asset_hash]\n    for hash_key, path in asset_map.items():\n        if hash_key in s3_key:\n            return path\n    return None\n\n\ndef _resolve_code_from_s3_bucket(\n    s3_bucket: dict, resolver: RefResolver, asset_map: dict[str, Path]\n) -> Path | None:\n    \"\"\"Try to match an S3Bucket ref to an asset.\"\"\"\n    resolved = str(resolver.resolve(s3_bucket))\n    for h, p in asset_map.items():\n        if h in resolved:\n            return p\n    return None\n\n\ndef _resolve_code_path(\n    code_uri: Any,\n    asset_map: dict[str, Path],\n    cdk_out_path: Path,\n    resolver: RefResolver,\n) -> Path | None:\n    \"\"\"Resolve a Lambda Code property to a local filesystem path.\"\"\"\n    if code_uri is None:\n        return None\n\n    if isinstance(code_uri, dict):\n        s3_key = code_uri.get(\"S3Key\")\n        if isinstance(s3_key, str):\n            result = _resolve_code_from_s3_key(s3_key, asset_map)\n            if result:\n                return result\n\n        s3_bucket = code_uri.get(\"S3Bucket\")\n        if isinstance(s3_bucket, dict):\n            result = _resolve_code_from_s3_bucket(s3_bucket, resolver, asset_map)\n            if result:\n                return result\n\n    if isinstance(code_uri, str):\n        candidate = cdk_out_path / code_uri\n        if candidate.exists():\n            return candidate\n\n    return None\n\n\ndef _find_handler_for_integration(\n    integration_uri: Any,\n    resources: list[CfnResource],\n    resolver: RefResolver,\n) -> str | None:\n    \"\"\"Try to match an API integration URI back to a Lambda logical ID.\"\"\"\n    if integration_uri is None:\n        return None\n\n    resolved = str(resolver.resolve(integration_uri))\n\n    # Look for a Lambda function logical ID in the resolved string\n    for r in resources:\n        if r.resource_type == \"AWS::Lambda::Function\":\n            if r.logical_id in resolved:\n                return r.logical_id\n\n    return None\n\n\n# ---------------------------------------------------------------------------\n# Collectors for new resource types\n# ---------------------------------------------------------------------------\n\n\ndef _collect_queues(\n    resources: list[CfnResource],\n    resolver: RefResolver,\n) -> list[SqsQueue]:\n    \"\"\"Extract SQS queues from parsed CloudFormation resources.\"\"\"\n    queues: list[SqsQueue] = []\n    for r in resources:\n        if r.resource_type != \"AWS::SQS::Queue\":\n            continue\n        props = r.properties\n        name = props.get(\"QueueName\", r.logical_id)\n        if isinstance(name, dict):\n            name = str(resolver.resolve(name))\n        is_fifo = bool(props.get(\"FifoQueue\", False))\n        vis = int(props.get(\"VisibilityTimeout\", 30))\n        dedup = bool(props.get(\"ContentBasedDeduplication\", False))\n        redrive = props.get(\"RedrivePolicy\")\n        redrive_target = None\n        max_receive = 5\n        if isinstance(redrive, dict):\n            dlq = redrive.get(\"deadLetterTargetArn\", \"\")\n            if isinstance(dlq, dict):\n                dlq = str(resolver.resolve(dlq))\n            redrive_target = str(dlq) if dlq else None\n            max_receive = int(redrive.get(\"maxReceiveCount\", 5))\n        queues.append(\n            SqsQueue(\n                name=name,\n                is_fifo=is_fifo,\n                visibility_timeout=vis,\n                content_based_dedup=dedup,\n                redrive_target=redrive_target,\n                max_receive_count=max_receive,\n            )\n        )\n    return queues\n\n\ndef _collect_buckets(resources: list[CfnResource]) -> list[S3Bucket]:\n    \"\"\"Extract S3 buckets from parsed CloudFormation resources.\"\"\"\n    buckets: list[S3Bucket] = []\n    for r in resources:\n        if r.resource_type != \"AWS::S3::Bucket\":\n            continue\n        name = r.properties.get(\"BucketName\", r.logical_id)\n        if isinstance(name, dict):\n            name = r.logical_id  # Can't resolve intrinsics for bucket names easily\n        buckets.append(S3Bucket(name=name))\n    return buckets\n\n\ndef _collect_topics(\n    resources: list[CfnResource],\n    resolver: RefResolver,\n) -> list[SnsTopic]:\n    \"\"\"Extract SNS topics from parsed CloudFormation resources.\"\"\"\n    topics: list[SnsTopic] = []\n    for r in resources:\n        if r.resource_type != \"AWS::SNS::Topic\":\n            continue\n        props = r.properties\n        name = props.get(\"TopicName\", r.logical_id)\n        if isinstance(name, dict):\n            name = str(resolver.resolve(name))\n        arn = f\"arn:aws:sns:us-east-1:000000000000:{name}\"\n        topics.append(SnsTopic(name=name, topic_arn=arn))\n    return topics\n\n\ndef _collect_event_buses(\n    resources: list[CfnResource],\n    resolver: RefResolver,\n) -> list[EventBus]:\n    \"\"\"Extract EventBridge event buses from parsed CloudFormation resources.\"\"\"\n    buses: list[EventBus] = []\n    for r in resources:\n        if r.resource_type != \"AWS::Events::EventBus\":\n            continue\n        props = r.properties\n        name = props.get(\"Name\", r.logical_id)\n        if isinstance(name, dict):\n            name = str(resolver.resolve(name))\n        arn = f\"arn:aws:events:us-east-1:000000000000:event-bus/{name}\"\n        buses.append(EventBus(name=name, bus_arn=arn))\n    return buses\n\n\ndef _collect_event_rules(\n    resources: list[CfnResource],\n    resolver: RefResolver,\n) -> list[EventRule]:\n    \"\"\"Extract EventBridge rules from parsed CloudFormation resources.\"\"\"\n    rules: list[EventRule] = []\n    for r in resources:\n        if r.resource_type != \"AWS::Events::Rule\":\n            continue\n        props = r.properties\n        rule_name = props.get(\"Name\", r.logical_id)\n        if isinstance(rule_name, dict):\n            rule_name = str(resolver.resolve(rule_name))\n        bus_name = props.get(\"EventBusName\", \"default\")\n        if isinstance(bus_name, dict):\n            bus_name = str(resolver.resolve(bus_name))\n        pattern = props.get(\"EventPattern\")\n        schedule = props.get(\"ScheduleExpression\")\n        raw_targets = props.get(\"Targets\", [])\n        targets: list[dict[str, Any]] = []\n        for t in raw_targets:\n            target_arn = t.get(\"Arn\", \"\")\n            if isinstance(target_arn, dict):\n                target_arn = str(resolver.resolve(target_arn))\n            targets.append(\n                {\n                    \"target_id\": t.get(\"Id\", \"\"),\n                    \"arn\": target_arn,\n                    \"input_path\": t.get(\"InputPath\"),\n                    \"input_template\": t.get(\"InputTransformer\", {}).get(\"InputTemplate\"),\n                }\n            )\n        rules.append(\n            EventRule(\n                rule_name=rule_name,\n                event_bus_name=bus_name,\n                event_pattern=pattern,\n                schedule_expression=schedule,\n                targets=targets,\n            )\n        )\n    return rules\n\n\ndef _resolve_sm_definition(definition: Any, resolver: RefResolver) -> Any:\n    \"\"\"Resolve a Step Functions DefinitionString that may use intrinsic functions.\"\"\"\n    if isinstance(definition, dict):\n        return resolver.resolve(definition)\n    return definition\n\n\ndef _resolve_substitutions(subs: dict[str, Any], resolver: RefResolver) -> dict[str, str]:\n    \"\"\"Resolve CloudFormation DefinitionSubstitutions to plain strings.\"\"\"\n    return {k: str(resolver.resolve(v)) if isinstance(v, dict) else str(v) for k, v in subs.items()}\n\n\ndef _collect_state_machines(\n    resources: list[CfnResource],\n    resolver: RefResolver,\n) -> list[StateMachine]:\n    \"\"\"Extract Step Functions state machines from parsed CloudFormation resources.\"\"\"\n    machines: list[StateMachine] = []\n    for r in resources:\n        if r.resource_type != \"AWS::StepFunctions::StateMachine\":\n            continue\n        props = r.properties\n        name = props.get(\"StateMachineName\", r.logical_id)\n        if isinstance(name, dict):\n            name = str(resolver.resolve(name))\n        definition = props.get(\"DefinitionString\", props.get(\"Definition\", \"\"))\n        definition = _resolve_sm_definition(definition, resolver)\n        role_arn = props.get(\"RoleArn\", \"\")\n        if isinstance(role_arn, dict):\n            role_arn = str(resolver.resolve(role_arn))\n        resolved_subs = _resolve_substitutions(props.get(\"DefinitionSubstitutions\", {}), resolver)\n        machines.append(\n            StateMachine(\n                name=name,\n                definition=definition,\n                workflow_type=props.get(\"StateMachineType\", \"STANDARD\"),\n                role_arn=role_arn,\n                definition_substitutions=resolved_subs,\n            )\n        )\n    return machines\n\n\ndef _collect_user_pools(\n    resources: list[CfnResource],\n    resolver: RefResolver,\n) -> list[CognitoUserPool]:\n    \"\"\"Extract Cognito user pools from parsed CloudFormation resources.\"\"\"\n    pools: list[CognitoUserPool] = []\n    # First pass: collect user pool clients to map pool -> client_id\n    client_map: dict[str, str] = {}\n    for r in resources:\n        if r.resource_type != \"AWS::Cognito::UserPoolClient\":\n            continue\n        pool_ref = r.properties.get(\"UserPoolId\", \"\")\n        if isinstance(pool_ref, dict):\n            pool_ref = str(resolver.resolve(pool_ref))\n        client_map[pool_ref] = r.logical_id\n\n    for r in resources:\n        if r.resource_type != \"AWS::Cognito::UserPool\":\n            continue\n        props = r.properties\n        name = props.get(\"UserPoolName\", r.logical_id)\n        if isinstance(name, dict):\n            name = str(resolver.resolve(name))\n        auto_confirm = True\n        lambda_config = props.get(\"LambdaConfig\", {})\n        pre_auth = lambda_config.get(\"PreAuthentication\")\n        if isinstance(pre_auth, dict):\n            pre_auth = str(resolver.resolve(pre_auth))\n        post_confirm = lambda_config.get(\"PostConfirmation\")\n        if isinstance(post_confirm, dict):\n            post_confirm = str(resolver.resolve(post_confirm))\n        pw_policy = props.get(\"Policies\", {}).get(\"PasswordPolicy\", {})\n        client_id = client_map.get(r.logical_id, \"\")\n        pools.append(\n            CognitoUserPool(\n                logical_id=r.logical_id,\n                user_pool_name=name,\n                auto_confirm=auto_confirm,\n                password_policy=pw_policy,\n                pre_auth_trigger=pre_auth,\n                post_confirm_trigger=post_confirm,\n                client_id=client_id,\n            )\n        )\n    return pools\n\n\ndef _collect_ecs_services(template: dict) -> list:\n    \"\"\"Extract ECS services from the raw CloudFormation template.\"\"\"\n    try:\n        from lws.providers.ecs.provider import parse_ecs_resources\n\n        return parse_ecs_resources(template)\n    except Exception:\n        logger.debug(\"Could not parse ECS resources\", exc_info=True)\n        return []\n","structuredPatch":[{"oldStart":703,"oldLines":6,"newStart":703,"newLines":56,"lines":["     return pools"," "," ","+def _collect_ssm_parameters(","+    resources: list[CfnResource],","+    resolver: RefResolver,","+) -> list[SsmParameter]:","+    \"\"\"Extract SSM parameters from parsed CloudFormation resources.\"\"\"","+    parameters: list[SsmParameter] = []","+    for r in resources:","+        if r.resource_type != \"AWS::SSM::Parameter\":","+            continue","+        props = r.properties","+        name = props.get(\"Name\", r.logical_id)","+        if isinstance(name, dict):","+            name = str(resolver.resolve(name))","+        param_type = props.get(\"Type\", \"String\")","+        value = props.get(\"Value\", \"\")","+        if isinstance(value, dict):","+            value = str(resolver.resolve(value))","+        description = props.get(\"Description\", \"\")","+        parameters.append(","+            SsmParameter(name=name, type=param_type, value=value, description=description)","+        )","+    return parameters","+","+","+def _collect_secrets(","+    resources: list[CfnResource],","+    resolver: RefResolver,","+) -> list[SmSecret]:","+    \"\"\"Extract Secrets Manager secrets from parsed CloudFormation resources.\"\"\"","+    secrets: list[SmSecret] = []","+    for r in resources:","+        if r.resource_type != \"AWS::SecretsManager::Secret\":","+            continue","+        props = r.properties","+        name = props.get(\"Name\", r.logical_id)","+        if isinstance(name, dict):","+            name = str(resolver.resolve(name))","+        description = props.get(\"Description\", \"\")","+        secret_string = props.get(\"SecretString\")","+        if secret_string is None:","+            # Try GenerateSecretString.SecretStringTemplate","+            gen = props.get(\"GenerateSecretString\", {})","+            if isinstance(gen, dict):","+                secret_string = gen.get(\"SecretStringTemplate\")","+        if isinstance(secret_string, dict):","+            secret_string = str(resolver.resolve(secret_string))","+        secrets.append(SmSecret(name=name, description=description, secret_string=secret_string))","+    return secrets","+","+"," def _collect_ecs_services(template: dict) -> list:","     \"\"\"Extract ECS services from the raw CloudFormation template.\"\"\"","     try:"]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"bd6958bc-177c-40ff-b322-604d7a8bd491"}
{"parentUuid":"476ca3e5-4ffe-45aa-a328-4cfdb4ef7af5","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","message":{"model":"claude-opus-4-6","id":"msg_019L181qgdc9XK82XPjjr9Ga","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01VpbrLJR2nC5azjaYkE47ec","name":"TaskUpdate","input":{"taskId":"1","status":"completed"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":760,"cache_read_input_tokens":67194,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":760},"output_tokens":26,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CY1FH2aAKfLs8kBXKZ1RH","type":"assistant","uuid":"3c58265f-6582-4ee7-98e8-96c5e588ecdd","timestamp":"2026-02-10T23:21:28.553Z"}
{"parentUuid":"3c58265f-6582-4ee7-98e8-96c5e588ecdd","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01VpbrLJR2nC5azjaYkE47ec","type":"tool_result","content":"Updated task #1 status"}]},"uuid":"9a9bce6a-d6e9-40de-99b9-147e64d7341b","timestamp":"2026-02-10T23:21:28.559Z","toolUseResult":{"success":true,"taskId":"1","updatedFields":["status"],"statusChange":{"from":"in_progress","to":"completed"}},"sourceToolAssistantUUID":"3c58265f-6582-4ee7-98e8-96c5e588ecdd"}
{"parentUuid":"9a9bce6a-d6e9-40de-99b9-147e64d7341b","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","message":{"model":"claude-opus-4-6","id":"msg_01VR2JM5V6q2wEifeQpaHD52","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01JjDCpHXWYLNhdF1gtFKHMs","name":"TaskUpdate","input":{"taskId":"2","status":"in_progress"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":88,"cache_read_input_tokens":67954,"output_tokens":72,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":88,"ephemeral_5m_input_tokens":0},"inference_geo":"","iterations":[]}},"requestId":"req_011CY1FHK6LPYAbfbdsxRJRg","type":"assistant","uuid":"50f1410e-8f5e-40ae-afe6-7e5a296ec84d","timestamp":"2026-02-10T23:21:31.775Z"}
{"parentUuid":"50f1410e-8f5e-40ae-afe6-7e5a296ec84d","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01JjDCpHXWYLNhdF1gtFKHMs","type":"tool_result","content":"Updated task #2 status"}]},"uuid":"286c6750-c04c-4a94-b942-615d36b93f54","timestamp":"2026-02-10T23:21:31.779Z","toolUseResult":{"success":true,"taskId":"2","updatedFields":["status"],"statusChange":{"from":"pending","to":"in_progress"}},"sourceToolAssistantUUID":"50f1410e-8f5e-40ae-afe6-7e5a296ec84d"}
{"type":"file-history-snapshot","messageId":"3d0f7635-23f1-467b-ba9e-50ea361d7a05","snapshot":{"messageId":"419d76bc-01da-47ab-8292-f6cf09dd2274","trackedFileBackups":{"src/lws/parser/assembly.py":{"backupFileName":"00df020cf1c04e6c@v1","version":1,"backupTime":"2026-02-10T23:21:01.336Z"},"src/lws/parser/tree_parser.py":{"backupFileName":"65fa9421a5a90c00@v1","version":1,"backupTime":"2026-02-10T23:21:36.827Z"}},"timestamp":"2026-02-10T23:20:18.621Z"},"isSnapshotUpdate":true}
{"parentUuid":"286c6750-c04c-4a94-b942-615d36b93f54","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","message":{"model":"claude-opus-4-6","id":"msg_01C8JQSCtnYpvKqkwHGQcDMb","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01HdCAzPaLe41QtG6S6Zv3cu","name":"Edit","input":{"replace_all":false,"file_path":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services/src/lws/parser/tree_parser.py","old_string":"    \"aws-cdk-lib.aws_stepfunctions.StateMachine\": \"stepfunctions\",\n    \"aws-cdk-lib.aws_events.Rule\": \"events\",\n}","new_string":"    \"aws-cdk-lib.aws_stepfunctions.StateMachine\": \"stepfunctions\",\n    \"aws-cdk-lib.aws_events.Rule\": \"events\",\n    \"aws-cdk-lib.aws_ssm.StringParameter\": \"ssm\",\n    \"aws-cdk-lib.aws_secretsmanager.Secret\": \"secretsmanager\",\n}"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":90,"cache_read_input_tokens":68042,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":90},"output_tokens":25,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CY1FHYfQqEp3Sv3P1qREF","type":"assistant","uuid":"3d0f7635-23f1-467b-ba9e-50ea361d7a05","timestamp":"2026-02-10T23:21:36.819Z"}
{"parentUuid":"3d0f7635-23f1-467b-ba9e-50ea361d7a05","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"callback"},"parentToolUseID":"toolu_01HdCAzPaLe41QtG6S6Zv3cu","toolUseID":"toolu_01HdCAzPaLe41QtG6S6Zv3cu","timestamp":"2026-02-10T23:21:36.831Z","uuid":"b50d3770-8495-42fb-8aa3-6b66580e38ec"}
{"parentUuid":"3d0f7635-23f1-467b-ba9e-50ea361d7a05","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01HdCAzPaLe41QtG6S6Zv3cu","type":"tool_result","content":"The file /Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services/src/lws/parser/tree_parser.py has been updated successfully."}]},"uuid":"5b34ca1a-e59e-4532-8deb-2ab361bf6f91","timestamp":"2026-02-10T23:21:36.830Z","toolUseResult":{"filePath":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services/src/lws/parser/tree_parser.py","oldString":"    \"aws-cdk-lib.aws_stepfunctions.StateMachine\": \"stepfunctions\",\n    \"aws-cdk-lib.aws_events.Rule\": \"events\",\n}","newString":"    \"aws-cdk-lib.aws_stepfunctions.StateMachine\": \"stepfunctions\",\n    \"aws-cdk-lib.aws_events.Rule\": \"events\",\n    \"aws-cdk-lib.aws_ssm.StringParameter\": \"ssm\",\n    \"aws-cdk-lib.aws_secretsmanager.Secret\": \"secretsmanager\",\n}","originalFile":"\"\"\"Parser for CDK tree.json files.\n\nWalks the construct tree and produces a flat/nested list of ConstructNode\ndataclasses that downstream stages use to correlate logical IDs with\nCDK-level metadata (FQN, resource category, etc.).\n\"\"\"\n\nfrom __future__ import annotations\n\nimport json\nimport logging\nfrom dataclasses import dataclass, field\nfrom pathlib import Path\n\nlogger = logging.getLogger(__name__)\n\n# ---------------------------------------------------------------------------\n# Known CDK FQN -> resource-category mapping\n# ---------------------------------------------------------------------------\nFQN_CATEGORY_MAP: dict[str, str] = {\n    \"aws-cdk-lib.aws_lambda.Function\": \"lambda\",\n    \"aws-cdk-lib.aws_lambda_nodejs.NodejsFunction\": \"lambda\",\n    \"aws-cdk-lib.aws_lambda_python_alpha.PythonFunction\": \"lambda\",\n    \"aws-cdk-lib.aws_dynamodb.Table\": \"dynamodb\",\n    \"aws-cdk-lib.aws_dynamodb.TableV2\": \"dynamodb\",\n    \"aws-cdk-lib.aws_apigateway.RestApi\": \"apigateway\",\n    \"aws-cdk-lib.aws_apigateway.LambdaRestApi\": \"apigateway\",\n    \"aws-cdk-lib.aws_apigatewayv2.HttpApi\": \"apigatewayv2\",\n    \"aws-cdk-lib.aws_apigatewayv2_alpha.HttpApi\": \"apigatewayv2\",\n    \"aws-cdk-lib.aws_s3.Bucket\": \"s3\",\n    \"aws-cdk-lib.aws_sqs.Queue\": \"sqs\",\n    \"aws-cdk-lib.aws_sns.Topic\": \"sns\",\n    \"aws-cdk-lib.aws_stepfunctions.StateMachine\": \"stepfunctions\",\n    \"aws-cdk-lib.aws_events.Rule\": \"events\",\n}\n\n\n@dataclass\nclass ConstructNode:\n    \"\"\"A node in the CDK construct tree.\"\"\"\n\n    path: str\n    id: str\n    fqn: str | None = None\n    children: list[ConstructNode] = field(default_factory=list)\n    cfn_type: str | None = None\n\n    @property\n    def category(self) -> str | None:\n        \"\"\"Return a human-friendly resource category derived from the FQN.\"\"\"\n        if self.fqn is not None:\n            return FQN_CATEGORY_MAP.get(self.fqn)\n        return None\n\n\ndef _walk_node(node_data: dict) -> ConstructNode:\n    \"\"\"Recursively convert a raw tree-JSON dict into a ConstructNode.\"\"\"\n    path = node_data.get(\"path\", \"\")\n    node_id = node_data.get(\"id\", \"\")\n\n    construct_info = node_data.get(\"constructInfo\", {})\n    fqn = construct_info.get(\"fqn\") if construct_info else None\n\n    # Some leaf nodes carry an AWS CloudFormation type directly\n    cfn_type = (\n        node_data.get(\"attributes\", {}).get(\"aws:cdk:cloudformation:type\")\n        if node_data.get(\"attributes\")\n        else None\n    )\n\n    children: list[ConstructNode] = []\n    for child_data in (node_data.get(\"children\") or {}).values():\n        children.append(_walk_node(child_data))\n\n    return ConstructNode(\n        path=path,\n        id=node_id,\n        fqn=fqn,\n        children=children,\n        cfn_type=cfn_type,\n    )\n\n\ndef parse_tree(tree_json_path: Path) -> list[ConstructNode]:\n    \"\"\"Parse a CDK ``tree.json`` and return top-level construct nodes.\n\n    Parameters\n    ----------\n    tree_json_path:\n        Absolute or relative path to the ``tree.json`` file emitted by\n        ``cdk synth``.\n\n    Returns\n    -------\n    list[ConstructNode]\n        The immediate children of the tree root (typically one node per\n        CDK stack).\n    \"\"\"\n    with open(tree_json_path, encoding=\"utf-8\") as fh:\n        data = json.load(fh)\n\n    tree_root = data.get(\"tree\", data)\n\n    children: list[ConstructNode] = []\n    for child_data in (tree_root.get(\"children\") or {}).values():\n        children.append(_walk_node(child_data))\n\n    return children\n","structuredPatch":[{"oldStart":32,"oldLines":6,"newStart":32,"newLines":8,"lines":["     \"aws-cdk-lib.aws_sns.Topic\": \"sns\",","     \"aws-cdk-lib.aws_stepfunctions.StateMachine\": \"stepfunctions\",","     \"aws-cdk-lib.aws_events.Rule\": \"events\",","+    \"aws-cdk-lib.aws_ssm.StringParameter\": \"ssm\",","+    \"aws-cdk-lib.aws_secretsmanager.Secret\": \"secretsmanager\","," }"," "," "]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"3d0f7635-23f1-467b-ba9e-50ea361d7a05"}
{"parentUuid":"5b34ca1a-e59e-4532-8deb-2ab361bf6f91","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","message":{"model":"claude-opus-4-6","id":"msg_01Wc22tRYDpur84aS3dVTmUb","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Y9J5QfuCYuboohtG6wXFj6","name":"TaskUpdate","input":{"taskId":"2","status":"completed"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":338,"cache_read_input_tokens":68132,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":338},"output_tokens":24,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CY1FHve17tabjwJSUvBTr","type":"assistant","uuid":"7040f7e4-f7dd-4809-a089-85ee565a9809","timestamp":"2026-02-10T23:21:38.840Z"}
{"parentUuid":"7040f7e4-f7dd-4809-a089-85ee565a9809","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Y9J5QfuCYuboohtG6wXFj6","type":"tool_result","content":"Updated task #2 status"}]},"uuid":"15a0c24e-a28e-4288-b95e-7925dedc73b9","timestamp":"2026-02-10T23:21:38.844Z","toolUseResult":{"success":true,"taskId":"2","updatedFields":["status"],"statusChange":{"from":"in_progress","to":"completed"}},"sourceToolAssistantUUID":"7040f7e4-f7dd-4809-a089-85ee565a9809"}
{"parentUuid":"15a0c24e-a28e-4288-b95e-7925dedc73b9","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","message":{"model":"claude-opus-4-6","id":"msg_01Eq6o9RKJ3pmk4aPqbGPcD8","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01WRJEeMzMvhbdYRyRhbnVL8","name":"TaskUpdate","input":{"taskId":"3","status":"in_progress"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":88,"cache_read_input_tokens":68470,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":88},"output_tokens":24,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CY1FJ57VJxu1SWUwBZCRa","type":"assistant","uuid":"e20d98ce-e6c3-4464-933d-fcf48b62825f","timestamp":"2026-02-10T23:21:40.957Z"}
{"parentUuid":"e20d98ce-e6c3-4464-933d-fcf48b62825f","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01WRJEeMzMvhbdYRyRhbnVL8","type":"tool_result","content":"Updated task #3 status"}]},"uuid":"56840e62-f0fe-46a7-b641-41745f1d762d","timestamp":"2026-02-10T23:21:40.960Z","toolUseResult":{"success":true,"taskId":"3","updatedFields":["status"],"statusChange":{"from":"pending","to":"in_progress"}},"sourceToolAssistantUUID":"e20d98ce-e6c3-4464-933d-fcf48b62825f"}
{"type":"file-history-snapshot","messageId":"db4f6c05-cd9e-4dd1-ad61-ed7cf34a3f13","snapshot":{"messageId":"419d76bc-01da-47ab-8292-f6cf09dd2274","trackedFileBackups":{"src/lws/parser/assembly.py":{"backupFileName":"00df020cf1c04e6c@v1","version":1,"backupTime":"2026-02-10T23:21:01.336Z"},"src/lws/parser/tree_parser.py":{"backupFileName":"65fa9421a5a90c00@v1","version":1,"backupTime":"2026-02-10T23:21:36.827Z"},"src/lws/providers/ssm/routes.py":{"backupFileName":"d14e765b331d5a53@v1","version":1,"backupTime":"2026-02-10T23:21:47.270Z"}},"timestamp":"2026-02-10T23:20:18.621Z"},"isSnapshotUpdate":true}
{"parentUuid":"56840e62-f0fe-46a7-b641-41745f1d762d","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","message":{"model":"claude-opus-4-6","id":"msg_01MvL5Gicz7vQFDPdZY3LZQK","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01SNawMdf9FpaLLspq2XXGuj","name":"Edit","input":{"replace_all":false,"file_path":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services/src/lws/providers/ssm/routes.py","old_string":"def create_ssm_app() -> FastAPI:\n    \"\"\"Create a FastAPI application that speaks the SSM wire protocol.\"\"\"\n    app = FastAPI(title=\"LDK SSM\")\n    app.add_middleware(RequestLoggingMiddleware, logger=_logger, service_name=\"ssm\")\n    state = _SsmState()","new_string":"def create_ssm_app(initial_parameters: list[dict] | None = None) -> FastAPI:\n    \"\"\"Create a FastAPI application that speaks the SSM wire protocol.\"\"\"\n    app = FastAPI(title=\"LDK SSM\")\n    app.add_middleware(RequestLoggingMiddleware, logger=_logger, service_name=\"ssm\")\n    state = _SsmState()\n\n    if initial_parameters:\n        for p in initial_parameters:\n            param = _Parameter(\n                name=p[\"name\"],\n                value=p.get(\"value\", \"\"),\n                param_type=p.get(\"type\", \"String\"),\n                description=p.get(\"description\", \"\"),\n            )\n            state._parameters[param.name] = param"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":90,"cache_read_input_tokens":68558,"output_tokens":403,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":90,"ephemeral_5m_input_tokens":0},"inference_geo":"","iterations":[]}},"requestId":"req_011CY1FJE9x8ijBkKtXtJvKV","type":"assistant","uuid":"db4f6c05-cd9e-4dd1-ad61-ed7cf34a3f13","timestamp":"2026-02-10T23:21:47.261Z"}
{"parentUuid":"db4f6c05-cd9e-4dd1-ad61-ed7cf34a3f13","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"callback"},"parentToolUseID":"toolu_01SNawMdf9FpaLLspq2XXGuj","toolUseID":"toolu_01SNawMdf9FpaLLspq2XXGuj","timestamp":"2026-02-10T23:21:47.273Z","uuid":"ee89654a-d48c-43a4-a0d9-044ba67e164b"}
{"parentUuid":"db4f6c05-cd9e-4dd1-ad61-ed7cf34a3f13","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01SNawMdf9FpaLLspq2XXGuj","type":"tool_result","content":"The file /Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services/src/lws/providers/ssm/routes.py has been updated successfully."}]},"uuid":"ee9eb502-3a76-4392-babe-686b50b9170e","timestamp":"2026-02-10T23:21:47.273Z","toolUseResult":{"filePath":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services/src/lws/providers/ssm/routes.py","oldString":"def create_ssm_app() -> FastAPI:\n    \"\"\"Create a FastAPI application that speaks the SSM wire protocol.\"\"\"\n    app = FastAPI(title=\"LDK SSM\")\n    app.add_middleware(RequestLoggingMiddleware, logger=_logger, service_name=\"ssm\")\n    state = _SsmState()","newString":"def create_ssm_app(initial_parameters: list[dict] | None = None) -> FastAPI:\n    \"\"\"Create a FastAPI application that speaks the SSM wire protocol.\"\"\"\n    app = FastAPI(title=\"LDK SSM\")\n    app.add_middleware(RequestLoggingMiddleware, logger=_logger, service_name=\"ssm\")\n    state = _SsmState()\n\n    if initial_parameters:\n        for p in initial_parameters:\n            param = _Parameter(\n                name=p[\"name\"],\n                value=p.get(\"value\", \"\"),\n                param_type=p.get(\"type\", \"String\"),\n                description=p.get(\"description\", \"\"),\n            )\n            state._parameters[param.name] = param","originalFile":"\"\"\"SSM Parameter Store HTTP routes.\n\nImplements the SSM wire protocol that AWS SDKs and Terraform use,\nusing JSON request/response format with X-Amz-Target header dispatch.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport json\nimport time\nfrom typing import Any\n\nfrom fastapi import FastAPI, Request, Response\n\nfrom lws.logging.logger import get_logger\nfrom lws.logging.middleware import RequestLoggingMiddleware\n\n_logger = get_logger(\"ldk.ssm\")\n\n_ACCOUNT_ID = \"000000000000\"\n_REGION = \"us-east-1\"\n\n\n# ------------------------------------------------------------------\n# In-memory state\n# ------------------------------------------------------------------\n\n\nclass _Parameter:\n    \"\"\"Represents an SSM parameter.\"\"\"\n\n    def __init__(\n        self,\n        name: str,\n        value: str,\n        param_type: str = \"String\",\n        description: str = \"\",\n        tags: dict[str, str] | None = None,\n    ) -> None:\n        self.name = name\n        self.value = value\n        self.type = param_type\n        self.description = description\n        self.version = 1\n        self.tags: dict[str, str] = tags or {}\n        self.last_modified_date: float = time.time()\n        self.arn = f\"arn:aws:ssm:{_REGION}:{_ACCOUNT_ID}:parameter{name}\"\n\n\nclass _SsmState:\n    \"\"\"In-memory store for SSM parameters.\"\"\"\n\n    def __init__(self) -> None:\n        self._parameters: dict[str, _Parameter] = {}\n\n\n# ------------------------------------------------------------------\n# Action handlers\n# ------------------------------------------------------------------\n\n\nasync def _handle_put_parameter(state: _SsmState, body: dict) -> Response:\n    name = body.get(\"Name\", \"\")\n    value = body.get(\"Value\", \"\")\n    param_type = body.get(\"Type\", \"String\")\n    description = body.get(\"Description\", \"\")\n    overwrite = body.get(\"Overwrite\", False)\n    tags_list = body.get(\"Tags\", [])\n    tags = {t[\"Key\"]: t[\"Value\"] for t in tags_list} if tags_list else {}\n\n    existing = state._parameters.get(name)\n    if existing and not overwrite:\n        return _error_response(\n            \"ParameterAlreadyExists\",\n            \"The parameter already exists. To overwrite set Overwrite to true.\",\n        )\n\n    if existing:\n        existing.value = value\n        existing.type = param_type\n        if description:\n            existing.description = description\n        existing.version += 1\n        existing.last_modified_date = time.time()\n        if tags:\n            existing.tags.update(tags)\n        version = existing.version\n    else:\n        param = _Parameter(\n            name=name,\n            value=value,\n            param_type=param_type,\n            description=description,\n            tags=tags,\n        )\n        state._parameters[name] = param\n        version = param.version\n\n    return _json_response({\"Version\": version, \"Tier\": \"Standard\"})\n\n\nasync def _handle_get_parameter(state: _SsmState, body: dict) -> Response:\n    name = body.get(\"Name\", \"\")\n    with_decryption = body.get(\"WithDecryption\", False)\n    param = state._parameters.get(name)\n    if param is None:\n        return _error_response(\n            \"ParameterNotFound\",\n            f\"Parameter {name} not found.\",\n            status_code=400,\n        )\n    return _json_response({\"Parameter\": _format_parameter(param, with_decryption=with_decryption)})\n\n\nasync def _handle_get_parameters(state: _SsmState, body: dict) -> Response:\n    names = body.get(\"Names\", [])\n    with_decryption = body.get(\"WithDecryption\", False)\n    parameters = []\n    invalid = []\n    for name in names:\n        param = state._parameters.get(name)\n        if param:\n            parameters.append(_format_parameter(param, with_decryption=with_decryption))\n        else:\n            invalid.append(name)\n    return _json_response({\"Parameters\": parameters, \"InvalidParameters\": invalid})\n\n\nasync def _handle_get_parameters_by_path(state: _SsmState, body: dict) -> Response:\n    path = body.get(\"Path\", \"/\")\n    recursive = body.get(\"Recursive\", False)\n    with_decryption = body.get(\"WithDecryption\", False)\n\n    parameters = []\n    for name, param in state._parameters.items():\n        if recursive:\n            if name.startswith(path):\n                parameters.append(_format_parameter(param, with_decryption=with_decryption))\n        else:\n            # Non-recursive: only direct children\n            if name.startswith(path):\n                remainder = name[len(path) :].lstrip(\"/\")\n                if \"/\" not in remainder:\n                    parameters.append(_format_parameter(param, with_decryption=with_decryption))\n\n    return _json_response({\"Parameters\": parameters})\n\n\nasync def _handle_delete_parameter(state: _SsmState, body: dict) -> Response:\n    name = body.get(\"Name\", \"\")\n    if name not in state._parameters:\n        return _error_response(\n            \"ParameterNotFound\",\n            f\"Parameter {name} not found.\",\n            status_code=400,\n        )\n    del state._parameters[name]\n    return _json_response({})\n\n\nasync def _handle_delete_parameters(state: _SsmState, body: dict) -> Response:\n    names = body.get(\"Names\", [])\n    deleted = []\n    invalid = []\n    for name in names:\n        if name in state._parameters:\n            del state._parameters[name]\n            deleted.append(name)\n        else:\n            invalid.append(name)\n    return _json_response({\"DeletedParameters\": deleted, \"InvalidParameters\": invalid})\n\n\nasync def _handle_describe_parameters(state: _SsmState, body: dict) -> Response:\n    filters = body.get(\"ParameterFilters\", [])\n    params_list = list(state._parameters.values())\n\n    # Apply basic name filtering\n    for f in filters:\n        key = f.get(\"Key\", \"\")\n        values = f.get(\"Values\", [])\n        option = f.get(\"Option\", \"Equals\")\n        if key == \"Name\":\n            if option == \"Equals\":\n                params_list = [p for p in params_list if p.name in values]\n            elif option == \"BeginsWith\":\n                params_list = [p for p in params_list if any(p.name.startswith(v) for v in values)]\n            elif option == \"Contains\":\n                params_list = [p for p in params_list if any(v in p.name for v in values)]\n\n    descriptions = [_format_parameter_metadata(p) for p in params_list]\n    return _json_response({\"Parameters\": descriptions})\n\n\nasync def _handle_add_tags_to_resource(state: _SsmState, body: dict) -> Response:\n    resource_id = body.get(\"ResourceId\", \"\")\n    resource_type = body.get(\"ResourceType\", \"Parameter\")\n    tags_list = body.get(\"Tags\", [])\n\n    if resource_type == \"Parameter\":\n        param = state._parameters.get(resource_id)\n        if param is None:\n            return _error_response(\n                \"InvalidResourceId\",\n                f\"Parameter {resource_id} not found.\",\n                status_code=400,\n            )\n        for tag in tags_list:\n            param.tags[tag[\"Key\"]] = tag[\"Value\"]\n\n    return _json_response({})\n\n\nasync def _handle_remove_tags_from_resource(state: _SsmState, body: dict) -> Response:\n    resource_id = body.get(\"ResourceId\", \"\")\n    resource_type = body.get(\"ResourceType\", \"Parameter\")\n    tag_keys = body.get(\"TagKeys\", [])\n\n    if resource_type == \"Parameter\":\n        param = state._parameters.get(resource_id)\n        if param is None:\n            return _error_response(\n                \"InvalidResourceId\",\n                f\"Parameter {resource_id} not found.\",\n                status_code=400,\n            )\n        for key in tag_keys:\n            param.tags.pop(key, None)\n\n    return _json_response({})\n\n\nasync def _handle_list_tags_for_resource(state: _SsmState, body: dict) -> Response:\n    resource_id = body.get(\"ResourceId\", \"\")\n    resource_type = body.get(\"ResourceType\", \"Parameter\")\n\n    tags: list[dict[str, str]] = []\n    if resource_type == \"Parameter\":\n        param = state._parameters.get(resource_id)\n        if param is not None:\n            tags = [{\"Key\": k, \"Value\": v} for k, v in param.tags.items()]\n\n    return _json_response({\"TagList\": tags})\n\n\n# ------------------------------------------------------------------\n# Helpers\n# ------------------------------------------------------------------\n\n\ndef _format_parameter(param: _Parameter, *, with_decryption: bool = False) -> dict[str, Any]:\n    \"\"\"Format a parameter for API response.\"\"\"\n    value = param.value\n    if param.type == \"SecureString\" and not with_decryption:\n        value = \"***\"\n    return {\n        \"Name\": param.name,\n        \"Type\": param.type,\n        \"Value\": value,\n        \"Version\": param.version,\n        \"LastModifiedDate\": param.last_modified_date,\n        \"ARN\": param.arn,\n        \"DataType\": \"text\",\n    }\n\n\ndef _format_parameter_metadata(param: _Parameter) -> dict[str, Any]:\n    \"\"\"Format a parameter for DescribeParameters response.\"\"\"\n    return {\n        \"Name\": param.name,\n        \"Type\": param.type,\n        \"Description\": param.description,\n        \"Version\": param.version,\n        \"LastModifiedDate\": param.last_modified_date,\n        \"ARN\": param.arn,\n        \"Tier\": \"Standard\",\n        \"DataType\": \"text\",\n    }\n\n\ndef _json_response(data: dict, status_code: int = 200) -> Response:\n    \"\"\"Return a JSON response.\"\"\"\n    return Response(\n        content=json.dumps(data, default=str),\n        status_code=status_code,\n        media_type=\"application/x-amz-json-1.1\",\n    )\n\n\ndef _error_response(code: str, message: str, status_code: int = 400) -> Response:\n    \"\"\"Return an error response in SSM format.\"\"\"\n    error_body = {\"__type\": code, \"message\": message}\n    return _json_response(error_body, status_code=status_code)\n\n\n# ------------------------------------------------------------------\n# Action dispatch table\n# ------------------------------------------------------------------\n\n\n_ACTION_HANDLERS: dict[str, Any] = {\n    \"PutParameter\": _handle_put_parameter,\n    \"GetParameter\": _handle_get_parameter,\n    \"GetParameters\": _handle_get_parameters,\n    \"GetParametersByPath\": _handle_get_parameters_by_path,\n    \"DeleteParameter\": _handle_delete_parameter,\n    \"DeleteParameters\": _handle_delete_parameters,\n    \"DescribeParameters\": _handle_describe_parameters,\n    \"AddTagsToResource\": _handle_add_tags_to_resource,\n    \"RemoveTagsFromResource\": _handle_remove_tags_from_resource,\n    \"ListTagsForResource\": _handle_list_tags_for_resource,\n}\n\n\n# ------------------------------------------------------------------\n# App factory\n# ------------------------------------------------------------------\n\n\ndef create_ssm_app() -> FastAPI:\n    \"\"\"Create a FastAPI application that speaks the SSM wire protocol.\"\"\"\n    app = FastAPI(title=\"LDK SSM\")\n    app.add_middleware(RequestLoggingMiddleware, logger=_logger, service_name=\"ssm\")\n    state = _SsmState()\n\n    @app.post(\"/\")\n    async def dispatch(request: Request) -> Response:\n        target = request.headers.get(\"x-amz-target\", \"\")\n        body = await _parse_request_body(request)\n        action = _resolve_action(target, body)\n\n        handler = _ACTION_HANDLERS.get(action)\n        if handler is None:\n            _logger.warning(\"Unknown SSM action: %s\", action)\n            return _error_response(\n                \"InvalidAction\",\n                f\"lws: SSM operation '{action}' is not yet implemented\",\n            )\n\n        return await handler(state, body)\n\n    return app\n\n\nasync def _parse_request_body(request: Request) -> dict:\n    \"\"\"Parse the JSON request body.\"\"\"\n    body_bytes = await request.body()\n    if not body_bytes:\n        return {}\n    try:\n        return json.loads(body_bytes)\n    except json.JSONDecodeError:\n        return {}\n\n\ndef _resolve_action(target: str, body: dict) -> str:\n    \"\"\"Resolve the API action from the target header or body.\"\"\"\n    if target:\n        # X-Amz-Target format: AmazonSSM.PutParameter\n        return target.rsplit(\".\", 1)[-1] if \".\" in target else target\n    return body.get(\"Action\", \"\")\n","structuredPatch":[{"oldStart":317,"oldLines":12,"newStart":317,"newLines":22,"lines":[" # ------------------------------------------------------------------"," "," ","-def create_ssm_app() -> FastAPI:","+def create_ssm_app(initial_parameters: list[dict] | None = None) -> FastAPI:","     \"\"\"Create a FastAPI application that speaks the SSM wire protocol.\"\"\"","     app = FastAPI(title=\"LDK SSM\")","     app.add_middleware(RequestLoggingMiddleware, logger=_logger, service_name=\"ssm\")","     state = _SsmState()"," ","+    if initial_parameters:","+        for p in initial_parameters:","+            param = _Parameter(","+                name=p[\"name\"],","+                value=p.get(\"value\", \"\"),","+                param_type=p.get(\"type\", \"String\"),","+                description=p.get(\"description\", \"\"),","+            )","+            state._parameters[param.name] = param","+","     @app.post(\"/\")","     async def dispatch(request: Request) -> Response:","         target = request.headers.get(\"x-amz-target\", \"\")"]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"db4f6c05-cd9e-4dd1-ad61-ed7cf34a3f13"}
{"parentUuid":"ee9eb502-3a76-4392-babe-686b50b9170e","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","message":{"model":"claude-opus-4-6","id":"msg_01KZZQ3EEuFVueUJGXqmtgHz","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Egebv45bdN68KmypsvDokd","name":"TaskUpdate","input":{"taskId":"3","status":"completed"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":461,"cache_read_input_tokens":68648,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":461},"output_tokens":24,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CY1FJhMKkUx3VkdNzFk84","type":"assistant","uuid":"dab24c9e-3803-4b06-a765-38eced649f31","timestamp":"2026-02-10T23:21:50.362Z"}
{"parentUuid":"dab24c9e-3803-4b06-a765-38eced649f31","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Egebv45bdN68KmypsvDokd","type":"tool_result","content":"Updated task #3 status"}]},"uuid":"8a6b2211-d934-44f9-9160-404f48d19724","timestamp":"2026-02-10T23:21:50.368Z","toolUseResult":{"success":true,"taskId":"3","updatedFields":["status"],"statusChange":{"from":"in_progress","to":"completed"}},"sourceToolAssistantUUID":"dab24c9e-3803-4b06-a765-38eced649f31"}
{"parentUuid":"8a6b2211-d934-44f9-9160-404f48d19724","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","message":{"model":"claude-opus-4-6","id":"msg_01DdiroxAQCoeWXLg3GLoYeB","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01RLzMzqGsTenQnGUwvxrLW5","name":"TaskUpdate","input":{"taskId":"4","status":"in_progress"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":88,"cache_read_input_tokens":69109,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":88},"output_tokens":24,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CY1FJv9GKGGBZzUSG4FKg","type":"assistant","uuid":"7489917c-ae08-4a3c-9bdb-bbd55e2473e1","timestamp":"2026-02-10T23:21:53.213Z"}
{"parentUuid":"7489917c-ae08-4a3c-9bdb-bbd55e2473e1","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01RLzMzqGsTenQnGUwvxrLW5","type":"tool_result","content":"Updated task #4 status"}]},"uuid":"4e17861e-e8a6-469f-b058-d84051fedc12","timestamp":"2026-02-10T23:21:53.218Z","toolUseResult":{"success":true,"taskId":"4","updatedFields":["status"],"statusChange":{"from":"pending","to":"in_progress"}},"sourceToolAssistantUUID":"7489917c-ae08-4a3c-9bdb-bbd55e2473e1"}
{"type":"file-history-snapshot","messageId":"ff44f20c-dc8d-4ac1-a22f-bbc1b0652def","snapshot":{"messageId":"419d76bc-01da-47ab-8292-f6cf09dd2274","trackedFileBackups":{"src/lws/parser/assembly.py":{"backupFileName":"00df020cf1c04e6c@v1","version":1,"backupTime":"2026-02-10T23:21:01.336Z"},"src/lws/parser/tree_parser.py":{"backupFileName":"65fa9421a5a90c00@v1","version":1,"backupTime":"2026-02-10T23:21:36.827Z"},"src/lws/providers/ssm/routes.py":{"backupFileName":"d14e765b331d5a53@v1","version":1,"backupTime":"2026-02-10T23:21:47.270Z"},"src/lws/providers/secretsmanager/routes.py":{"backupFileName":"9face069ed21abb2@v1","version":1,"backupTime":"2026-02-10T23:21:59.102Z"}},"timestamp":"2026-02-10T23:20:18.621Z"},"isSnapshotUpdate":true}
{"parentUuid":"4e17861e-e8a6-469f-b058-d84051fedc12","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","message":{"model":"claude-opus-4-6","id":"msg_01FoCdUbqEBRMYwBtQi7HCSW","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01TezoLYPAwZzQnsFtxbhAFj","name":"Edit","input":{"replace_all":false,"file_path":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services/src/lws/providers/secretsmanager/routes.py","old_string":"def create_secretsmanager_app() -> FastAPI:\n    \"\"\"Create a FastAPI application that speaks the Secrets Manager wire protocol.\"\"\"\n    app = FastAPI(title=\"LDK Secrets Manager\")\n    app.add_middleware(RequestLoggingMiddleware, logger=_logger, service_name=\"secretsmanager\")\n    state = _SecretsState()","new_string":"def create_secretsmanager_app(initial_secrets: list[dict] | None = None) -> FastAPI:\n    \"\"\"Create a FastAPI application that speaks the Secrets Manager wire protocol.\"\"\"\n    app = FastAPI(title=\"LDK Secrets Manager\")\n    app.add_middleware(RequestLoggingMiddleware, logger=_logger, service_name=\"secretsmanager\")\n    state = _SecretsState()\n\n    if initial_secrets:\n        for s in initial_secrets:\n            secret = _Secret(\n                name=s[\"name\"],\n                description=s.get(\"description\", \"\"),\n            )\n            secret_string = s.get(\"secret_string\")\n            if secret_string is not None:\n                version_id = str(uuid.uuid4())\n                version = _SecretVersion(\n                    version_id=version_id,\n                    secret_string=secret_string,\n                    stages=[\"AWSCURRENT\"],\n                )\n                secret.versions[version_id] = version\n                secret.current_version_id = version_id\n            state._secrets[secret.name] = secret"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":90,"cache_read_input_tokens":69197,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":90},"output_tokens":24,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CY1FK8PDEs5suPU8xgCov","type":"assistant","uuid":"ff44f20c-dc8d-4ac1-a22f-bbc1b0652def","timestamp":"2026-02-10T23:21:59.097Z"}
{"parentUuid":"ff44f20c-dc8d-4ac1-a22f-bbc1b0652def","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"callback"},"parentToolUseID":"toolu_01TezoLYPAwZzQnsFtxbhAFj","toolUseID":"toolu_01TezoLYPAwZzQnsFtxbhAFj","timestamp":"2026-02-10T23:21:59.109Z","uuid":"3f81f1f1-6dfa-490c-97a6-d81ddeee386e"}
{"parentUuid":"ff44f20c-dc8d-4ac1-a22f-bbc1b0652def","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01TezoLYPAwZzQnsFtxbhAFj","type":"tool_result","content":"The file /Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services/src/lws/providers/secretsmanager/routes.py has been updated successfully."}]},"uuid":"7b6ca7fa-97cd-4250-8edb-46576e1b5628","timestamp":"2026-02-10T23:21:59.109Z","toolUseResult":{"filePath":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services/src/lws/providers/secretsmanager/routes.py","oldString":"def create_secretsmanager_app() -> FastAPI:\n    \"\"\"Create a FastAPI application that speaks the Secrets Manager wire protocol.\"\"\"\n    app = FastAPI(title=\"LDK Secrets Manager\")\n    app.add_middleware(RequestLoggingMiddleware, logger=_logger, service_name=\"secretsmanager\")\n    state = _SecretsState()","newString":"def create_secretsmanager_app(initial_secrets: list[dict] | None = None) -> FastAPI:\n    \"\"\"Create a FastAPI application that speaks the Secrets Manager wire protocol.\"\"\"\n    app = FastAPI(title=\"LDK Secrets Manager\")\n    app.add_middleware(RequestLoggingMiddleware, logger=_logger, service_name=\"secretsmanager\")\n    state = _SecretsState()\n\n    if initial_secrets:\n        for s in initial_secrets:\n            secret = _Secret(\n                name=s[\"name\"],\n                description=s.get(\"description\", \"\"),\n            )\n            secret_string = s.get(\"secret_string\")\n            if secret_string is not None:\n                version_id = str(uuid.uuid4())\n                version = _SecretVersion(\n                    version_id=version_id,\n                    secret_string=secret_string,\n                    stages=[\"AWSCURRENT\"],\n                )\n                secret.versions[version_id] = version\n                secret.current_version_id = version_id\n            state._secrets[secret.name] = secret","originalFile":"\"\"\"Secrets Manager HTTP routes.\n\nImplements the Secrets Manager wire protocol that AWS SDKs and Terraform use,\nusing JSON request/response format with X-Amz-Target header dispatch.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport json\nimport time\nimport uuid\nfrom typing import Any\n\nfrom fastapi import FastAPI, Request, Response\n\nfrom lws.logging.logger import get_logger\nfrom lws.logging.middleware import RequestLoggingMiddleware\n\n_logger = get_logger(\"ldk.secretsmanager\")\n\n_ACCOUNT_ID = \"000000000000\"\n_REGION = \"us-east-1\"\n\n\n# ------------------------------------------------------------------\n# In-memory state\n# ------------------------------------------------------------------\n\n\nclass _SecretVersion:\n    \"\"\"A single version of a secret.\"\"\"\n\n    def __init__(\n        self,\n        version_id: str,\n        secret_string: str | None = None,\n        secret_binary: str | None = None,\n        stages: list[str] | None = None,\n    ) -> None:\n        self.version_id = version_id\n        self.secret_string = secret_string\n        self.secret_binary = secret_binary\n        self.stages = stages or [\"AWSCURRENT\"]\n        self.created_date: float = time.time()\n\n\nclass _Secret:\n    \"\"\"Represents a Secrets Manager secret.\"\"\"\n\n    def __init__(\n        self,\n        name: str,\n        description: str = \"\",\n        tags: dict[str, str] | None = None,\n    ) -> None:\n        self.name = name\n        self.arn = f\"arn:aws:secretsmanager:{_REGION}:{_ACCOUNT_ID}:secret:{name}\"\n        self.description = description\n        self.tags: dict[str, str] = tags or {}\n        self.versions: dict[str, _SecretVersion] = {}\n        self.current_version_id: str | None = None\n        self.deleted_date: float | None = None\n        self.created_date: float = time.time()\n        self.last_changed_date: float = time.time()\n\n\nclass _SecretsState:\n    \"\"\"In-memory store for Secrets Manager secrets.\"\"\"\n\n    def __init__(self) -> None:\n        self._secrets: dict[str, _Secret] = {}\n\n\n# ------------------------------------------------------------------\n# Action handlers\n# ------------------------------------------------------------------\n\n\nasync def _handle_create_secret(state: _SecretsState, body: dict) -> Response:\n    name = body.get(\"Name\", \"\")\n    description = body.get(\"Description\", \"\")\n    secret_string = body.get(\"SecretString\")\n    secret_binary = body.get(\"SecretBinary\")\n    tags_list = body.get(\"Tags\", [])\n    tags = {t[\"Key\"]: t[\"Value\"] for t in tags_list} if tags_list else {}\n\n    if name in state._secrets:\n        existing = state._secrets[name]\n        if existing.deleted_date is not None:\n            # Restore soft-deleted secret\n            existing.deleted_date = None\n            existing.description = description\n            existing.tags = tags\n        else:\n            return _error_response(\n                \"ResourceExistsException\",\n                f\"The secret {name} already exists.\",\n            )\n\n    secret = _Secret(name=name, description=description, tags=tags)\n    state._secrets[name] = secret\n\n    version_id: str | None = None\n    if secret_string is not None or secret_binary is not None:\n        version_id = str(uuid.uuid4())\n        version = _SecretVersion(\n            version_id=version_id,\n            secret_string=secret_string,\n            secret_binary=secret_binary,\n            stages=[\"AWSCURRENT\"],\n        )\n        secret.versions[version_id] = version\n        secret.current_version_id = version_id\n\n    result: dict[str, Any] = {\"ARN\": secret.arn, \"Name\": name}\n    if version_id:\n        result[\"VersionId\"] = version_id\n    return _json_response(result)\n\n\nasync def _handle_get_secret_value(state: _SecretsState, body: dict) -> Response:\n    secret_id = body.get(\"SecretId\", \"\")\n    version_id = body.get(\"VersionId\")\n    version_stage = body.get(\"VersionStage\", \"AWSCURRENT\")\n\n    secret = _find_secret(state, secret_id)\n    if secret is None or secret.deleted_date is not None:\n        return _error_response(\n            \"ResourceNotFoundException\",\n            f\"Secret {secret_id} not found.\",\n        )\n\n    version = _resolve_version(secret, version_id, version_stage)\n    if version is None:\n        return _error_response(\n            \"ResourceNotFoundException\",\n            f\"No version found for secret {secret_id}.\",\n        )\n\n    result: dict[str, Any] = {\n        \"ARN\": secret.arn,\n        \"Name\": secret.name,\n        \"VersionId\": version.version_id,\n        \"VersionStages\": version.stages,\n        \"CreatedDate\": version.created_date,\n    }\n    if version.secret_string is not None:\n        result[\"SecretString\"] = version.secret_string\n    if version.secret_binary is not None:\n        result[\"SecretBinary\"] = version.secret_binary\n    return _json_response(result)\n\n\nasync def _handle_put_secret_value(state: _SecretsState, body: dict) -> Response:\n    secret_id = body.get(\"SecretId\", \"\")\n    secret_string = body.get(\"SecretString\")\n    secret_binary = body.get(\"SecretBinary\")\n\n    secret = _find_secret(state, secret_id)\n    if secret is None or secret.deleted_date is not None:\n        return _error_response(\n            \"ResourceNotFoundException\",\n            f\"Secret {secret_id} not found.\",\n        )\n\n    # Move AWSCURRENT from old version\n    if secret.current_version_id and secret.current_version_id in secret.versions:\n        old = secret.versions[secret.current_version_id]\n        if \"AWSCURRENT\" in old.stages:\n            old.stages.remove(\"AWSCURRENT\")\n        if \"AWSPREVIOUS\" not in old.stages:\n            old.stages.append(\"AWSPREVIOUS\")\n\n    version_id = str(uuid.uuid4())\n    version = _SecretVersion(\n        version_id=version_id,\n        secret_string=secret_string,\n        secret_binary=secret_binary,\n        stages=[\"AWSCURRENT\"],\n    )\n    secret.versions[version_id] = version\n    secret.current_version_id = version_id\n    secret.last_changed_date = time.time()\n\n    return _json_response({\"ARN\": secret.arn, \"Name\": secret.name, \"VersionId\": version_id})\n\n\nasync def _handle_update_secret(state: _SecretsState, body: dict) -> Response:\n    secret_id = body.get(\"SecretId\", \"\")\n    description = body.get(\"Description\")\n    secret_string = body.get(\"SecretString\")\n    secret_binary = body.get(\"SecretBinary\")\n\n    secret = _find_secret(state, secret_id)\n    if secret is None or secret.deleted_date is not None:\n        return _error_response(\n            \"ResourceNotFoundException\",\n            f\"Secret {secret_id} not found.\",\n        )\n\n    if description is not None:\n        secret.description = description\n\n    version_id: str | None = None\n    if secret_string is not None or secret_binary is not None:\n        # Move AWSCURRENT from old version\n        if secret.current_version_id and secret.current_version_id in secret.versions:\n            old = secret.versions[secret.current_version_id]\n            if \"AWSCURRENT\" in old.stages:\n                old.stages.remove(\"AWSCURRENT\")\n            if \"AWSPREVIOUS\" not in old.stages:\n                old.stages.append(\"AWSPREVIOUS\")\n\n        version_id = str(uuid.uuid4())\n        version = _SecretVersion(\n            version_id=version_id,\n            secret_string=secret_string,\n            secret_binary=secret_binary,\n            stages=[\"AWSCURRENT\"],\n        )\n        secret.versions[version_id] = version\n        secret.current_version_id = version_id\n\n    secret.last_changed_date = time.time()\n    result: dict[str, Any] = {\"ARN\": secret.arn, \"Name\": secret.name}\n    if version_id:\n        result[\"VersionId\"] = version_id\n    return _json_response(result)\n\n\nasync def _handle_delete_secret(state: _SecretsState, body: dict) -> Response:\n    secret_id = body.get(\"SecretId\", \"\")\n    force_delete = body.get(\"ForceDeleteWithoutRecovery\", False)\n\n    secret = _find_secret(state, secret_id)\n    if secret is None:\n        return _error_response(\n            \"ResourceNotFoundException\",\n            f\"Secret {secret_id} not found.\",\n        )\n\n    if force_delete:\n        state._secrets.pop(secret.name, None)\n    else:\n        secret.deleted_date = time.time()\n\n    return _json_response(\n        {\n            \"ARN\": secret.arn,\n            \"Name\": secret.name,\n            \"DeletionDate\": secret.deleted_date or time.time(),\n        }\n    )\n\n\nasync def _handle_describe_secret(state: _SecretsState, body: dict) -> Response:\n    secret_id = body.get(\"SecretId\", \"\")\n    secret = _find_secret(state, secret_id)\n    if secret is None:\n        return _error_response(\n            \"ResourceNotFoundException\",\n            f\"Secret {secret_id} not found.\",\n        )\n    return _json_response(_format_secret_description(secret))\n\n\nasync def _handle_list_secrets(state: _SecretsState, body: dict) -> Response:\n    secrets = [\n        _format_secret_description(s) for s in state._secrets.values() if s.deleted_date is None\n    ]\n    return _json_response({\"SecretList\": secrets})\n\n\nasync def _handle_restore_secret(state: _SecretsState, body: dict) -> Response:\n    secret_id = body.get(\"SecretId\", \"\")\n    secret = _find_secret(state, secret_id)\n    if secret is None:\n        return _error_response(\n            \"ResourceNotFoundException\",\n            f\"Secret {secret_id} not found.\",\n        )\n    if secret.deleted_date is None:\n        return _error_response(\n            \"InvalidRequestException\",\n            f\"Secret {secret_id} is not scheduled for deletion.\",\n        )\n    secret.deleted_date = None\n    return _json_response({\"ARN\": secret.arn, \"Name\": secret.name})\n\n\nasync def _handle_tag_resource(state: _SecretsState, body: dict) -> Response:\n    secret_id = body.get(\"SecretId\", \"\")\n    tags_list = body.get(\"Tags\", [])\n\n    secret = _find_secret(state, secret_id)\n    if secret is None:\n        return _error_response(\n            \"ResourceNotFoundException\",\n            f\"Secret {secret_id} not found.\",\n        )\n\n    for tag in tags_list:\n        secret.tags[tag[\"Key\"]] = tag[\"Value\"]\n    return _json_response({})\n\n\nasync def _handle_untag_resource(state: _SecretsState, body: dict) -> Response:\n    secret_id = body.get(\"SecretId\", \"\")\n    tag_keys = body.get(\"TagKeys\", [])\n\n    secret = _find_secret(state, secret_id)\n    if secret is None:\n        return _error_response(\n            \"ResourceNotFoundException\",\n            f\"Secret {secret_id} not found.\",\n        )\n\n    for key in tag_keys:\n        secret.tags.pop(key, None)\n    return _json_response({})\n\n\nasync def _handle_get_resource_policy(state: _SecretsState, body: dict) -> Response:\n    secret_id = body.get(\"SecretId\", \"\")\n    secret = _find_secret(state, secret_id)\n    if secret is None:\n        return _error_response(\n            \"ResourceNotFoundException\",\n            f\"Secret {secret_id} not found.\",\n        )\n    return _json_response({\"ARN\": secret.arn, \"Name\": secret.name})\n\n\nasync def _handle_list_secret_version_ids(state: _SecretsState, body: dict) -> Response:\n    secret_id = body.get(\"SecretId\", \"\")\n    secret = _find_secret(state, secret_id)\n    if secret is None:\n        return _error_response(\n            \"ResourceNotFoundException\",\n            f\"Secret {secret_id} not found.\",\n        )\n\n    versions = [\n        {\n            \"VersionId\": v.version_id,\n            \"VersionStages\": v.stages,\n            \"CreatedDate\": v.created_date,\n        }\n        for v in secret.versions.values()\n    ]\n    return _json_response({\"ARN\": secret.arn, \"Name\": secret.name, \"Versions\": versions})\n\n\n# ------------------------------------------------------------------\n# Helpers\n# ------------------------------------------------------------------\n\n\ndef _find_secret(state: _SecretsState, secret_id: str) -> _Secret | None:\n    \"\"\"Find a secret by name or ARN.\"\"\"\n    if secret_id in state._secrets:\n        return state._secrets[secret_id]\n    for s in state._secrets.values():\n        if s.arn == secret_id:\n            return s\n    return None\n\n\ndef _resolve_version(\n    secret: _Secret,\n    version_id: str | None,\n    version_stage: str,\n) -> _SecretVersion | None:\n    \"\"\"Resolve a secret version by ID or stage.\"\"\"\n    if version_id:\n        return secret.versions.get(version_id)\n    for v in secret.versions.values():\n        if version_stage in v.stages:\n            return v\n    return None\n\n\ndef _format_secret_description(secret: _Secret) -> dict[str, Any]:\n    \"\"\"Format a secret for DescribeSecret / ListSecrets response.\"\"\"\n    result: dict[str, Any] = {\n        \"ARN\": secret.arn,\n        \"Name\": secret.name,\n        \"Description\": secret.description,\n        \"CreatedDate\": secret.created_date,\n        \"LastChangedDate\": secret.last_changed_date,\n    }\n    if secret.tags:\n        result[\"Tags\"] = [{\"Key\": k, \"Value\": v} for k, v in secret.tags.items()]\n    if secret.deleted_date is not None:\n        result[\"DeletedDate\"] = secret.deleted_date\n    # Version IDs to stages mapping\n    if secret.versions:\n        result[\"VersionIdsToStages\"] = {v.version_id: v.stages for v in secret.versions.values()}\n    return result\n\n\ndef _json_response(data: dict, status_code: int = 200) -> Response:\n    \"\"\"Return a JSON response.\"\"\"\n    return Response(\n        content=json.dumps(data, default=str),\n        status_code=status_code,\n        media_type=\"application/x-amz-json-1.1\",\n    )\n\n\ndef _error_response(code: str, message: str, status_code: int = 400) -> Response:\n    \"\"\"Return an error response in Secrets Manager format.\"\"\"\n    error_body = {\"__type\": code, \"Message\": message}\n    return _json_response(error_body, status_code=status_code)\n\n\n# ------------------------------------------------------------------\n# Action dispatch table\n# ------------------------------------------------------------------\n\n\n_ACTION_HANDLERS: dict[str, Any] = {\n    \"CreateSecret\": _handle_create_secret,\n    \"GetSecretValue\": _handle_get_secret_value,\n    \"PutSecretValue\": _handle_put_secret_value,\n    \"UpdateSecret\": _handle_update_secret,\n    \"DeleteSecret\": _handle_delete_secret,\n    \"DescribeSecret\": _handle_describe_secret,\n    \"ListSecrets\": _handle_list_secrets,\n    \"RestoreSecret\": _handle_restore_secret,\n    \"TagResource\": _handle_tag_resource,\n    \"UntagResource\": _handle_untag_resource,\n    \"ListSecretVersionIds\": _handle_list_secret_version_ids,\n    \"GetResourcePolicy\": _handle_get_resource_policy,\n}\n\n\n# ------------------------------------------------------------------\n# App factory\n# ------------------------------------------------------------------\n\n\ndef create_secretsmanager_app() -> FastAPI:\n    \"\"\"Create a FastAPI application that speaks the Secrets Manager wire protocol.\"\"\"\n    app = FastAPI(title=\"LDK Secrets Manager\")\n    app.add_middleware(RequestLoggingMiddleware, logger=_logger, service_name=\"secretsmanager\")\n    state = _SecretsState()\n\n    @app.post(\"/\")\n    async def dispatch(request: Request) -> Response:\n        target = request.headers.get(\"x-amz-target\", \"\")\n        body = await _parse_request_body(request)\n        action = _resolve_action(target, body)\n\n        handler = _ACTION_HANDLERS.get(action)\n        if handler is None:\n            _logger.warning(\"Unknown Secrets Manager action: %s\", action)\n            return _error_response(\n                \"InvalidAction\",\n                f\"lws: Secrets Manager operation '{action}' is not yet implemented\",\n            )\n\n        return await handler(state, body)\n\n    return app\n\n\nasync def _parse_request_body(request: Request) -> dict:\n    \"\"\"Parse the JSON request body.\"\"\"\n    body_bytes = await request.body()\n    if not body_bytes:\n        return {}\n    try:\n        return json.loads(body_bytes)\n    except json.JSONDecodeError:\n        return {}\n\n\ndef _resolve_action(target: str, body: dict) -> str:\n    \"\"\"Resolve the API action from the target header or body.\"\"\"\n    if target:\n        # X-Amz-Target format: secretsmanager.CreateSecret\n        return target.rsplit(\".\", 1)[-1] if \".\" in target else target\n    return body.get(\"Action\", \"\")\n","structuredPatch":[{"oldStart":440,"oldLines":12,"newStart":440,"newLines":30,"lines":[" # ------------------------------------------------------------------"," "," ","-def create_secretsmanager_app() -> FastAPI:","+def create_secretsmanager_app(initial_secrets: list[dict] | None = None) -> FastAPI:","     \"\"\"Create a FastAPI application that speaks the Secrets Manager wire protocol.\"\"\"","     app = FastAPI(title=\"LDK Secrets Manager\")","     app.add_middleware(RequestLoggingMiddleware, logger=_logger, service_name=\"secretsmanager\")","     state = _SecretsState()"," ","+    if initial_secrets:","+        for s in initial_secrets:","+            secret = _Secret(","+                name=s[\"name\"],","+                description=s.get(\"description\", \"\"),","+            )","+            secret_string = s.get(\"secret_string\")","+            if secret_string is not None:","+                version_id = str(uuid.uuid4())","+                version = _SecretVersion(","+                    version_id=version_id,","+                    secret_string=secret_string,","+                    stages=[\"AWSCURRENT\"],","+                )","+                secret.versions[version_id] = version","+                secret.current_version_id = version_id","+            state._secrets[secret.name] = secret","+","     @app.post(\"/\")","     async def dispatch(request: Request) -> Response:","         target = request.headers.get(\"x-amz-target\", \"\")"]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"ff44f20c-dc8d-4ac1-a22f-bbc1b0652def"}
{"parentUuid":"7b6ca7fa-97cd-4250-8edb-46576e1b5628","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","message":{"model":"claude-opus-4-6","id":"msg_01K9hvCzNd35ENC78LbkXdMn","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01SXKvbRzAn3jQPnXW8h1amt","name":"TaskUpdate","input":{"taskId":"4","status":"completed"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":559,"cache_read_input_tokens":69287,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":559},"output_tokens":19,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CY1FKZwrbZ9JnDWkacFsn","type":"assistant","uuid":"ac7331a9-cb8d-40c5-9271-782011a8625e","timestamp":"2026-02-10T23:22:06.950Z"}
{"parentUuid":"ac7331a9-cb8d-40c5-9271-782011a8625e","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01SXKvbRzAn3jQPnXW8h1amt","type":"tool_result","content":"Updated task #4 status"}]},"uuid":"02a53079-99b7-4704-9a8f-2bc264ea5b88","timestamp":"2026-02-10T23:22:06.958Z","toolUseResult":{"success":true,"taskId":"4","updatedFields":["status"],"statusChange":{"from":"in_progress","to":"completed"}},"sourceToolAssistantUUID":"ac7331a9-cb8d-40c5-9271-782011a8625e"}
{"parentUuid":"02a53079-99b7-4704-9a8f-2bc264ea5b88","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","message":{"model":"claude-opus-4-6","id":"msg_01VC1Xs89DGcK8rYPwV3P2Cr","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_018dfmCWMFbjT2pTweEYXpQY","name":"TaskUpdate","input":{"taskId":"5","status":"in_progress"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":88,"cache_read_input_tokens":69846,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":88},"output_tokens":24,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CY1FL9dQLQH8DvMJ6qxbB","type":"assistant","uuid":"fe0adb7c-cbd7-4833-ade6-0254011706c9","timestamp":"2026-02-10T23:22:09.229Z"}
{"parentUuid":"fe0adb7c-cbd7-4833-ade6-0254011706c9","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_018dfmCWMFbjT2pTweEYXpQY","type":"tool_result","content":"Updated task #5 status"}]},"uuid":"14753a32-daea-473e-b1ab-d2ff4e1388b9","timestamp":"2026-02-10T23:22:09.232Z","toolUseResult":{"success":true,"taskId":"5","updatedFields":["status"],"statusChange":{"from":"pending","to":"in_progress"}},"sourceToolAssistantUUID":"fe0adb7c-cbd7-4833-ade6-0254011706c9"}
{"parentUuid":"14753a32-daea-473e-b1ab-d2ff4e1388b9","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","message":{"model":"claude-opus-4-6","id":"msg_017hHZnVG5Mz2qtU6z7LLdjU","type":"message","role":"assistant","content":[{"type":"text","text":"Now update `ldk.py` — first the CDK mode `_create_providers` to pass parsed resources:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":90,"cache_read_input_tokens":69934,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":90},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CY1FLK2T5zM5pHpN6fUdM","type":"assistant","uuid":"dc7480f0-a03c-40dd-83aa-9fe4c55665d1","timestamp":"2026-02-10T23:22:12.678Z"}
{"type":"file-history-snapshot","messageId":"9b73fd13-0622-452a-997b-2d0d2df55533","snapshot":{"messageId":"419d76bc-01da-47ab-8292-f6cf09dd2274","trackedFileBackups":{"src/lws/parser/assembly.py":{"backupFileName":"00df020cf1c04e6c@v1","version":1,"backupTime":"2026-02-10T23:21:01.336Z"},"src/lws/parser/tree_parser.py":{"backupFileName":"65fa9421a5a90c00@v1","version":1,"backupTime":"2026-02-10T23:21:36.827Z"},"src/lws/providers/ssm/routes.py":{"backupFileName":"d14e765b331d5a53@v1","version":1,"backupTime":"2026-02-10T23:21:47.270Z"},"src/lws/providers/secretsmanager/routes.py":{"backupFileName":"9face069ed21abb2@v1","version":1,"backupTime":"2026-02-10T23:21:59.102Z"},"src/lws/cli/ldk.py":{"backupFileName":"4f31122ba1afb3e8@v1","version":1,"backupTime":"2026-02-10T23:22:18.348Z"}},"timestamp":"2026-02-10T23:20:18.621Z"},"isSnapshotUpdate":true}
{"parentUuid":"dc7480f0-a03c-40dd-83aa-9fe4c55665d1","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","message":{"model":"claude-opus-4-6","id":"msg_017hHZnVG5Mz2qtU6z7LLdjU","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01JsHaiH9hvWKfWjWoFwWi9H","name":"Edit","input":{"replace_all":false,"file_path":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services/src/lws/cli/ldk.py","old_string":"    # 9. SSM Parameter Store and Secrets Manager\n    from lws.providers.secretsmanager.routes import create_secretsmanager_app\n    from lws.providers.ssm.routes import create_ssm_app\n\n    providers[\"__ssm_http__\"] = _HttpServiceProvider(\n        \"ssm-http\", create_ssm_app, ssm_port\n    )\n    providers[\"__secretsmanager_http__\"] = _HttpServiceProvider(\n        \"secretsmanager-http\", create_secretsmanager_app, secretsmanager_port\n    )","new_string":"    # 9. SSM Parameter Store and Secrets Manager (pre-seeded from CloudFormation)\n    from lws.providers.secretsmanager.routes import create_secretsmanager_app\n    from lws.providers.ssm.routes import create_ssm_app\n\n    ssm_params = [\n        {\"name\": p.name, \"type\": p.type, \"value\": p.value, \"description\": p.description}\n        for p in app_model.ssm_parameters\n    ]\n    sm_secrets = [\n        {\"name\": s.name, \"description\": s.description, \"secret_string\": s.secret_string}\n        for s in app_model.secrets\n    ]\n\n    providers[\"__ssm_http__\"] = _HttpServiceProvider(\n        \"ssm-http\", lambda: create_ssm_app(ssm_params), ssm_port\n    )\n    providers[\"__secretsmanager_http__\"] = _HttpServiceProvider(\n        \"secretsmanager-http\", lambda: create_secretsmanager_app(sm_secrets), secretsmanager_port\n    )"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":90,"cache_read_input_tokens":69934,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":90},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CY1FLK2T5zM5pHpN6fUdM","type":"assistant","uuid":"9b73fd13-0622-452a-997b-2d0d2df55533","timestamp":"2026-02-10T23:22:18.341Z"}
{"parentUuid":"9b73fd13-0622-452a-997b-2d0d2df55533","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"callback"},"parentToolUseID":"toolu_01JsHaiH9hvWKfWjWoFwWi9H","toolUseID":"toolu_01JsHaiH9hvWKfWjWoFwWi9H","timestamp":"2026-02-10T23:22:18.351Z","uuid":"da8f3912-90d8-4ac8-9991-246cd53feea8"}
{"parentUuid":"9b73fd13-0622-452a-997b-2d0d2df55533","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01JsHaiH9hvWKfWjWoFwWi9H","type":"tool_result","content":"The file /Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services/src/lws/cli/ldk.py has been updated successfully."}]},"uuid":"78b7014e-8134-44c9-9642-fc8b1046488e","timestamp":"2026-02-10T23:22:18.350Z","toolUseResult":{"filePath":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services/src/lws/cli/ldk.py","oldString":"    # 9. SSM Parameter Store and Secrets Manager\n    from lws.providers.secretsmanager.routes import create_secretsmanager_app\n    from lws.providers.ssm.routes import create_ssm_app\n\n    providers[\"__ssm_http__\"] = _HttpServiceProvider(\n        \"ssm-http\", create_ssm_app, ssm_port\n    )\n    providers[\"__secretsmanager_http__\"] = _HttpServiceProvider(\n        \"secretsmanager-http\", create_secretsmanager_app, secretsmanager_port\n    )","newString":"    # 9. SSM Parameter Store and Secrets Manager (pre-seeded from CloudFormation)\n    from lws.providers.secretsmanager.routes import create_secretsmanager_app\n    from lws.providers.ssm.routes import create_ssm_app\n\n    ssm_params = [\n        {\"name\": p.name, \"type\": p.type, \"value\": p.value, \"description\": p.description}\n        for p in app_model.ssm_parameters\n    ]\n    sm_secrets = [\n        {\"name\": s.name, \"description\": s.description, \"secret_string\": s.secret_string}\n        for s in app_model.secrets\n    ]\n\n    providers[\"__ssm_http__\"] = _HttpServiceProvider(\n        \"ssm-http\", lambda: create_ssm_app(ssm_params), ssm_port\n    )\n    providers[\"__secretsmanager_http__\"] = _HttpServiceProvider(\n        \"secretsmanager-http\", lambda: create_secretsmanager_app(sm_secrets), secretsmanager_port\n    )","originalFile":"\"\"\"LDK CLI entry point.\n\nProvides the ``ldk dev``, ``ldk invoke``, and ``ldk reset`` commands.\n``ldk dev`` parses a CDK cloud assembly, builds the application graph,\nstarts local providers, and watches for file changes.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport asyncio\nimport json\nimport logging\nimport shutil\nfrom collections.abc import Callable\nfrom pathlib import Path\nfrom typing import Any\n\nimport typer\nimport uvicorn\nfrom rich.console import Console\nfrom rich.syntax import Syntax\n\nfrom lws.cli.display import (\n    print_banner,\n    print_error,\n    print_resource_summary,\n    print_startup_complete,\n)\nfrom lws.config.loader import ConfigError, LdkConfig, load_config\nfrom lws.graph.builder import AppGraph, NodeType, build_graph\nfrom lws.interfaces import (\n    ComputeConfig,\n    GsiDefinition,\n    ICompute,\n    KeyAttribute,\n    KeySchema,\n    Provider,\n    TableConfig,\n)\nfrom lws.parser.assembly import AppModel, parse_assembly\nfrom lws.providers.apigateway.provider import ApiGatewayProvider, RouteConfig\nfrom lws.providers.cognito.provider import CognitoProvider\nfrom lws.providers.cognito.user_store import PasswordPolicy, UserPoolConfig\nfrom lws.providers.dynamodb.provider import SqliteDynamoProvider\nfrom lws.providers.dynamodb.routes import create_dynamodb_app\nfrom lws.providers.ecs.provider import EcsProvider\nfrom lws.providers.eventbridge.provider import (\n    EventBridgeProvider,\n    EventBusConfig,\n    RuleConfig,\n    RuleTarget,\n)\nfrom lws.providers.lambda_runtime.nodejs import NodeJsCompute\nfrom lws.providers.lambda_runtime.python import PythonCompute\nfrom lws.providers.s3.provider import S3Provider\nfrom lws.providers.s3.routes import create_s3_app\nfrom lws.providers.sns.provider import SnsProvider, TopicConfig\nfrom lws.providers.sns.routes import create_sns_app\nfrom lws.providers.sqs.provider import QueueConfig, RedrivePolicy, SqsProvider\nfrom lws.providers.sqs.routes import create_sqs_app\nfrom lws.providers.stepfunctions.provider import (\n    StateMachineConfig,\n    StepFunctionsProvider,\n    WorkflowType,\n)\nfrom lws.runtime.env_builder import build_lambda_env\nfrom lws.runtime.orchestrator import Orchestrator\nfrom lws.runtime.sdk_env import build_sdk_env\nfrom lws.runtime.synth import SynthError, ensure_synth\nfrom lws.runtime.watcher import FileWatcher\n\n_console = Console()\n\napp = typer.Typer(name=\"ldk\", help=\"Local Development Kit - Run AWS CDK applications locally\")\n\n__version__ = \"0.4.0\"\n\n\n@app.callback()\ndef main() -> None:\n    \"\"\"LDK - Local Development Kit.\"\"\"\n\n\n@app.command()\ndef dev(\n    port: int = typer.Option(None, \"--port\", \"-p\", help=\"API Gateway listen port\"),\n    no_persist: bool = typer.Option(False, \"--no-persist\", help=\"Disable data persistence\"),\n    force_synth: bool = typer.Option(False, \"--force-synth\", help=\"Force CDK synth\"),\n    log_level: str = typer.Option(\n        None, \"--log-level\", \"-l\", help=\"Log level (debug/info/warning/error)\"\n    ),\n    project_dir: Path = typer.Option(\".\", \"--project-dir\", \"-d\", help=\"Project root directory\"),\n    mode: str = typer.Option(None, \"--mode\", \"-m\", help=\"Project mode (cdk or terraform)\"),\n) -> None:\n    \"\"\"Start the local development environment.\"\"\"\n    try:\n        asyncio.run(_run_dev(project_dir, port, no_persist, force_synth, log_level, mode))\n    except KeyboardInterrupt:\n        pass\n\n\n@app.command()\ndef invoke(\n    function_name: str = typer.Option(..., \"--function-name\", \"-f\", help=\"Lambda function name\"),\n    event: str = typer.Option(None, \"--event\", \"-e\", help=\"Inline JSON event payload\"),\n    event_file: Path = typer.Option(None, \"--event-file\", help=\"Path to JSON event file\"),\n    project_dir: Path = typer.Option(\".\", \"--project-dir\", \"-d\", help=\"Project root directory\"),\n    port: int = typer.Option(None, \"--port\", \"-p\", help=\"Management API port\"),\n) -> None:\n    \"\"\"Invoke a Lambda function directly.\"\"\"\n    asyncio.run(_run_invoke(function_name, event, event_file, project_dir, port))\n\n\nasync def _run_invoke(\n    function_name: str,\n    event_json: str | None,\n    event_file: Path | None,\n    project_dir: Path,\n    port_override: int | None,\n) -> None:\n    \"\"\"Async implementation of the ``ldk invoke`` command.\"\"\"\n    # Resolve event payload\n    event_payload = _resolve_event_payload(event_json, event_file)\n\n    # Try connecting to running ldk dev via management API\n    project_dir = project_dir.resolve()\n    config = _load_config_quiet(project_dir)\n    mgmt_port = port_override or config.port\n\n    if await _try_management_invoke(mgmt_port, function_name, event_payload):\n        return\n\n    # Fallback: one-shot invocation\n    _console.print(\"[dim]No running ldk dev found, performing one-shot invocation...[/dim]\")\n    await _oneshot_invoke(project_dir, config, function_name, event_payload)\n\n\ndef _resolve_event_payload(event_json: str | None, event_file: Path | None) -> dict:\n    \"\"\"Parse event payload from CLI args.\"\"\"\n    if event_json is not None:\n        try:\n            return json.loads(event_json)\n        except json.JSONDecodeError as exc:\n            print_error(\"Invalid JSON in --event\", str(exc))\n            raise typer.Exit(1)\n\n    if event_file is not None:\n        if not event_file.exists():\n            print_error(\"Event file not found\", str(event_file))\n            raise typer.Exit(1)\n        try:\n            return json.loads(event_file.read_text())\n        except json.JSONDecodeError as exc:\n            print_error(\"Invalid JSON in event file\", str(exc))\n            raise typer.Exit(1)\n\n    return {}\n\n\nasync def _try_management_invoke(port: int, function_name: str, event: dict) -> bool:\n    \"\"\"Try to invoke via the management API. Return True if successful.\"\"\"\n    try:\n        import httpx\n\n        async with httpx.AsyncClient() as client:\n            resp = await client.post(\n                f\"http://localhost:{port}/_ldk/invoke\",\n                json={\"function_name\": function_name, \"event\": event},\n                timeout=30.0,\n            )\n            result = resp.json()\n            formatted = json.dumps(result, indent=2)\n            syntax = Syntax(formatted, \"json\", theme=\"monokai\")\n            _console.print(syntax)\n            return True\n    except Exception:\n        return False\n\n\nasync def _oneshot_invoke(\n    project_dir: Path, config: LdkConfig, function_name: str, event: dict\n) -> None:\n    \"\"\"Perform a one-shot Lambda invocation without a running server.\"\"\"\n    try:\n        import uuid as _uuid\n\n        from lws.interfaces import InvocationResult, LambdaContext\n\n        cdk_out = project_dir / config.cdk_out_dir\n        if not cdk_out.exists():\n            print_error(\"CDK output not found\", f\"Run 'cdk synth' first in {project_dir}\")\n            raise typer.Exit(1)\n\n        app_model = parse_assembly(cdk_out)\n        func_def = next((f for f in app_model.functions if f.name == function_name), None)\n        if func_def is None:\n            print_error(\"Function not found\", f\"No function named '{function_name}'\")\n            raise typer.Exit(1)\n\n        sdk_env = build_sdk_env({})\n        func_env = build_lambda_env(\n            function_name=func_def.name,\n            function_env=func_def.environment,\n            local_endpoints={},\n            resolved_refs={},\n        )\n        compute_config = ComputeConfig(\n            function_name=func_def.name,\n            handler=func_def.handler,\n            runtime=func_def.runtime,\n            code_path=func_def.code_path or Path(\".\"),\n            timeout=func_def.timeout,\n            memory_size=func_def.memory,\n            environment=func_env,\n        )\n        compute = NodeJsCompute(config=compute_config, sdk_env=sdk_env)\n        await compute.start()\n\n        request_id = str(_uuid.uuid4())\n        context = LambdaContext(\n            function_name=function_name,\n            memory_limit_in_mb=compute_config.memory_size,\n            timeout_seconds=compute_config.timeout,\n            aws_request_id=request_id,\n            invoked_function_arn=(\n                f\"arn:aws:lambda:us-east-1:000000000000:function:{function_name}\"\n            ),\n        )\n\n        result: InvocationResult = await compute.invoke(event, context)\n        await compute.stop()\n\n        output = result.payload if result.error is None else {\"error\": result.error}\n        formatted = json.dumps(output, indent=2, default=str)\n        syntax = Syntax(formatted, \"json\", theme=\"monokai\")\n        _console.print(syntax)\n\n    except typer.Exit:\n        raise\n    except Exception as exc:\n        print_error(\"Invocation failed\", str(exc))\n        raise typer.Exit(1)\n\n\n@app.command()\ndef reset(\n    yes: bool = typer.Option(False, \"--yes\", \"-y\", help=\"Skip confirmation prompt\"),\n    project_dir: Path = typer.Option(\".\", \"--project-dir\", \"-d\", help=\"Project root directory\"),\n    port: int = typer.Option(None, \"--port\", \"-p\", help=\"Management API port\"),\n) -> None:\n    \"\"\"Reset all LDK local state (databases, queues, etc.).\"\"\"\n    project_dir = project_dir.resolve()\n    config = _load_config_quiet(project_dir)\n    data_dir = project_dir / config.data_dir\n\n    if not data_dir.exists():\n        _console.print(\"[dim]No data directory found. Nothing to reset.[/dim]\")\n        return\n\n    # List contents to be deleted\n    items = list(data_dir.iterdir())\n    if not items:\n        _console.print(\"[dim]Data directory is empty. Nothing to reset.[/dim]\")\n        return\n\n    _console.print(f\"[bold]Will delete all files under:[/bold] {data_dir}\")\n    for item in items:\n        kind = \"dir\" if item.is_dir() else \"file\"\n        _console.print(f\"  [dim]{kind}:[/dim] {item.name}\")\n\n    if not yes:\n        confirm = typer.confirm(\"Are you sure you want to delete all local state?\")\n        if not confirm:\n            _console.print(\"[dim]Aborted.[/dim]\")\n            return\n\n    # Delete contents\n    deleted_count = 0\n    for item in items:\n        if item.is_dir():\n            shutil.rmtree(item)\n        else:\n            item.unlink()\n        deleted_count += 1\n\n    _console.print(f\"[green]Deleted {deleted_count} item(s) from {data_dir}[/green]\")\n\n    # Notify running ldk dev if possible\n    mgmt_port = port or config.port\n    asyncio.run(_try_management_reset(mgmt_port))\n\n\nasync def _try_management_reset(port: int) -> None:\n    \"\"\"Try to notify running ldk dev of the reset via management API.\"\"\"\n    try:\n        import httpx\n\n        async with httpx.AsyncClient() as client:\n            resp = await client.post(\n                f\"http://localhost:{port}/_ldk/reset\",\n                timeout=5.0,\n            )\n            if resp.status_code == 200:\n                _console.print(\"[dim]Notified running ldk dev of reset.[/dim]\")\n    except Exception:\n        pass  # Server not running, that's fine\n\n\ndef _load_config_quiet(project_dir: Path) -> LdkConfig:\n    \"\"\"Load config without printing errors. Falls back to defaults.\"\"\"\n    try:\n        return load_config(project_dir)\n    except ConfigError:\n        return LdkConfig()\n\n\ndef _load_and_apply_config(\n    project_dir: Path,\n    port_override: int | None,\n    no_persist: bool,\n    log_level_override: str | None,\n) -> LdkConfig:\n    \"\"\"Load config and apply CLI overrides.\"\"\"\n    try:\n        config = load_config(project_dir)\n    except ConfigError as exc:\n        print_error(\"Configuration error\", str(exc))\n        raise typer.Exit(1)\n\n    if port_override is not None:\n        config.port = port_override\n    if log_level_override is not None:\n        config.log_level = log_level_override\n    if no_persist:\n        config.persist = False\n\n    logging.basicConfig(\n        level=getattr(logging, config.log_level.upper(), logging.INFO),\n        format=\"%(levelname)s %(name)s: %(message)s\",\n    )\n    return config\n\n\ndef _collect_extra_resources(app_model: AppModel) -> dict[str, list[str]]:\n    \"\"\"Collect extra resource name lists from the app model for display.\"\"\"\n    extras: dict[str, list[str]] = {}\n    _RESOURCE_ATTRS = {\n        \"queues\": (\"name\", \"queues\"),\n        \"buckets\": (\"name\", \"buckets\"),\n        \"topics\": (\"name\", \"topics\"),\n        \"state_machines\": (\"name\", \"state_machines\"),\n        \"ecs_services\": (\"service_name\", \"ecs_services\"),\n        \"user_pools\": (\"user_pool_name\", \"user_pools\"),\n    }\n    for key, (attr, model_attr) in _RESOURCE_ATTRS.items():\n        items = getattr(app_model, model_attr, [])\n        if items:\n            extras[key] = [getattr(item, attr, str(item)) for item in items]\n    return extras\n\n\ndef _build_local_details(app_model: AppModel, port: int) -> dict[str, str]:\n    \"\"\"Build a mapping of ``\"Type:Name\"`` to local detail strings.\"\"\"\n    details: dict[str, str] = {}\n\n    _add_api_details(details, app_model)\n    _add_resource_details(details, app_model)\n    return details\n\n\ndef _add_api_details(details: dict[str, str], app_model: AppModel) -> None:\n    \"\"\"Add API route and Lambda function details.\"\"\"\n    for api_def in app_model.apis:\n        for r in api_def.routes:\n            details[f\"API Route:{r.path}\"] = (\n                f\"lws apigateway test-invoke-method --resource {r.path} --http-method {r.method}\"\n            )\n    for f in app_model.functions:\n        details[f\"Function:{f.name}\"] = f\"ldk invoke {f.name}\"\n\n\ndef _add_resource_details(details: dict[str, str], app_model: AppModel) -> None:\n    \"\"\"Add service resource details (DynamoDB, SQS, S3, etc.).\"\"\"\n    for t in app_model.tables:\n        details[f\"Table:{t.name}\"] = f\"lws dynamodb scan --table-name {t.name}\"\n    for q in app_model.queues:\n        details[f\"Queue:{q.name}\"] = f\"lws sqs receive-message --queue-name {q.name}\"\n    for b in app_model.buckets:\n        details[f\"Bucket:{b.name}\"] = f\"lws s3api list-objects-v2 --bucket {b.name}\"\n    for t in app_model.topics:\n        details[f\"Topic:{t.name}\"] = f\"lws sns publish --topic-name {t.name} --message '...'\"\n    for b in app_model.event_buses:\n        details[f\"Event Bus:{b.name}\"] = f\"lws events list-rules --event-bus-name {b.name}\"\n    for sm in app_model.state_machines:\n        details[f\"State Machine:{sm.name}\"] = f\"lws stepfunctions start-execution --name {sm.name}\"\n    for p in app_model.user_pools:\n        details[f\"User Pool:{p.user_pool_name}\"] = (\n            f\"lws cognito-idp sign-up --user-pool-name {p.user_pool_name}\"\n        )\n\n\ndef _display_summary(app_model: AppModel, port: int) -> None:\n    \"\"\"Print resource summary and startup-complete banner.\"\"\"\n    routes_info = [\n        {\"method\": r.method, \"path\": r.path, \"handler\": r.handler_name or \"\"}\n        for api_def in app_model.apis\n        for r in api_def.routes\n    ]\n    tables_info = [t.name for t in app_model.tables]\n    functions_info = [f\"{f.name} ({f.runtime})\" for f in app_model.functions]\n\n    extra_resources = _collect_extra_resources(app_model)\n    local_details = _build_local_details(app_model, port)\n    print_resource_summary(\n        routes_info, tables_info, functions_info, local_details=local_details, **extra_resources\n    )\n\n    extra_counts = {f\"num_{k}\": len(v) for k, v in extra_resources.items()}\n    print_startup_complete(\n        port,\n        num_routes=len(routes_info),\n        num_tables=len(tables_info),\n        num_functions=len(functions_info),\n        **extra_counts,\n    )\n\n\ndef _resolve_mode(project_dir: Path, config: LdkConfig, mode_override: str | None) -> str:\n    \"\"\"Resolve the project mode from CLI flag, config, or auto-detection.\n\n    Returns ``\"cdk\"`` or ``\"terraform\"``.\n    Raises ``typer.Exit(1)`` on error.\n    \"\"\"\n    from lws.terraform.detect import detect_project_type\n\n    mode = mode_override or config.mode\n    if mode:\n        if mode not in (\"cdk\", \"terraform\"):\n            print_error(\"Invalid mode\", f\"Must be 'cdk' or 'terraform', got '{mode}'\")\n            raise typer.Exit(1)\n        return mode\n\n    detected = detect_project_type(project_dir)\n    if detected == \"ambiguous\":\n        print_error(\n            \"Ambiguous project\",\n            \"Both .tf files and cdk.out found. Use --mode cdk or --mode terraform.\",\n        )\n        raise typer.Exit(1)\n    if detected == \"none\":\n        print_error(\n            \"No project found\",\n            \"No .tf files or cdk.out directory found. \"\n            \"Run from a CDK or Terraform project directory.\",\n        )\n        raise typer.Exit(1)\n    return detected\n\n\nasync def _run_dev_terraform(project_dir: Path, config: LdkConfig) -> None:\n    \"\"\"Run the dev server in Terraform mode.\n\n    Starts all service providers in always-on mode, generates the\n    Terraform provider override file, and waits for shutdown.\n    \"\"\"\n    from lws.terraform.gitignore import ensure_gitignore\n    from lws.terraform.override import cleanup_override, generate_override\n\n    port = config.port\n    data_dir = project_dir / config.data_dir\n    data_dir.mkdir(parents=True, exist_ok=True)\n\n    # Generate override file\n    try:\n        override_path = generate_override(port, project_dir)\n    except FileExistsError as exc:\n        print_error(\"Override file conflict\", str(exc))\n        raise typer.Exit(1)\n\n    ensure_gitignore(project_dir)\n\n    # Create all providers in always-on mode (no app model)\n    providers, ports = _create_terraform_providers(config, data_dir, project_dir)\n\n    orchestrator = Orchestrator()\n\n    # Enable WebSocket log streaming\n    from lws.logging.logger import WebSocketLogHandler, set_ws_handler\n\n    ws_log_handler = WebSocketLogHandler()\n    set_ws_handler(ws_log_handler)\n\n    # Build resource metadata so the CLI client can discover services\n    resource_metadata: dict[str, Any] = {\n        \"port\": port,\n        \"services\": {\n            svc_name: {\"port\": svc_port, \"resources\": []} for svc_name, svc_port in ports.items()\n        },\n    }\n\n    # Mount management API (no compute providers in terraform mode)\n    _mount_management_api(providers, orchestrator, {}, port, resource_metadata)\n\n    for key in providers:\n        pass  # All keys are already in the dict\n\n    startup_order = list(providers.keys())\n\n    try:\n        await orchestrator.start(providers, startup_order)\n    except Exception as exc:\n        cleanup_override(project_dir)\n        print_error(\"Failed to start providers\", str(exc))\n        raise typer.Exit(1)\n\n    # Display summary\n    _console.print()\n    _console.print(\"[bold green]Terraform mode active[/bold green]\")\n    _console.print(f\"  Override file: {override_path}\")\n    _console.print()\n    _console.print(\"[bold]Service endpoints:[/bold]\")\n    for svc_name, svc_port in sorted(ports.items()):\n        _console.print(f\"  {svc_name:20s} http://localhost:{svc_port}\")\n    _console.print()\n    _console.print(\"[dim]Run 'terraform init && terraform apply' to create resources.[/dim]\")\n    _console.print(f\"  Dashboard: http://localhost:{config.port}/_ldk/gui\")\n    _console.print()\n\n    try:\n        await orchestrator.wait_for_shutdown()\n    finally:\n        cleanup_override(project_dir)\n        set_ws_handler(None)\n        await orchestrator.stop()\n        typer.echo(\"Goodbye\")\n\n\ndef _create_terraform_providers(\n    config: LdkConfig,\n    data_dir: Path,\n    project_dir: Path | None = None,\n) -> tuple[dict[str, Provider], dict[str, int]]:\n    \"\"\"Create all service providers for Terraform mode (no app model).\"\"\"\n    providers: dict[str, Provider] = {}\n\n    port = config.port\n    ports = {\n        \"dynamodb\": port + 1,\n        \"sqs\": port + 2,\n        \"s3\": port + 3,\n        \"sns\": port + 4,\n        \"eventbridge\": port + 5,\n        \"stepfunctions\": port + 6,\n        \"cognito\": port + 7,\n        \"apigateway\": port + 8,\n        \"lambda\": port + 9,\n        \"iam\": port + 10,\n        \"sts\": port + 11,\n        \"ssm\": port + 12,\n        \"secretsmanager\": port + 13,\n    }\n\n    dynamo_provider = SqliteDynamoProvider(data_dir=data_dir, tables=[])\n    sqs_provider = SqsProvider()\n    s3_provider = S3Provider(data_dir=data_dir)\n    sns_provider = SnsProvider()\n    eb_provider = EventBridgeProvider()\n    sf_provider = StepFunctionsProvider()\n\n    pool_config = UserPoolConfig(\n        user_pool_id=\"us-east-1_default\",\n        user_pool_name=\"default\",\n    )\n    cognito_provider = CognitoProvider(data_dir=data_dir, config=pool_config)\n\n    _register_http_providers(\n        providers,\n        dynamo_provider=dynamo_provider,\n        sqs_provider=sqs_provider,\n        s3_provider=s3_provider,\n        sns_provider=sns_provider,\n        eb_provider=eb_provider,\n        sf_provider=sf_provider,\n        cognito_provider=cognito_provider,\n        ports=ports,\n    )\n\n    # Shared Lambda registry for Lambda management and API Gateway V2 proxy\n    from lws.providers.lambda_runtime.routes import LambdaRegistry, create_lambda_management_app\n\n    lambda_registry = LambdaRegistry()\n\n    # Wire Lambda registry compute providers into Step Functions so SFN can\n    # invoke Lambda functions that Terraform creates dynamically.\n    sf_provider.set_compute_providers(lambda_registry._compute)\n\n    # Build SDK env so Lambda functions can reach local services\n    local_endpoints: dict[str, str] = {\n        \"dynamodb\": f\"http://127.0.0.1:{ports['dynamodb']}\",\n        \"sqs\": f\"http://127.0.0.1:{ports['sqs']}\",\n        \"s3\": f\"http://127.0.0.1:{ports['s3']}\",\n        \"sns\": f\"http://127.0.0.1:{ports['sns']}\",\n        \"events\": f\"http://127.0.0.1:{ports['eventbridge']}\",\n        \"stepfunctions\": f\"http://127.0.0.1:{ports['stepfunctions']}\",\n        \"cognito-idp\": f\"http://127.0.0.1:{ports['cognito']}\",\n        \"ssm\": f\"http://127.0.0.1:{ports['ssm']}\",\n        \"secretsmanager\": f\"http://127.0.0.1:{ports['secretsmanager']}\",\n    }\n    sdk_env = build_sdk_env(local_endpoints)\n\n    # Lambda management API\n    providers[\"__lambda_http__\"] = _HttpServiceProvider(\n        \"lambda-http\",\n        lambda: create_lambda_management_app(lambda_registry, project_dir, sdk_env),\n        ports[\"lambda\"],\n    )\n\n    # API Gateway management API with V2 support and Lambda proxy\n    from lws.providers.apigateway.routes import create_apigateway_management_app\n\n    providers[\"__apigateway_http__\"] = _HttpServiceProvider(\n        \"apigateway-http\",\n        lambda: create_apigateway_management_app(lambda_registry),\n        ports[\"apigateway\"],\n    )\n\n    # IAM stub\n    from lws.providers.iam.routes import create_iam_app\n\n    providers[\"__iam_http__\"] = _HttpServiceProvider(\"iam-http\", create_iam_app, ports[\"iam\"])\n\n    # STS stub\n    from lws.providers.sts.routes import create_sts_app\n\n    providers[\"__sts_http__\"] = _HttpServiceProvider(\"sts-http\", create_sts_app, ports[\"sts\"])\n\n    # SSM Parameter Store\n    from lws.providers.ssm.routes import create_ssm_app\n\n    providers[\"__ssm_http__\"] = _HttpServiceProvider(\"ssm-http\", create_ssm_app, ports[\"ssm\"])\n\n    # Secrets Manager\n    from lws.providers.secretsmanager.routes import create_secretsmanager_app\n\n    providers[\"__secretsmanager_http__\"] = _HttpServiceProvider(\n        \"secretsmanager-http\", create_secretsmanager_app, ports[\"secretsmanager\"]\n    )\n\n    return providers, ports\n\n\ndef _has_any_resources(app_model: AppModel) -> bool:\n    \"\"\"Return True if the app model contains at least one resource.\"\"\"\n    return bool(\n        app_model.functions\n        or app_model.tables\n        or app_model.apis\n        or app_model.queues\n        or app_model.buckets\n        or app_model.topics\n        or app_model.event_buses\n        or app_model.state_machines\n        or app_model.ecs_services\n        or app_model.user_pools\n    )\n\n\nasync def _run_dev(\n    project_dir: Path,\n    port_override: int | None,\n    no_persist: bool,\n    force_synth: bool,\n    log_level_override: str | None,\n    mode_override: str | None = None,\n) -> None:\n    \"\"\"Async implementation of the ``ldk dev`` command.\"\"\"\n    project_dir = project_dir.resolve()\n    config = _load_and_apply_config(project_dir, port_override, no_persist, log_level_override)\n    print_banner(__version__, project_dir.name)\n\n    # Resolve project mode\n    resolved_mode = _resolve_mode(project_dir, config, mode_override)\n    if resolved_mode == \"terraform\":\n        await _run_dev_terraform(project_dir, config)\n        return\n\n    try:\n        cdk_out = await ensure_synth(project_dir, force=force_synth)\n    except SynthError as exc:\n        print_error(\"CDK synth failed\", str(exc))\n        raise typer.Exit(1)\n\n    app_model = parse_assembly(cdk_out)\n    if not _has_any_resources(app_model):\n        print_error(\"No resources found in cloud assembly\", str(cdk_out))\n        raise typer.Exit(1)\n\n    graph = build_graph(app_model)\n    startup_order = graph.topological_sort()\n\n    data_dir = project_dir / config.data_dir\n    data_dir.mkdir(parents=True, exist_ok=True)\n    providers, compute_providers = _create_providers(app_model, graph, config, data_dir)\n\n    orchestrator = Orchestrator()\n\n    # Enable WebSocket log streaming\n    from lws.logging.logger import WebSocketLogHandler, set_ws_handler\n\n    ws_log_handler = WebSocketLogHandler()\n    set_ws_handler(ws_log_handler)\n\n    # Mount management API\n    resource_metadata = _build_resource_metadata(app_model, config.port)\n    _mount_management_api(\n        providers, orchestrator, compute_providers, config.port, resource_metadata\n    )\n\n    # Append non-graph provider keys (HTTP servers, management) to startup order.\n    # This must happen after _mount_management_api so the fallback management\n    # HTTP server (when no API Gateway exists) is included in the startup order.\n    for key in providers:\n        if key not in startup_order:\n            startup_order.append(key)\n\n    try:\n        await orchestrator.start(providers, startup_order)\n    except Exception as exc:\n        print_error(\"Failed to start providers\", str(exc))\n        raise typer.Exit(1)\n\n    _display_summary(app_model, config.port)\n    typer.echo(f\"  Dashboard: http://localhost:{config.port}/_ldk/gui\")\n\n    watcher = FileWatcher(\n        watch_dir=project_dir,\n        include_patterns=config.watch_include,\n        exclude_patterns=config.watch_exclude,\n    )\n    watcher.on_change(lambda path: logging.getLogger(\"ldk.watcher\").info(\"Changed: %s\", path))\n    watcher.start()\n\n    try:\n        await orchestrator.wait_for_shutdown()\n    finally:\n        watcher.stop()\n        set_ws_handler(None)\n        await orchestrator.stop()\n        typer.echo(\"Goodbye\")\n\n\ndef _create_dynamo_providers(\n    app_model: AppModel,\n    graph: AppGraph,\n    data_dir: Path,\n) -> tuple[SqliteDynamoProvider, dict[str, Provider]]:\n    \"\"\"Create DynamoDB table providers from the app model.\n\n    Always returns a provider (even with no CDK tables) so the DynamoDB\n    HTTP endpoint is available for Terraform/CLI table creation.\n    \"\"\"\n    providers: dict[str, Provider] = {}\n    table_configs: list[TableConfig] = []\n    for table in app_model.tables:\n        ks = _build_key_schema(table.key_schema)\n        gsi_defs = [_build_gsi(g) for g in table.gsi_definitions]\n        table_configs.append(\n            TableConfig(table_name=table.name, key_schema=ks, gsi_definitions=gsi_defs)\n        )\n\n    dynamo_provider = SqliteDynamoProvider(data_dir=data_dir, tables=table_configs)\n    for table in app_model.tables:\n        node_id = _find_node_id(graph, NodeType.DYNAMODB_TABLE, table.name)\n        if node_id:\n            providers[node_id] = dynamo_provider\n    return dynamo_provider, providers\n\n\ndef _create_compute_providers(\n    app_model: AppModel,\n    graph: AppGraph,\n    local_endpoints: dict[str, str],\n    sdk_env: dict[str, str],\n) -> tuple[dict[str, ICompute], dict[str, Provider]]:\n    \"\"\"Create Lambda compute providers from the app model (Node.js + Python).\"\"\"\n    providers: dict[str, Provider] = {}\n    compute_providers: dict[str, ICompute] = {}\n    for func in app_model.functions:\n        func_env = build_lambda_env(\n            function_name=func.name,\n            function_env=func.environment,\n            local_endpoints=local_endpoints,\n            resolved_refs={},\n        )\n        compute_config = ComputeConfig(\n            function_name=func.name,\n            handler=func.handler,\n            runtime=func.runtime,\n            code_path=func.code_path or Path(\".\"),\n            timeout=func.timeout,\n            memory_size=func.memory,\n            environment=func_env,\n        )\n        if func.runtime.startswith(\"python\"):\n            compute: ICompute = PythonCompute(config=compute_config, sdk_env=sdk_env)\n        elif func.runtime.startswith(\"nodejs\"):\n            compute = NodeJsCompute(config=compute_config, sdk_env=sdk_env)\n        else:\n            logging.getLogger(\"ldk.cli\").warning(\n                \"Unsupported runtime %s for %s, skipping\", func.runtime, func.name\n            )\n            continue\n        compute_providers[func.name] = compute\n        node_id = _find_node_id(graph, NodeType.LAMBDA_FUNCTION, func.name)\n        if node_id:\n            providers[node_id] = compute\n    return compute_providers, providers\n\n\ndef _create_api_providers(\n    app_model: AppModel,\n    graph: AppGraph,\n    compute_providers: dict[str, ICompute],\n    port: int,\n) -> tuple[ApiGatewayProvider | None, dict[str, Provider]]:\n    \"\"\"Create API Gateway providers from the app model.\"\"\"\n    providers: dict[str, Provider] = {}\n    api_provider: ApiGatewayProvider | None = None\n    for api_def in app_model.apis:\n        route_configs = [\n            RouteConfig(method=r.method, path=r.path, handler_name=r.handler_name)\n            for r in api_def.routes\n            if r.handler_name and r.handler_name in compute_providers\n        ]\n        if route_configs:\n            api_provider = ApiGatewayProvider(\n                routes=route_configs, compute_providers=compute_providers, port=port\n            )\n            node_id = _find_node_id(graph, NodeType.API_GATEWAY, api_def.name)\n            if node_id:\n                providers[node_id] = api_provider\n    return api_provider, providers\n\n\ndef _create_sqs_providers(\n    app_model: AppModel,\n    graph: AppGraph,\n) -> tuple[SqsProvider, dict[str, Provider]]:\n    \"\"\"Create SQS queue providers from the app model.\n\n    Always returns a provider (even with no CDK queues) so the SQS\n    HTTP endpoint is available for Terraform/CLI queue creation.\n    \"\"\"\n    providers: dict[str, Provider] = {}\n    queue_configs = []\n    for q in app_model.queues:\n        redrive = None\n        if q.redrive_target:\n            redrive = RedrivePolicy(\n                dead_letter_queue_name=q.redrive_target, max_receive_count=q.max_receive_count\n            )\n        queue_configs.append(\n            QueueConfig(\n                queue_name=q.name,\n                visibility_timeout=q.visibility_timeout,\n                is_fifo=q.is_fifo,\n                content_based_dedup=q.content_based_dedup,\n                redrive_policy=redrive,\n            )\n        )\n    sqs_provider = SqsProvider(queues=queue_configs if queue_configs else None)\n    for q in app_model.queues:\n        node_id = _find_node_id(graph, NodeType.SQS_QUEUE, q.name)\n        if node_id:\n            providers[node_id] = sqs_provider\n    return sqs_provider, providers\n\n\ndef _create_s3_providers(\n    app_model: AppModel,\n    graph: AppGraph,\n    data_dir: Path,\n) -> tuple[S3Provider, dict[str, Provider]]:\n    \"\"\"Create S3 bucket providers from the app model.\n\n    Always returns a provider (even with no CDK buckets) so the S3\n    HTTP endpoint is available for Terraform/CLI bucket creation.\n    \"\"\"\n    providers: dict[str, Provider] = {}\n    bucket_names = [b.name for b in app_model.buckets]\n    s3_provider = S3Provider(data_dir=data_dir, buckets=bucket_names if bucket_names else None)\n    for b in app_model.buckets:\n        node_id = _find_node_id(graph, NodeType.S3_BUCKET, b.name)\n        if node_id:\n            providers[node_id] = s3_provider\n    return s3_provider, providers\n\n\ndef _create_sns_providers(\n    app_model: AppModel,\n    graph: AppGraph,\n) -> tuple[SnsProvider, dict[str, Provider]]:\n    \"\"\"Create SNS topic providers from the app model.\n\n    Always returns a provider (even with no CDK topics) so the SNS\n    HTTP endpoint is available for Terraform/CLI topic creation.\n    \"\"\"\n    providers: dict[str, Provider] = {}\n    topic_configs = [\n        TopicConfig(topic_name=t.name, topic_arn=t.topic_arn) for t in app_model.topics\n    ]\n    sns_provider = SnsProvider(topics=topic_configs if topic_configs else None)\n    for t in app_model.topics:\n        node_id = _find_node_id(graph, NodeType.SNS_TOPIC, t.name)\n        if node_id:\n            providers[node_id] = sns_provider\n    return sns_provider, providers\n\n\ndef _create_eventbridge_providers(\n    app_model: AppModel,\n    graph: AppGraph,\n) -> tuple[EventBridgeProvider, dict[str, Provider]]:\n    \"\"\"Create EventBridge providers from the app model.\n\n    Always returns a provider (even with no CDK buses) so the EventBridge\n    HTTP endpoint is available for Terraform/CLI event bus creation.\n    \"\"\"\n    providers: dict[str, Provider] = {}\n    bus_configs = [\n        EventBusConfig(bus_name=b.name, bus_arn=b.bus_arn) for b in app_model.event_buses\n    ]\n    rule_configs = []\n    for r in app_model.event_rules:\n        targets = [\n            RuleTarget(target_id=t[\"target_id\"], arn=t[\"arn\"], input_path=t.get(\"input_path\"))\n            for t in r.targets\n        ]\n        rule_configs.append(\n            RuleConfig(\n                rule_name=r.rule_name,\n                event_bus_name=r.event_bus_name,\n                event_pattern=r.event_pattern,\n                schedule_expression=r.schedule_expression,\n                targets=targets,\n            )\n        )\n    eb_provider = EventBridgeProvider(\n        buses=bus_configs if bus_configs else None,\n        rules=rule_configs if rule_configs else None,\n    )\n    for b in app_model.event_buses:\n        node_id = _find_node_id(graph, NodeType.EVENT_BUS, b.name)\n        if node_id:\n            providers[node_id] = eb_provider\n    return eb_provider, providers\n\n\ndef _create_stepfunctions_providers(\n    app_model: AppModel,\n    graph: AppGraph,\n) -> tuple[StepFunctionsProvider, dict[str, Provider]]:\n    \"\"\"Create Step Functions providers from the app model.\n\n    Always returns a provider (even with no CDK state machines) so the\n    Step Functions HTTP endpoint is available for Terraform/CLI creation.\n    \"\"\"\n    providers: dict[str, Provider] = {}\n    sm_configs = []\n    for sm in app_model.state_machines:\n        wf_type = WorkflowType.EXPRESS if sm.workflow_type == \"EXPRESS\" else WorkflowType.STANDARD\n        sm_configs.append(\n            StateMachineConfig(\n                name=sm.name,\n                definition=sm.definition,\n                workflow_type=wf_type,\n                role_arn=sm.role_arn,\n                definition_substitutions=sm.definition_substitutions,\n            )\n        )\n    sf_provider = StepFunctionsProvider(\n        state_machines=sm_configs if sm_configs else None,\n    )\n    for sm in app_model.state_machines:\n        node_id = _find_node_id(graph, NodeType.STATE_MACHINE, sm.name)\n        if node_id:\n            providers[node_id] = sf_provider\n    return sf_provider, providers\n\n\ndef _create_ecs_providers(\n    app_model: AppModel,\n    graph: AppGraph,\n) -> tuple[EcsProvider, dict[str, Provider]]:\n    \"\"\"Create ECS service providers from the app model.\n\n    Always returns a provider (even with no CDK services).\n    \"\"\"\n    providers: dict[str, Provider] = {}\n    ecs_provider = EcsProvider(\n        services=app_model.ecs_services if app_model.ecs_services else None,\n    )\n    for svc in app_model.ecs_services:\n        svc_name = getattr(svc, \"service_name\", str(id(svc)))\n        node_id = _find_node_id(graph, NodeType.ECS_SERVICE, svc_name)\n        if node_id:\n            providers[node_id] = ecs_provider\n    return ecs_provider, providers\n\n\ndef _create_cognito_providers(\n    app_model: AppModel,\n    data_dir: Path,\n    compute_providers: dict[str, ICompute],\n) -> tuple[CognitoProvider, dict[str, Provider]]:\n    \"\"\"Create Cognito user pool providers from the app model.\n\n    Always returns a provider (even with no CDK user pools) so the\n    Cognito HTTP endpoint is available for Terraform/CLI user pool creation.\n    \"\"\"\n    providers: dict[str, Provider] = {}\n    if not app_model.user_pools:\n        pool_config = UserPoolConfig(\n            user_pool_id=\"us-east-1_default\",\n            user_pool_name=\"default\",\n        )\n        cognito_provider = CognitoProvider(data_dir=data_dir, config=pool_config)\n        return cognito_provider, providers\n    # Use the first user pool (multi-pool support can be added later)\n    pool = app_model.user_pools[0]\n    pw = pool.password_policy\n    password_policy = PasswordPolicy(\n        minimum_length=int(pw.get(\"MinimumLength\", 8)),\n        require_lowercase=bool(pw.get(\"RequireLowercase\", True)),\n        require_uppercase=bool(pw.get(\"RequireUppercase\", True)),\n        require_digits=bool(pw.get(\"RequireNumbers\", pw.get(\"RequireDigits\", True))),\n        require_symbols=bool(pw.get(\"RequireSymbols\", False)),\n    )\n    pool_config = UserPoolConfig(\n        user_pool_id=f\"us-east-1_{pool.logical_id}\",\n        user_pool_name=pool.user_pool_name,\n        password_policy=password_policy,\n        auto_confirm=pool.auto_confirm,\n        client_id=pool.client_id or \"local-client-id\",\n        pre_authentication_trigger=pool.pre_auth_trigger,\n        post_confirmation_trigger=pool.post_confirm_trigger,\n    )\n    trigger_funcs = {}\n    if pool.pre_auth_trigger and pool.pre_auth_trigger in compute_providers:\n        trigger_funcs[\"PreAuthentication\"] = compute_providers[pool.pre_auth_trigger]\n    if pool.post_confirm_trigger and pool.post_confirm_trigger in compute_providers:\n        trigger_funcs[\"PostConfirmation\"] = compute_providers[pool.post_confirm_trigger]\n    cognito_provider = CognitoProvider(\n        data_dir=data_dir, config=pool_config, trigger_functions=trigger_funcs or None\n    )\n    providers[f\"__cognito_{pool.logical_id}__\"] = cognito_provider\n    return cognito_provider, providers\n\n\ndef _wire_remaining_providers(\n    app_model: AppModel,\n    graph: AppGraph,\n    providers: dict[str, Provider],\n    compute_providers: dict[str, ICompute],\n    sqs_provider: SqsProvider,\n    local_endpoints: dict[str, str],\n    data_dir: Path,\n    api_port: int,\n    *,\n    sns_port: int,\n    eb_port: int,\n    sf_port: int,\n    cognito_port: int,\n) -> tuple[\n    SnsProvider,\n    EventBridgeProvider,\n    StepFunctionsProvider,\n    CognitoProvider,\n]:\n    \"\"\"Wire messaging, cognito, and API Gateway providers.\"\"\"\n    sns_provider, sns_providers = _create_sns_providers(app_model, graph)\n    providers.update(sns_providers)\n    sns_provider.set_compute_providers(compute_providers)\n    sns_provider.set_queue_provider(sqs_provider)\n    local_endpoints[\"sns\"] = f\"http://127.0.0.1:{sns_port}\"\n\n    eb_provider, eb_providers = _create_eventbridge_providers(app_model, graph)\n    providers.update(eb_providers)\n    eb_provider.set_compute_providers(compute_providers)\n    local_endpoints[\"events\"] = f\"http://127.0.0.1:{eb_port}\"\n\n    sf_provider, sf_providers = _create_stepfunctions_providers(app_model, graph)\n    providers.update(sf_providers)\n    sf_provider.set_compute_providers(compute_providers)\n    local_endpoints[\"stepfunctions\"] = f\"http://127.0.0.1:{sf_port}\"\n\n    cognito_provider, cognito_providers = _create_cognito_providers(\n        app_model, data_dir, compute_providers\n    )\n    providers.update(cognito_providers)\n    local_endpoints[\"cognito-idp\"] = f\"http://127.0.0.1:{cognito_port}\"\n\n    api_provider, api_providers = _create_api_providers(\n        app_model, graph, compute_providers, api_port\n    )\n    providers.update(api_providers)\n\n    return sns_provider, eb_provider, sf_provider, cognito_provider\n\n\ndef _create_providers(\n    app_model: AppModel,\n    graph: AppGraph,\n    config: LdkConfig,\n    data_dir: Path,\n) -> tuple[dict[str, Provider], dict[str, ICompute]]:\n    \"\"\"Instantiate providers from the parsed app model.\n\n    Returns a tuple of (provider map, compute_providers).\n    \"\"\"\n    providers: dict[str, Provider] = {}\n\n    # Port allocation: base+1 DynamoDB, +2 SQS, +3 S3, +4 SNS, +5 EventBridge,\n    # +6 Step Functions, +7 Cognito, +12 SSM, +13 Secrets Manager\n    dynamo_port = config.port + 1\n    sqs_port = config.port + 2\n    s3_port = config.port + 3\n    sns_port = config.port + 4\n    eb_port = config.port + 5\n    sf_port = config.port + 6\n    cognito_port = config.port + 7\n    ssm_port = config.port + 12\n    secretsmanager_port = config.port + 13\n\n    # 1. Storage providers (no deps)\n    dynamo_provider, dynamo_providers = _create_dynamo_providers(app_model, graph, data_dir)\n    providers.update(dynamo_providers)\n\n    sqs_provider, sqs_providers = _create_sqs_providers(app_model, graph)\n    providers.update(sqs_providers)\n\n    s3_provider, s3_providers = _create_s3_providers(app_model, graph, data_dir)\n    providers.update(s3_providers)\n\n    # 2. Build local_endpoints for SDK env redirection\n    local_endpoints: dict[str, str] = {}\n    local_endpoints[\"dynamodb\"] = f\"http://127.0.0.1:{dynamo_port}\"\n    local_endpoints[\"sqs\"] = f\"http://127.0.0.1:{sqs_port}\"\n    local_endpoints[\"s3\"] = f\"http://127.0.0.1:{s3_port}\"\n\n    # 3. Compute (Lambda — Node.js + Python)\n    sdk_env = build_sdk_env(local_endpoints)\n    compute_providers, compute_graph_providers = _create_compute_providers(\n        app_model, graph, local_endpoints, sdk_env\n    )\n    providers.update(compute_graph_providers)\n\n    # 4-6. Messaging, ECS, Cognito, API Gateway\n    sns_provider, eb_provider, sf_provider, cognito_provider = _wire_remaining_providers(\n        app_model,\n        graph,\n        providers,\n        compute_providers,\n        sqs_provider,\n        local_endpoints,\n        data_dir,\n        config.port,\n        sns_port=sns_port,\n        eb_port=eb_port,\n        sf_port=sf_port,\n        cognito_port=cognito_port,\n    )\n    ecs_provider, ecs_providers = _create_ecs_providers(app_model, graph)\n    providers.update(ecs_providers)\n\n    # 7. Add SSM and Secrets Manager endpoints, rebuild SDK env, update compute\n    local_endpoints[\"ssm\"] = f\"http://127.0.0.1:{ssm_port}\"\n    local_endpoints[\"secretsmanager\"] = f\"http://127.0.0.1:{secretsmanager_port}\"\n    sdk_env = build_sdk_env(local_endpoints)\n    for compute in compute_providers.values():\n        if hasattr(compute, \"_sdk_env\"):\n            compute._sdk_env = sdk_env\n\n    # 8. Create HTTP servers for each active service\n    _register_http_providers(\n        providers,\n        dynamo_provider=dynamo_provider,\n        sqs_provider=sqs_provider,\n        s3_provider=s3_provider,\n        sns_provider=sns_provider,\n        eb_provider=eb_provider,\n        sf_provider=sf_provider,\n        cognito_provider=cognito_provider,\n        ports={\n            \"dynamodb\": dynamo_port,\n            \"sqs\": sqs_port,\n            \"s3\": s3_port,\n            \"sns\": sns_port,\n            \"eventbridge\": eb_port,\n            \"stepfunctions\": sf_port,\n            \"cognito\": cognito_port,\n        },\n    )\n\n    # 9. SSM Parameter Store and Secrets Manager\n    from lws.providers.secretsmanager.routes import create_secretsmanager_app\n    from lws.providers.ssm.routes import create_ssm_app\n\n    providers[\"__ssm_http__\"] = _HttpServiceProvider(\n        \"ssm-http\", create_ssm_app, ssm_port\n    )\n    providers[\"__secretsmanager_http__\"] = _HttpServiceProvider(\n        \"secretsmanager-http\", create_secretsmanager_app, secretsmanager_port\n    )\n\n    return providers, compute_providers\n\n\ndef _register_http_providers(\n    providers: dict[str, Provider],\n    *,\n    dynamo_provider: SqliteDynamoProvider,\n    sqs_provider: SqsProvider,\n    s3_provider: S3Provider,\n    sns_provider: SnsProvider,\n    eb_provider: EventBridgeProvider,\n    sf_provider: StepFunctionsProvider,\n    cognito_provider: CognitoProvider,\n    ports: dict[str, int],\n) -> None:\n    \"\"\"Register HTTP service providers for each active backend.\"\"\"\n    from lws.providers.cognito.routes import create_cognito_app\n    from lws.providers.eventbridge.routes import create_eventbridge_app\n    from lws.providers.stepfunctions.routes import create_stepfunctions_app\n\n    http_services: list[tuple[str, Any, Callable[[], Any]]] = []\n    http_services.append(\n        (\"dynamodb\", ports[\"dynamodb\"], lambda p=dynamo_provider: create_dynamodb_app(p))\n    )\n    http_services.append(\n        (\"sqs\", ports[\"sqs\"], lambda p=sqs_provider, pt=ports[\"sqs\"]: create_sqs_app(p, pt))\n    )\n    http_services.append((\"s3\", ports[\"s3\"], lambda p=s3_provider: create_s3_app(p)))\n    http_services.append((\"sns\", ports[\"sns\"], lambda p=sns_provider: create_sns_app(p)))\n    http_services.append(\n        (\"eventbridge\", ports[\"eventbridge\"], lambda p=eb_provider: create_eventbridge_app(p))\n    )\n    http_services.append(\n        (\n            \"stepfunctions\",\n            ports[\"stepfunctions\"],\n            lambda p=sf_provider: create_stepfunctions_app(p),\n        )\n    )\n    http_services.append(\n        (\"cognito\", ports[\"cognito\"], lambda p=cognito_provider: create_cognito_app(p))\n    )\n\n    for svc_name, port, factory in http_services:\n        providers[f\"__{svc_name}_http__\"] = _HttpServiceProvider(f\"{svc_name}-http\", factory, port)\n\n\nclass _HttpServiceProvider(Provider):\n    \"\"\"Generic wrapper that runs any FastAPI app as a uvicorn-served Provider.\"\"\"\n\n    def __init__(self, service_name: str, app_factory: Callable[[], Any], port: int) -> None:\n        self._service_name = service_name\n        self._app_factory = app_factory\n        self._port = port\n        self._server: uvicorn.Server | None = None\n        self._task: asyncio.Task | None = None  # type: ignore[type-arg]\n\n    @property\n    def name(self) -> str:\n        return self._service_name\n\n    async def start(self) -> None:\n        http_app = self._app_factory()\n        uvi_config = uvicorn.Config(\n            app=http_app,\n            host=\"0.0.0.0\",\n            port=self._port,\n            log_level=\"warning\",\n        )\n        self._server = uvicorn.Server(uvi_config)\n        self._task = asyncio.create_task(self._server.serve())\n        # Wait for the server to actually bind before reporting as started\n        for _ in range(50):\n            if self._server.started:\n                break\n            await asyncio.sleep(0.1)\n\n    async def stop(self) -> None:\n        if self._server is not None:\n            self._server.should_exit = True\n        if self._task is not None:\n            await self._task\n            self._task = None\n        self._server = None\n\n    async def health_check(self) -> bool:\n        return self._server is not None\n\n\ndef _build_resource_metadata(app_model: AppModel, port: int) -> dict[str, Any]:\n    \"\"\"Build resource metadata for the ``/_ldk/resources`` endpoint.\"\"\"\n    metadata: dict[str, Any] = {\"port\": port, \"services\": {}}\n    services = metadata[\"services\"]\n    ports = _service_ports(port)\n\n    _add_api_metadata(services, app_model, port)\n    _add_service_metadata(services, app_model, ports)\n    return metadata\n\n\ndef _service_ports(port: int) -> dict[str, int]:\n    \"\"\"Return a mapping of service name to port number.\"\"\"\n    return {\n        \"dynamodb\": port + 1,\n        \"sqs\": port + 2,\n        \"s3\": port + 3,\n        \"sns\": port + 4,\n        \"events\": port + 5,\n        \"stepfunctions\": port + 6,\n        \"cognito-idp\": port + 7,\n        \"ssm\": port + 12,\n        \"secretsmanager\": port + 13,\n    }\n\n\ndef _add_api_metadata(services: dict[str, Any], app_model: AppModel, port: int) -> None:\n    \"\"\"Add API Gateway metadata to services.\"\"\"\n    if not app_model.apis:\n        return\n    routes = []\n    for api_def in app_model.apis:\n        for r in api_def.routes:\n            routes.append(\n                {\n                    \"name\": api_def.name,\n                    \"path\": r.path,\n                    \"method\": r.method,\n                    \"handler\": r.handler_name or \"\",\n                }\n            )\n    services[\"apigateway\"] = {\"port\": port, \"resources\": routes}\n\n\ndef _add_service_metadata(\n    services: dict[str, Any], app_model: AppModel, ports: dict[str, int]\n) -> None:\n    \"\"\"Add non-API service metadata to services.\"\"\"\n    if app_model.functions:\n        services[\"lambda\"] = {\n            \"resources\": [\n                {\n                    \"name\": f.name,\n                    \"runtime\": f.runtime,\n                    \"arn\": f\"arn:aws:lambda:us-east-1:000000000000:function:{f.name}\",\n                }\n                for f in app_model.functions\n            ],\n        }\n    if app_model.tables:\n        services[\"dynamodb\"] = {\n            \"port\": ports[\"dynamodb\"],\n            \"resources\": [{\"name\": t.name} for t in app_model.tables],\n        }\n    if app_model.queues:\n        sqs_port = ports[\"sqs\"]\n        services[\"sqs\"] = {\n            \"port\": sqs_port,\n            \"resources\": [\n                {\n                    \"name\": q.name,\n                    \"queue_url\": f\"http://localhost:{sqs_port}/000000000000/{q.name}\",\n                }\n                for q in app_model.queues\n            ],\n        }\n    if app_model.buckets:\n        services[\"s3\"] = {\n            \"port\": ports[\"s3\"],\n            \"resources\": [{\"name\": b.name} for b in app_model.buckets],\n        }\n    if app_model.topics:\n        services[\"sns\"] = {\n            \"port\": ports[\"sns\"],\n            \"resources\": [\n                {\n                    \"name\": t.name,\n                    \"arn\": t.topic_arn or f\"arn:aws:sns:us-east-1:000000000000:{t.name}\",\n                }\n                for t in app_model.topics\n            ],\n        }\n    if app_model.event_buses:\n        services[\"events\"] = {\n            \"port\": ports[\"events\"],\n            \"resources\": [\n                {\n                    \"name\": b.name,\n                    \"arn\": b.bus_arn or f\"arn:aws:events:us-east-1:000000000000:event-bus/{b.name}\",\n                }\n                for b in app_model.event_buses\n            ],\n        }\n    if app_model.state_machines:\n        services[\"stepfunctions\"] = {\n            \"port\": ports[\"stepfunctions\"],\n            \"resources\": [\n                {\n                    \"name\": sm.name,\n                    \"arn\": f\"arn:aws:states:us-east-1:000000000000:stateMachine:{sm.name}\",\n                }\n                for sm in app_model.state_machines\n            ],\n        }\n    if app_model.user_pools:\n        services[\"cognito-idp\"] = {\n            \"port\": ports[\"cognito-idp\"],\n            \"resources\": [\n                {\"name\": p.user_pool_name, \"user_pool_id\": f\"us-east-1_{p.logical_id}\"}\n                for p in app_model.user_pools\n            ],\n        }\n\n\ndef _mount_management_api(\n    providers: dict[str, Provider],\n    orchestrator: Orchestrator,\n    compute_providers: dict[str, ICompute],\n    port: int,\n    resource_metadata: dict[str, Any] | None = None,\n) -> None:\n    \"\"\"Mount the management API router on the API Gateway app or create a standalone one.\"\"\"\n    from fastapi import FastAPI\n\n    from lws.api.management import create_management_router\n\n    mgmt_router = create_management_router(\n        orchestrator, compute_providers, providers, resource_metadata=resource_metadata\n    )\n\n    # Try to find an existing API Gateway provider to mount on\n    for key, prov in providers.items():\n        if isinstance(prov, ApiGatewayProvider):\n            prov.app.include_router(mgmt_router)\n            return\n\n    # No API Gateway — create a standalone FastAPI app for management\n    mgmt_app = FastAPI(title=\"LDK Management\")\n    mgmt_app.include_router(mgmt_router)\n    providers[\"__management_http__\"] = _HttpServiceProvider(\n        \"management-http\", lambda: mgmt_app, port\n    )\n\n\ndef _find_node_id(graph: AppGraph, node_type: NodeType, name: str) -> str | None:\n    \"\"\"Find a graph node ID by type and name.\"\"\"\n    for nid, node in graph.nodes.items():\n        if node.node_type == node_type and nid == name:\n            return nid\n    # Fallback: check config\n    for nid, node in graph.nodes.items():\n        if node.node_type == node_type:\n            if node.config.get(\"table_name\") == name or node.config.get(\"handler\") == name:\n                return nid\n    return name\n\n\ndef _build_key_schema(raw_schema: list[dict[str, str]]) -> KeySchema:\n    \"\"\"Convert raw key schema dicts to a KeySchema dataclass.\"\"\"\n    pk: KeyAttribute | None = None\n    sk: KeyAttribute | None = None\n    for ks in raw_schema:\n        attr = KeyAttribute(name=ks.get(\"attribute_name\", \"pk\"), type=ks.get(\"type\", \"S\"))\n        if ks.get(\"key_type\") == \"RANGE\":\n            sk = attr\n        else:\n            pk = attr\n    if pk is None:\n        pk = KeyAttribute(name=\"pk\", type=\"S\")\n    return KeySchema(partition_key=pk, sort_key=sk)\n\n\ndef _build_gsi(raw_gsi: dict) -> GsiDefinition:\n    \"\"\"Convert a raw GSI dict to a GsiDefinition dataclass.\"\"\"\n    index_name = raw_gsi.get(\"index_name\", raw_gsi.get(\"IndexName\", \"gsi\"))\n    ks_raw = raw_gsi.get(\"key_schema\", [])\n    ks = _build_key_schema(ks_raw)\n    projection = raw_gsi.get(\"projection_type\", \"ALL\")\n    return GsiDefinition(index_name=index_name, key_schema=ks, projection_type=projection)\n","structuredPatch":[{"oldStart":1202,"oldLines":15,"newStart":1202,"newLines":24,"lines":["         },","     )"," ","-    # 9. SSM Parameter Store and Secrets Manager","+    # 9. SSM Parameter Store and Secrets Manager (pre-seeded from CloudFormation)","     from lws.providers.secretsmanager.routes import create_secretsmanager_app","     from lws.providers.ssm.routes import create_ssm_app"," ","+    ssm_params = [","+        {\"name\": p.name, \"type\": p.type, \"value\": p.value, \"description\": p.description}","+        for p in app_model.ssm_parameters","+    ]","+    sm_secrets = [","+        {\"name\": s.name, \"description\": s.description, \"secret_string\": s.secret_string}","+        for s in app_model.secrets","+    ]","+","     providers[\"__ssm_http__\"] = _HttpServiceProvider(","-        \"ssm-http\", create_ssm_app, ssm_port","+        \"ssm-http\", lambda: create_ssm_app(ssm_params), ssm_port","     )","     providers[\"__secretsmanager_http__\"] = _HttpServiceProvider(","-        \"secretsmanager-http\", create_secretsmanager_app, secretsmanager_port","+        \"secretsmanager-http\", lambda: create_secretsmanager_app(sm_secrets), secretsmanager_port","     )"," ","     return providers, compute_providers"]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"9b73fd13-0622-452a-997b-2d0d2df55533"}
{"parentUuid":"78b7014e-8134-44c9-9642-fc8b1046488e","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","message":{"model":"claude-opus-4-6","id":"msg_0123eMiF73Ah4x8t9PoDAXgs","type":"message","role":"assistant","content":[{"type":"text","text":"Now add display details — first `_collect_extra_resources`:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":633,"cache_read_input_tokens":70024,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":633},"output_tokens":2,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CY1FLzMaFakwfVh8LKG7U","type":"assistant","uuid":"6197130d-8def-4285-a1da-82d8164ea7dc","timestamp":"2026-02-10T23:22:20.849Z"}
{"parentUuid":"6197130d-8def-4285-a1da-82d8164ea7dc","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","message":{"model":"claude-opus-4-6","id":"msg_0123eMiF73Ah4x8t9PoDAXgs","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01VrghLHppmbz4p6zWQj8ygk","name":"Edit","input":{"replace_all":false,"file_path":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services/src/lws/cli/ldk.py","old_string":"        \"ecs_services\": (\"service_name\", \"ecs_services\"),\n        \"user_pools\": (\"user_pool_name\", \"user_pools\"),\n    }","new_string":"        \"ecs_services\": (\"service_name\", \"ecs_services\"),\n        \"user_pools\": (\"user_pool_name\", \"user_pools\"),\n        \"ssm_parameters\": (\"name\", \"ssm_parameters\"),\n        \"secrets\": (\"name\", \"secrets\"),\n    }"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":633,"cache_read_input_tokens":70024,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":633},"output_tokens":2,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CY1FLzMaFakwfVh8LKG7U","type":"assistant","uuid":"6e1ad753-d6ca-45e6-ba4c-ab90cfbfaa20","timestamp":"2026-02-10T23:22:23.169Z"}
{"parentUuid":"6e1ad753-d6ca-45e6-ba4c-ab90cfbfaa20","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"callback"},"parentToolUseID":"toolu_01VrghLHppmbz4p6zWQj8ygk","toolUseID":"toolu_01VrghLHppmbz4p6zWQj8ygk","timestamp":"2026-02-10T23:22:23.176Z","uuid":"53d1b9d9-9ec4-4662-9805-3f88be914954"}
{"parentUuid":"6e1ad753-d6ca-45e6-ba4c-ab90cfbfaa20","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01VrghLHppmbz4p6zWQj8ygk","type":"tool_result","content":"The file /Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services/src/lws/cli/ldk.py has been updated successfully."}]},"uuid":"c8d9c4f1-3d95-4bd3-800c-6c2a5e2d12d9","timestamp":"2026-02-10T23:22:23.176Z","toolUseResult":{"filePath":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services/src/lws/cli/ldk.py","oldString":"        \"ecs_services\": (\"service_name\", \"ecs_services\"),\n        \"user_pools\": (\"user_pool_name\", \"user_pools\"),\n    }","newString":"        \"ecs_services\": (\"service_name\", \"ecs_services\"),\n        \"user_pools\": (\"user_pool_name\", \"user_pools\"),\n        \"ssm_parameters\": (\"name\", \"ssm_parameters\"),\n        \"secrets\": (\"name\", \"secrets\"),\n    }","originalFile":"\"\"\"LDK CLI entry point.\n\nProvides the ``ldk dev``, ``ldk invoke``, and ``ldk reset`` commands.\n``ldk dev`` parses a CDK cloud assembly, builds the application graph,\nstarts local providers, and watches for file changes.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport asyncio\nimport json\nimport logging\nimport shutil\nfrom collections.abc import Callable\nfrom pathlib import Path\nfrom typing import Any\n\nimport typer\nimport uvicorn\nfrom rich.console import Console\nfrom rich.syntax import Syntax\n\nfrom lws.cli.display import (\n    print_banner,\n    print_error,\n    print_resource_summary,\n    print_startup_complete,\n)\nfrom lws.config.loader import ConfigError, LdkConfig, load_config\nfrom lws.graph.builder import AppGraph, NodeType, build_graph\nfrom lws.interfaces import (\n    ComputeConfig,\n    GsiDefinition,\n    ICompute,\n    KeyAttribute,\n    KeySchema,\n    Provider,\n    TableConfig,\n)\nfrom lws.parser.assembly import AppModel, parse_assembly\nfrom lws.providers.apigateway.provider import ApiGatewayProvider, RouteConfig\nfrom lws.providers.cognito.provider import CognitoProvider\nfrom lws.providers.cognito.user_store import PasswordPolicy, UserPoolConfig\nfrom lws.providers.dynamodb.provider import SqliteDynamoProvider\nfrom lws.providers.dynamodb.routes import create_dynamodb_app\nfrom lws.providers.ecs.provider import EcsProvider\nfrom lws.providers.eventbridge.provider import (\n    EventBridgeProvider,\n    EventBusConfig,\n    RuleConfig,\n    RuleTarget,\n)\nfrom lws.providers.lambda_runtime.nodejs import NodeJsCompute\nfrom lws.providers.lambda_runtime.python import PythonCompute\nfrom lws.providers.s3.provider import S3Provider\nfrom lws.providers.s3.routes import create_s3_app\nfrom lws.providers.sns.provider import SnsProvider, TopicConfig\nfrom lws.providers.sns.routes import create_sns_app\nfrom lws.providers.sqs.provider import QueueConfig, RedrivePolicy, SqsProvider\nfrom lws.providers.sqs.routes import create_sqs_app\nfrom lws.providers.stepfunctions.provider import (\n    StateMachineConfig,\n    StepFunctionsProvider,\n    WorkflowType,\n)\nfrom lws.runtime.env_builder import build_lambda_env\nfrom lws.runtime.orchestrator import Orchestrator\nfrom lws.runtime.sdk_env import build_sdk_env\nfrom lws.runtime.synth import SynthError, ensure_synth\nfrom lws.runtime.watcher import FileWatcher\n\n_console = Console()\n\napp = typer.Typer(name=\"ldk\", help=\"Local Development Kit - Run AWS CDK applications locally\")\n\n__version__ = \"0.4.0\"\n\n\n@app.callback()\ndef main() -> None:\n    \"\"\"LDK - Local Development Kit.\"\"\"\n\n\n@app.command()\ndef dev(\n    port: int = typer.Option(None, \"--port\", \"-p\", help=\"API Gateway listen port\"),\n    no_persist: bool = typer.Option(False, \"--no-persist\", help=\"Disable data persistence\"),\n    force_synth: bool = typer.Option(False, \"--force-synth\", help=\"Force CDK synth\"),\n    log_level: str = typer.Option(\n        None, \"--log-level\", \"-l\", help=\"Log level (debug/info/warning/error)\"\n    ),\n    project_dir: Path = typer.Option(\".\", \"--project-dir\", \"-d\", help=\"Project root directory\"),\n    mode: str = typer.Option(None, \"--mode\", \"-m\", help=\"Project mode (cdk or terraform)\"),\n) -> None:\n    \"\"\"Start the local development environment.\"\"\"\n    try:\n        asyncio.run(_run_dev(project_dir, port, no_persist, force_synth, log_level, mode))\n    except KeyboardInterrupt:\n        pass\n\n\n@app.command()\ndef invoke(\n    function_name: str = typer.Option(..., \"--function-name\", \"-f\", help=\"Lambda function name\"),\n    event: str = typer.Option(None, \"--event\", \"-e\", help=\"Inline JSON event payload\"),\n    event_file: Path = typer.Option(None, \"--event-file\", help=\"Path to JSON event file\"),\n    project_dir: Path = typer.Option(\".\", \"--project-dir\", \"-d\", help=\"Project root directory\"),\n    port: int = typer.Option(None, \"--port\", \"-p\", help=\"Management API port\"),\n) -> None:\n    \"\"\"Invoke a Lambda function directly.\"\"\"\n    asyncio.run(_run_invoke(function_name, event, event_file, project_dir, port))\n\n\nasync def _run_invoke(\n    function_name: str,\n    event_json: str | None,\n    event_file: Path | None,\n    project_dir: Path,\n    port_override: int | None,\n) -> None:\n    \"\"\"Async implementation of the ``ldk invoke`` command.\"\"\"\n    # Resolve event payload\n    event_payload = _resolve_event_payload(event_json, event_file)\n\n    # Try connecting to running ldk dev via management API\n    project_dir = project_dir.resolve()\n    config = _load_config_quiet(project_dir)\n    mgmt_port = port_override or config.port\n\n    if await _try_management_invoke(mgmt_port, function_name, event_payload):\n        return\n\n    # Fallback: one-shot invocation\n    _console.print(\"[dim]No running ldk dev found, performing one-shot invocation...[/dim]\")\n    await _oneshot_invoke(project_dir, config, function_name, event_payload)\n\n\ndef _resolve_event_payload(event_json: str | None, event_file: Path | None) -> dict:\n    \"\"\"Parse event payload from CLI args.\"\"\"\n    if event_json is not None:\n        try:\n            return json.loads(event_json)\n        except json.JSONDecodeError as exc:\n            print_error(\"Invalid JSON in --event\", str(exc))\n            raise typer.Exit(1)\n\n    if event_file is not None:\n        if not event_file.exists():\n            print_error(\"Event file not found\", str(event_file))\n            raise typer.Exit(1)\n        try:\n            return json.loads(event_file.read_text())\n        except json.JSONDecodeError as exc:\n            print_error(\"Invalid JSON in event file\", str(exc))\n            raise typer.Exit(1)\n\n    return {}\n\n\nasync def _try_management_invoke(port: int, function_name: str, event: dict) -> bool:\n    \"\"\"Try to invoke via the management API. Return True if successful.\"\"\"\n    try:\n        import httpx\n\n        async with httpx.AsyncClient() as client:\n            resp = await client.post(\n                f\"http://localhost:{port}/_ldk/invoke\",\n                json={\"function_name\": function_name, \"event\": event},\n                timeout=30.0,\n            )\n            result = resp.json()\n            formatted = json.dumps(result, indent=2)\n            syntax = Syntax(formatted, \"json\", theme=\"monokai\")\n            _console.print(syntax)\n            return True\n    except Exception:\n        return False\n\n\nasync def _oneshot_invoke(\n    project_dir: Path, config: LdkConfig, function_name: str, event: dict\n) -> None:\n    \"\"\"Perform a one-shot Lambda invocation without a running server.\"\"\"\n    try:\n        import uuid as _uuid\n\n        from lws.interfaces import InvocationResult, LambdaContext\n\n        cdk_out = project_dir / config.cdk_out_dir\n        if not cdk_out.exists():\n            print_error(\"CDK output not found\", f\"Run 'cdk synth' first in {project_dir}\")\n            raise typer.Exit(1)\n\n        app_model = parse_assembly(cdk_out)\n        func_def = next((f for f in app_model.functions if f.name == function_name), None)\n        if func_def is None:\n            print_error(\"Function not found\", f\"No function named '{function_name}'\")\n            raise typer.Exit(1)\n\n        sdk_env = build_sdk_env({})\n        func_env = build_lambda_env(\n            function_name=func_def.name,\n            function_env=func_def.environment,\n            local_endpoints={},\n            resolved_refs={},\n        )\n        compute_config = ComputeConfig(\n            function_name=func_def.name,\n            handler=func_def.handler,\n            runtime=func_def.runtime,\n            code_path=func_def.code_path or Path(\".\"),\n            timeout=func_def.timeout,\n            memory_size=func_def.memory,\n            environment=func_env,\n        )\n        compute = NodeJsCompute(config=compute_config, sdk_env=sdk_env)\n        await compute.start()\n\n        request_id = str(_uuid.uuid4())\n        context = LambdaContext(\n            function_name=function_name,\n            memory_limit_in_mb=compute_config.memory_size,\n            timeout_seconds=compute_config.timeout,\n            aws_request_id=request_id,\n            invoked_function_arn=(\n                f\"arn:aws:lambda:us-east-1:000000000000:function:{function_name}\"\n            ),\n        )\n\n        result: InvocationResult = await compute.invoke(event, context)\n        await compute.stop()\n\n        output = result.payload if result.error is None else {\"error\": result.error}\n        formatted = json.dumps(output, indent=2, default=str)\n        syntax = Syntax(formatted, \"json\", theme=\"monokai\")\n        _console.print(syntax)\n\n    except typer.Exit:\n        raise\n    except Exception as exc:\n        print_error(\"Invocation failed\", str(exc))\n        raise typer.Exit(1)\n\n\n@app.command()\ndef reset(\n    yes: bool = typer.Option(False, \"--yes\", \"-y\", help=\"Skip confirmation prompt\"),\n    project_dir: Path = typer.Option(\".\", \"--project-dir\", \"-d\", help=\"Project root directory\"),\n    port: int = typer.Option(None, \"--port\", \"-p\", help=\"Management API port\"),\n) -> None:\n    \"\"\"Reset all LDK local state (databases, queues, etc.).\"\"\"\n    project_dir = project_dir.resolve()\n    config = _load_config_quiet(project_dir)\n    data_dir = project_dir / config.data_dir\n\n    if not data_dir.exists():\n        _console.print(\"[dim]No data directory found. Nothing to reset.[/dim]\")\n        return\n\n    # List contents to be deleted\n    items = list(data_dir.iterdir())\n    if not items:\n        _console.print(\"[dim]Data directory is empty. Nothing to reset.[/dim]\")\n        return\n\n    _console.print(f\"[bold]Will delete all files under:[/bold] {data_dir}\")\n    for item in items:\n        kind = \"dir\" if item.is_dir() else \"file\"\n        _console.print(f\"  [dim]{kind}:[/dim] {item.name}\")\n\n    if not yes:\n        confirm = typer.confirm(\"Are you sure you want to delete all local state?\")\n        if not confirm:\n            _console.print(\"[dim]Aborted.[/dim]\")\n            return\n\n    # Delete contents\n    deleted_count = 0\n    for item in items:\n        if item.is_dir():\n            shutil.rmtree(item)\n        else:\n            item.unlink()\n        deleted_count += 1\n\n    _console.print(f\"[green]Deleted {deleted_count} item(s) from {data_dir}[/green]\")\n\n    # Notify running ldk dev if possible\n    mgmt_port = port or config.port\n    asyncio.run(_try_management_reset(mgmt_port))\n\n\nasync def _try_management_reset(port: int) -> None:\n    \"\"\"Try to notify running ldk dev of the reset via management API.\"\"\"\n    try:\n        import httpx\n\n        async with httpx.AsyncClient() as client:\n            resp = await client.post(\n                f\"http://localhost:{port}/_ldk/reset\",\n                timeout=5.0,\n            )\n            if resp.status_code == 200:\n                _console.print(\"[dim]Notified running ldk dev of reset.[/dim]\")\n    except Exception:\n        pass  # Server not running, that's fine\n\n\ndef _load_config_quiet(project_dir: Path) -> LdkConfig:\n    \"\"\"Load config without printing errors. Falls back to defaults.\"\"\"\n    try:\n        return load_config(project_dir)\n    except ConfigError:\n        return LdkConfig()\n\n\ndef _load_and_apply_config(\n    project_dir: Path,\n    port_override: int | None,\n    no_persist: bool,\n    log_level_override: str | None,\n) -> LdkConfig:\n    \"\"\"Load config and apply CLI overrides.\"\"\"\n    try:\n        config = load_config(project_dir)\n    except ConfigError as exc:\n        print_error(\"Configuration error\", str(exc))\n        raise typer.Exit(1)\n\n    if port_override is not None:\n        config.port = port_override\n    if log_level_override is not None:\n        config.log_level = log_level_override\n    if no_persist:\n        config.persist = False\n\n    logging.basicConfig(\n        level=getattr(logging, config.log_level.upper(), logging.INFO),\n        format=\"%(levelname)s %(name)s: %(message)s\",\n    )\n    return config\n\n\ndef _collect_extra_resources(app_model: AppModel) -> dict[str, list[str]]:\n    \"\"\"Collect extra resource name lists from the app model for display.\"\"\"\n    extras: dict[str, list[str]] = {}\n    _RESOURCE_ATTRS = {\n        \"queues\": (\"name\", \"queues\"),\n        \"buckets\": (\"name\", \"buckets\"),\n        \"topics\": (\"name\", \"topics\"),\n        \"state_machines\": (\"name\", \"state_machines\"),\n        \"ecs_services\": (\"service_name\", \"ecs_services\"),\n        \"user_pools\": (\"user_pool_name\", \"user_pools\"),\n    }\n    for key, (attr, model_attr) in _RESOURCE_ATTRS.items():\n        items = getattr(app_model, model_attr, [])\n        if items:\n            extras[key] = [getattr(item, attr, str(item)) for item in items]\n    return extras\n\n\ndef _build_local_details(app_model: AppModel, port: int) -> dict[str, str]:\n    \"\"\"Build a mapping of ``\"Type:Name\"`` to local detail strings.\"\"\"\n    details: dict[str, str] = {}\n\n    _add_api_details(details, app_model)\n    _add_resource_details(details, app_model)\n    return details\n\n\ndef _add_api_details(details: dict[str, str], app_model: AppModel) -> None:\n    \"\"\"Add API route and Lambda function details.\"\"\"\n    for api_def in app_model.apis:\n        for r in api_def.routes:\n            details[f\"API Route:{r.path}\"] = (\n                f\"lws apigateway test-invoke-method --resource {r.path} --http-method {r.method}\"\n            )\n    for f in app_model.functions:\n        details[f\"Function:{f.name}\"] = f\"ldk invoke {f.name}\"\n\n\ndef _add_resource_details(details: dict[str, str], app_model: AppModel) -> None:\n    \"\"\"Add service resource details (DynamoDB, SQS, S3, etc.).\"\"\"\n    for t in app_model.tables:\n        details[f\"Table:{t.name}\"] = f\"lws dynamodb scan --table-name {t.name}\"\n    for q in app_model.queues:\n        details[f\"Queue:{q.name}\"] = f\"lws sqs receive-message --queue-name {q.name}\"\n    for b in app_model.buckets:\n        details[f\"Bucket:{b.name}\"] = f\"lws s3api list-objects-v2 --bucket {b.name}\"\n    for t in app_model.topics:\n        details[f\"Topic:{t.name}\"] = f\"lws sns publish --topic-name {t.name} --message '...'\"\n    for b in app_model.event_buses:\n        details[f\"Event Bus:{b.name}\"] = f\"lws events list-rules --event-bus-name {b.name}\"\n    for sm in app_model.state_machines:\n        details[f\"State Machine:{sm.name}\"] = f\"lws stepfunctions start-execution --name {sm.name}\"\n    for p in app_model.user_pools:\n        details[f\"User Pool:{p.user_pool_name}\"] = (\n            f\"lws cognito-idp sign-up --user-pool-name {p.user_pool_name}\"\n        )\n\n\ndef _display_summary(app_model: AppModel, port: int) -> None:\n    \"\"\"Print resource summary and startup-complete banner.\"\"\"\n    routes_info = [\n        {\"method\": r.method, \"path\": r.path, \"handler\": r.handler_name or \"\"}\n        for api_def in app_model.apis\n        for r in api_def.routes\n    ]\n    tables_info = [t.name for t in app_model.tables]\n    functions_info = [f\"{f.name} ({f.runtime})\" for f in app_model.functions]\n\n    extra_resources = _collect_extra_resources(app_model)\n    local_details = _build_local_details(app_model, port)\n    print_resource_summary(\n        routes_info, tables_info, functions_info, local_details=local_details, **extra_resources\n    )\n\n    extra_counts = {f\"num_{k}\": len(v) for k, v in extra_resources.items()}\n    print_startup_complete(\n        port,\n        num_routes=len(routes_info),\n        num_tables=len(tables_info),\n        num_functions=len(functions_info),\n        **extra_counts,\n    )\n\n\ndef _resolve_mode(project_dir: Path, config: LdkConfig, mode_override: str | None) -> str:\n    \"\"\"Resolve the project mode from CLI flag, config, or auto-detection.\n\n    Returns ``\"cdk\"`` or ``\"terraform\"``.\n    Raises ``typer.Exit(1)`` on error.\n    \"\"\"\n    from lws.terraform.detect import detect_project_type\n\n    mode = mode_override or config.mode\n    if mode:\n        if mode not in (\"cdk\", \"terraform\"):\n            print_error(\"Invalid mode\", f\"Must be 'cdk' or 'terraform', got '{mode}'\")\n            raise typer.Exit(1)\n        return mode\n\n    detected = detect_project_type(project_dir)\n    if detected == \"ambiguous\":\n        print_error(\n            \"Ambiguous project\",\n            \"Both .tf files and cdk.out found. Use --mode cdk or --mode terraform.\",\n        )\n        raise typer.Exit(1)\n    if detected == \"none\":\n        print_error(\n            \"No project found\",\n            \"No .tf files or cdk.out directory found. \"\n            \"Run from a CDK or Terraform project directory.\",\n        )\n        raise typer.Exit(1)\n    return detected\n\n\nasync def _run_dev_terraform(project_dir: Path, config: LdkConfig) -> None:\n    \"\"\"Run the dev server in Terraform mode.\n\n    Starts all service providers in always-on mode, generates the\n    Terraform provider override file, and waits for shutdown.\n    \"\"\"\n    from lws.terraform.gitignore import ensure_gitignore\n    from lws.terraform.override import cleanup_override, generate_override\n\n    port = config.port\n    data_dir = project_dir / config.data_dir\n    data_dir.mkdir(parents=True, exist_ok=True)\n\n    # Generate override file\n    try:\n        override_path = generate_override(port, project_dir)\n    except FileExistsError as exc:\n        print_error(\"Override file conflict\", str(exc))\n        raise typer.Exit(1)\n\n    ensure_gitignore(project_dir)\n\n    # Create all providers in always-on mode (no app model)\n    providers, ports = _create_terraform_providers(config, data_dir, project_dir)\n\n    orchestrator = Orchestrator()\n\n    # Enable WebSocket log streaming\n    from lws.logging.logger import WebSocketLogHandler, set_ws_handler\n\n    ws_log_handler = WebSocketLogHandler()\n    set_ws_handler(ws_log_handler)\n\n    # Build resource metadata so the CLI client can discover services\n    resource_metadata: dict[str, Any] = {\n        \"port\": port,\n        \"services\": {\n            svc_name: {\"port\": svc_port, \"resources\": []} for svc_name, svc_port in ports.items()\n        },\n    }\n\n    # Mount management API (no compute providers in terraform mode)\n    _mount_management_api(providers, orchestrator, {}, port, resource_metadata)\n\n    for key in providers:\n        pass  # All keys are already in the dict\n\n    startup_order = list(providers.keys())\n\n    try:\n        await orchestrator.start(providers, startup_order)\n    except Exception as exc:\n        cleanup_override(project_dir)\n        print_error(\"Failed to start providers\", str(exc))\n        raise typer.Exit(1)\n\n    # Display summary\n    _console.print()\n    _console.print(\"[bold green]Terraform mode active[/bold green]\")\n    _console.print(f\"  Override file: {override_path}\")\n    _console.print()\n    _console.print(\"[bold]Service endpoints:[/bold]\")\n    for svc_name, svc_port in sorted(ports.items()):\n        _console.print(f\"  {svc_name:20s} http://localhost:{svc_port}\")\n    _console.print()\n    _console.print(\"[dim]Run 'terraform init && terraform apply' to create resources.[/dim]\")\n    _console.print(f\"  Dashboard: http://localhost:{config.port}/_ldk/gui\")\n    _console.print()\n\n    try:\n        await orchestrator.wait_for_shutdown()\n    finally:\n        cleanup_override(project_dir)\n        set_ws_handler(None)\n        await orchestrator.stop()\n        typer.echo(\"Goodbye\")\n\n\ndef _create_terraform_providers(\n    config: LdkConfig,\n    data_dir: Path,\n    project_dir: Path | None = None,\n) -> tuple[dict[str, Provider], dict[str, int]]:\n    \"\"\"Create all service providers for Terraform mode (no app model).\"\"\"\n    providers: dict[str, Provider] = {}\n\n    port = config.port\n    ports = {\n        \"dynamodb\": port + 1,\n        \"sqs\": port + 2,\n        \"s3\": port + 3,\n        \"sns\": port + 4,\n        \"eventbridge\": port + 5,\n        \"stepfunctions\": port + 6,\n        \"cognito\": port + 7,\n        \"apigateway\": port + 8,\n        \"lambda\": port + 9,\n        \"iam\": port + 10,\n        \"sts\": port + 11,\n        \"ssm\": port + 12,\n        \"secretsmanager\": port + 13,\n    }\n\n    dynamo_provider = SqliteDynamoProvider(data_dir=data_dir, tables=[])\n    sqs_provider = SqsProvider()\n    s3_provider = S3Provider(data_dir=data_dir)\n    sns_provider = SnsProvider()\n    eb_provider = EventBridgeProvider()\n    sf_provider = StepFunctionsProvider()\n\n    pool_config = UserPoolConfig(\n        user_pool_id=\"us-east-1_default\",\n        user_pool_name=\"default\",\n    )\n    cognito_provider = CognitoProvider(data_dir=data_dir, config=pool_config)\n\n    _register_http_providers(\n        providers,\n        dynamo_provider=dynamo_provider,\n        sqs_provider=sqs_provider,\n        s3_provider=s3_provider,\n        sns_provider=sns_provider,\n        eb_provider=eb_provider,\n        sf_provider=sf_provider,\n        cognito_provider=cognito_provider,\n        ports=ports,\n    )\n\n    # Shared Lambda registry for Lambda management and API Gateway V2 proxy\n    from lws.providers.lambda_runtime.routes import LambdaRegistry, create_lambda_management_app\n\n    lambda_registry = LambdaRegistry()\n\n    # Wire Lambda registry compute providers into Step Functions so SFN can\n    # invoke Lambda functions that Terraform creates dynamically.\n    sf_provider.set_compute_providers(lambda_registry._compute)\n\n    # Build SDK env so Lambda functions can reach local services\n    local_endpoints: dict[str, str] = {\n        \"dynamodb\": f\"http://127.0.0.1:{ports['dynamodb']}\",\n        \"sqs\": f\"http://127.0.0.1:{ports['sqs']}\",\n        \"s3\": f\"http://127.0.0.1:{ports['s3']}\",\n        \"sns\": f\"http://127.0.0.1:{ports['sns']}\",\n        \"events\": f\"http://127.0.0.1:{ports['eventbridge']}\",\n        \"stepfunctions\": f\"http://127.0.0.1:{ports['stepfunctions']}\",\n        \"cognito-idp\": f\"http://127.0.0.1:{ports['cognito']}\",\n        \"ssm\": f\"http://127.0.0.1:{ports['ssm']}\",\n        \"secretsmanager\": f\"http://127.0.0.1:{ports['secretsmanager']}\",\n    }\n    sdk_env = build_sdk_env(local_endpoints)\n\n    # Lambda management API\n    providers[\"__lambda_http__\"] = _HttpServiceProvider(\n        \"lambda-http\",\n        lambda: create_lambda_management_app(lambda_registry, project_dir, sdk_env),\n        ports[\"lambda\"],\n    )\n\n    # API Gateway management API with V2 support and Lambda proxy\n    from lws.providers.apigateway.routes import create_apigateway_management_app\n\n    providers[\"__apigateway_http__\"] = _HttpServiceProvider(\n        \"apigateway-http\",\n        lambda: create_apigateway_management_app(lambda_registry),\n        ports[\"apigateway\"],\n    )\n\n    # IAM stub\n    from lws.providers.iam.routes import create_iam_app\n\n    providers[\"__iam_http__\"] = _HttpServiceProvider(\"iam-http\", create_iam_app, ports[\"iam\"])\n\n    # STS stub\n    from lws.providers.sts.routes import create_sts_app\n\n    providers[\"__sts_http__\"] = _HttpServiceProvider(\"sts-http\", create_sts_app, ports[\"sts\"])\n\n    # SSM Parameter Store\n    from lws.providers.ssm.routes import create_ssm_app\n\n    providers[\"__ssm_http__\"] = _HttpServiceProvider(\"ssm-http\", create_ssm_app, ports[\"ssm\"])\n\n    # Secrets Manager\n    from lws.providers.secretsmanager.routes import create_secretsmanager_app\n\n    providers[\"__secretsmanager_http__\"] = _HttpServiceProvider(\n        \"secretsmanager-http\", create_secretsmanager_app, ports[\"secretsmanager\"]\n    )\n\n    return providers, ports\n\n\ndef _has_any_resources(app_model: AppModel) -> bool:\n    \"\"\"Return True if the app model contains at least one resource.\"\"\"\n    return bool(\n        app_model.functions\n        or app_model.tables\n        or app_model.apis\n        or app_model.queues\n        or app_model.buckets\n        or app_model.topics\n        or app_model.event_buses\n        or app_model.state_machines\n        or app_model.ecs_services\n        or app_model.user_pools\n    )\n\n\nasync def _run_dev(\n    project_dir: Path,\n    port_override: int | None,\n    no_persist: bool,\n    force_synth: bool,\n    log_level_override: str | None,\n    mode_override: str | None = None,\n) -> None:\n    \"\"\"Async implementation of the ``ldk dev`` command.\"\"\"\n    project_dir = project_dir.resolve()\n    config = _load_and_apply_config(project_dir, port_override, no_persist, log_level_override)\n    print_banner(__version__, project_dir.name)\n\n    # Resolve project mode\n    resolved_mode = _resolve_mode(project_dir, config, mode_override)\n    if resolved_mode == \"terraform\":\n        await _run_dev_terraform(project_dir, config)\n        return\n\n    try:\n        cdk_out = await ensure_synth(project_dir, force=force_synth)\n    except SynthError as exc:\n        print_error(\"CDK synth failed\", str(exc))\n        raise typer.Exit(1)\n\n    app_model = parse_assembly(cdk_out)\n    if not _has_any_resources(app_model):\n        print_error(\"No resources found in cloud assembly\", str(cdk_out))\n        raise typer.Exit(1)\n\n    graph = build_graph(app_model)\n    startup_order = graph.topological_sort()\n\n    data_dir = project_dir / config.data_dir\n    data_dir.mkdir(parents=True, exist_ok=True)\n    providers, compute_providers = _create_providers(app_model, graph, config, data_dir)\n\n    orchestrator = Orchestrator()\n\n    # Enable WebSocket log streaming\n    from lws.logging.logger import WebSocketLogHandler, set_ws_handler\n\n    ws_log_handler = WebSocketLogHandler()\n    set_ws_handler(ws_log_handler)\n\n    # Mount management API\n    resource_metadata = _build_resource_metadata(app_model, config.port)\n    _mount_management_api(\n        providers, orchestrator, compute_providers, config.port, resource_metadata\n    )\n\n    # Append non-graph provider keys (HTTP servers, management) to startup order.\n    # This must happen after _mount_management_api so the fallback management\n    # HTTP server (when no API Gateway exists) is included in the startup order.\n    for key in providers:\n        if key not in startup_order:\n            startup_order.append(key)\n\n    try:\n        await orchestrator.start(providers, startup_order)\n    except Exception as exc:\n        print_error(\"Failed to start providers\", str(exc))\n        raise typer.Exit(1)\n\n    _display_summary(app_model, config.port)\n    typer.echo(f\"  Dashboard: http://localhost:{config.port}/_ldk/gui\")\n\n    watcher = FileWatcher(\n        watch_dir=project_dir,\n        include_patterns=config.watch_include,\n        exclude_patterns=config.watch_exclude,\n    )\n    watcher.on_change(lambda path: logging.getLogger(\"ldk.watcher\").info(\"Changed: %s\", path))\n    watcher.start()\n\n    try:\n        await orchestrator.wait_for_shutdown()\n    finally:\n        watcher.stop()\n        set_ws_handler(None)\n        await orchestrator.stop()\n        typer.echo(\"Goodbye\")\n\n\ndef _create_dynamo_providers(\n    app_model: AppModel,\n    graph: AppGraph,\n    data_dir: Path,\n) -> tuple[SqliteDynamoProvider, dict[str, Provider]]:\n    \"\"\"Create DynamoDB table providers from the app model.\n\n    Always returns a provider (even with no CDK tables) so the DynamoDB\n    HTTP endpoint is available for Terraform/CLI table creation.\n    \"\"\"\n    providers: dict[str, Provider] = {}\n    table_configs: list[TableConfig] = []\n    for table in app_model.tables:\n        ks = _build_key_schema(table.key_schema)\n        gsi_defs = [_build_gsi(g) for g in table.gsi_definitions]\n        table_configs.append(\n            TableConfig(table_name=table.name, key_schema=ks, gsi_definitions=gsi_defs)\n        )\n\n    dynamo_provider = SqliteDynamoProvider(data_dir=data_dir, tables=table_configs)\n    for table in app_model.tables:\n        node_id = _find_node_id(graph, NodeType.DYNAMODB_TABLE, table.name)\n        if node_id:\n            providers[node_id] = dynamo_provider\n    return dynamo_provider, providers\n\n\ndef _create_compute_providers(\n    app_model: AppModel,\n    graph: AppGraph,\n    local_endpoints: dict[str, str],\n    sdk_env: dict[str, str],\n) -> tuple[dict[str, ICompute], dict[str, Provider]]:\n    \"\"\"Create Lambda compute providers from the app model (Node.js + Python).\"\"\"\n    providers: dict[str, Provider] = {}\n    compute_providers: dict[str, ICompute] = {}\n    for func in app_model.functions:\n        func_env = build_lambda_env(\n            function_name=func.name,\n            function_env=func.environment,\n            local_endpoints=local_endpoints,\n            resolved_refs={},\n        )\n        compute_config = ComputeConfig(\n            function_name=func.name,\n            handler=func.handler,\n            runtime=func.runtime,\n            code_path=func.code_path or Path(\".\"),\n            timeout=func.timeout,\n            memory_size=func.memory,\n            environment=func_env,\n        )\n        if func.runtime.startswith(\"python\"):\n            compute: ICompute = PythonCompute(config=compute_config, sdk_env=sdk_env)\n        elif func.runtime.startswith(\"nodejs\"):\n            compute = NodeJsCompute(config=compute_config, sdk_env=sdk_env)\n        else:\n            logging.getLogger(\"ldk.cli\").warning(\n                \"Unsupported runtime %s for %s, skipping\", func.runtime, func.name\n            )\n            continue\n        compute_providers[func.name] = compute\n        node_id = _find_node_id(graph, NodeType.LAMBDA_FUNCTION, func.name)\n        if node_id:\n            providers[node_id] = compute\n    return compute_providers, providers\n\n\ndef _create_api_providers(\n    app_model: AppModel,\n    graph: AppGraph,\n    compute_providers: dict[str, ICompute],\n    port: int,\n) -> tuple[ApiGatewayProvider | None, dict[str, Provider]]:\n    \"\"\"Create API Gateway providers from the app model.\"\"\"\n    providers: dict[str, Provider] = {}\n    api_provider: ApiGatewayProvider | None = None\n    for api_def in app_model.apis:\n        route_configs = [\n            RouteConfig(method=r.method, path=r.path, handler_name=r.handler_name)\n            for r in api_def.routes\n            if r.handler_name and r.handler_name in compute_providers\n        ]\n        if route_configs:\n            api_provider = ApiGatewayProvider(\n                routes=route_configs, compute_providers=compute_providers, port=port\n            )\n            node_id = _find_node_id(graph, NodeType.API_GATEWAY, api_def.name)\n            if node_id:\n                providers[node_id] = api_provider\n    return api_provider, providers\n\n\ndef _create_sqs_providers(\n    app_model: AppModel,\n    graph: AppGraph,\n) -> tuple[SqsProvider, dict[str, Provider]]:\n    \"\"\"Create SQS queue providers from the app model.\n\n    Always returns a provider (even with no CDK queues) so the SQS\n    HTTP endpoint is available for Terraform/CLI queue creation.\n    \"\"\"\n    providers: dict[str, Provider] = {}\n    queue_configs = []\n    for q in app_model.queues:\n        redrive = None\n        if q.redrive_target:\n            redrive = RedrivePolicy(\n                dead_letter_queue_name=q.redrive_target, max_receive_count=q.max_receive_count\n            )\n        queue_configs.append(\n            QueueConfig(\n                queue_name=q.name,\n                visibility_timeout=q.visibility_timeout,\n                is_fifo=q.is_fifo,\n                content_based_dedup=q.content_based_dedup,\n                redrive_policy=redrive,\n            )\n        )\n    sqs_provider = SqsProvider(queues=queue_configs if queue_configs else None)\n    for q in app_model.queues:\n        node_id = _find_node_id(graph, NodeType.SQS_QUEUE, q.name)\n        if node_id:\n            providers[node_id] = sqs_provider\n    return sqs_provider, providers\n\n\ndef _create_s3_providers(\n    app_model: AppModel,\n    graph: AppGraph,\n    data_dir: Path,\n) -> tuple[S3Provider, dict[str, Provider]]:\n    \"\"\"Create S3 bucket providers from the app model.\n\n    Always returns a provider (even with no CDK buckets) so the S3\n    HTTP endpoint is available for Terraform/CLI bucket creation.\n    \"\"\"\n    providers: dict[str, Provider] = {}\n    bucket_names = [b.name for b in app_model.buckets]\n    s3_provider = S3Provider(data_dir=data_dir, buckets=bucket_names if bucket_names else None)\n    for b in app_model.buckets:\n        node_id = _find_node_id(graph, NodeType.S3_BUCKET, b.name)\n        if node_id:\n            providers[node_id] = s3_provider\n    return s3_provider, providers\n\n\ndef _create_sns_providers(\n    app_model: AppModel,\n    graph: AppGraph,\n) -> tuple[SnsProvider, dict[str, Provider]]:\n    \"\"\"Create SNS topic providers from the app model.\n\n    Always returns a provider (even with no CDK topics) so the SNS\n    HTTP endpoint is available for Terraform/CLI topic creation.\n    \"\"\"\n    providers: dict[str, Provider] = {}\n    topic_configs = [\n        TopicConfig(topic_name=t.name, topic_arn=t.topic_arn) for t in app_model.topics\n    ]\n    sns_provider = SnsProvider(topics=topic_configs if topic_configs else None)\n    for t in app_model.topics:\n        node_id = _find_node_id(graph, NodeType.SNS_TOPIC, t.name)\n        if node_id:\n            providers[node_id] = sns_provider\n    return sns_provider, providers\n\n\ndef _create_eventbridge_providers(\n    app_model: AppModel,\n    graph: AppGraph,\n) -> tuple[EventBridgeProvider, dict[str, Provider]]:\n    \"\"\"Create EventBridge providers from the app model.\n\n    Always returns a provider (even with no CDK buses) so the EventBridge\n    HTTP endpoint is available for Terraform/CLI event bus creation.\n    \"\"\"\n    providers: dict[str, Provider] = {}\n    bus_configs = [\n        EventBusConfig(bus_name=b.name, bus_arn=b.bus_arn) for b in app_model.event_buses\n    ]\n    rule_configs = []\n    for r in app_model.event_rules:\n        targets = [\n            RuleTarget(target_id=t[\"target_id\"], arn=t[\"arn\"], input_path=t.get(\"input_path\"))\n            for t in r.targets\n        ]\n        rule_configs.append(\n            RuleConfig(\n                rule_name=r.rule_name,\n                event_bus_name=r.event_bus_name,\n                event_pattern=r.event_pattern,\n                schedule_expression=r.schedule_expression,\n                targets=targets,\n            )\n        )\n    eb_provider = EventBridgeProvider(\n        buses=bus_configs if bus_configs else None,\n        rules=rule_configs if rule_configs else None,\n    )\n    for b in app_model.event_buses:\n        node_id = _find_node_id(graph, NodeType.EVENT_BUS, b.name)\n        if node_id:\n            providers[node_id] = eb_provider\n    return eb_provider, providers\n\n\ndef _create_stepfunctions_providers(\n    app_model: AppModel,\n    graph: AppGraph,\n) -> tuple[StepFunctionsProvider, dict[str, Provider]]:\n    \"\"\"Create Step Functions providers from the app model.\n\n    Always returns a provider (even with no CDK state machines) so the\n    Step Functions HTTP endpoint is available for Terraform/CLI creation.\n    \"\"\"\n    providers: dict[str, Provider] = {}\n    sm_configs = []\n    for sm in app_model.state_machines:\n        wf_type = WorkflowType.EXPRESS if sm.workflow_type == \"EXPRESS\" else WorkflowType.STANDARD\n        sm_configs.append(\n            StateMachineConfig(\n                name=sm.name,\n                definition=sm.definition,\n                workflow_type=wf_type,\n                role_arn=sm.role_arn,\n                definition_substitutions=sm.definition_substitutions,\n            )\n        )\n    sf_provider = StepFunctionsProvider(\n        state_machines=sm_configs if sm_configs else None,\n    )\n    for sm in app_model.state_machines:\n        node_id = _find_node_id(graph, NodeType.STATE_MACHINE, sm.name)\n        if node_id:\n            providers[node_id] = sf_provider\n    return sf_provider, providers\n\n\ndef _create_ecs_providers(\n    app_model: AppModel,\n    graph: AppGraph,\n) -> tuple[EcsProvider, dict[str, Provider]]:\n    \"\"\"Create ECS service providers from the app model.\n\n    Always returns a provider (even with no CDK services).\n    \"\"\"\n    providers: dict[str, Provider] = {}\n    ecs_provider = EcsProvider(\n        services=app_model.ecs_services if app_model.ecs_services else None,\n    )\n    for svc in app_model.ecs_services:\n        svc_name = getattr(svc, \"service_name\", str(id(svc)))\n        node_id = _find_node_id(graph, NodeType.ECS_SERVICE, svc_name)\n        if node_id:\n            providers[node_id] = ecs_provider\n    return ecs_provider, providers\n\n\ndef _create_cognito_providers(\n    app_model: AppModel,\n    data_dir: Path,\n    compute_providers: dict[str, ICompute],\n) -> tuple[CognitoProvider, dict[str, Provider]]:\n    \"\"\"Create Cognito user pool providers from the app model.\n\n    Always returns a provider (even with no CDK user pools) so the\n    Cognito HTTP endpoint is available for Terraform/CLI user pool creation.\n    \"\"\"\n    providers: dict[str, Provider] = {}\n    if not app_model.user_pools:\n        pool_config = UserPoolConfig(\n            user_pool_id=\"us-east-1_default\",\n            user_pool_name=\"default\",\n        )\n        cognito_provider = CognitoProvider(data_dir=data_dir, config=pool_config)\n        return cognito_provider, providers\n    # Use the first user pool (multi-pool support can be added later)\n    pool = app_model.user_pools[0]\n    pw = pool.password_policy\n    password_policy = PasswordPolicy(\n        minimum_length=int(pw.get(\"MinimumLength\", 8)),\n        require_lowercase=bool(pw.get(\"RequireLowercase\", True)),\n        require_uppercase=bool(pw.get(\"RequireUppercase\", True)),\n        require_digits=bool(pw.get(\"RequireNumbers\", pw.get(\"RequireDigits\", True))),\n        require_symbols=bool(pw.get(\"RequireSymbols\", False)),\n    )\n    pool_config = UserPoolConfig(\n        user_pool_id=f\"us-east-1_{pool.logical_id}\",\n        user_pool_name=pool.user_pool_name,\n        password_policy=password_policy,\n        auto_confirm=pool.auto_confirm,\n        client_id=pool.client_id or \"local-client-id\",\n        pre_authentication_trigger=pool.pre_auth_trigger,\n        post_confirmation_trigger=pool.post_confirm_trigger,\n    )\n    trigger_funcs = {}\n    if pool.pre_auth_trigger and pool.pre_auth_trigger in compute_providers:\n        trigger_funcs[\"PreAuthentication\"] = compute_providers[pool.pre_auth_trigger]\n    if pool.post_confirm_trigger and pool.post_confirm_trigger in compute_providers:\n        trigger_funcs[\"PostConfirmation\"] = compute_providers[pool.post_confirm_trigger]\n    cognito_provider = CognitoProvider(\n        data_dir=data_dir, config=pool_config, trigger_functions=trigger_funcs or None\n    )\n    providers[f\"__cognito_{pool.logical_id}__\"] = cognito_provider\n    return cognito_provider, providers\n\n\ndef _wire_remaining_providers(\n    app_model: AppModel,\n    graph: AppGraph,\n    providers: dict[str, Provider],\n    compute_providers: dict[str, ICompute],\n    sqs_provider: SqsProvider,\n    local_endpoints: dict[str, str],\n    data_dir: Path,\n    api_port: int,\n    *,\n    sns_port: int,\n    eb_port: int,\n    sf_port: int,\n    cognito_port: int,\n) -> tuple[\n    SnsProvider,\n    EventBridgeProvider,\n    StepFunctionsProvider,\n    CognitoProvider,\n]:\n    \"\"\"Wire messaging, cognito, and API Gateway providers.\"\"\"\n    sns_provider, sns_providers = _create_sns_providers(app_model, graph)\n    providers.update(sns_providers)\n    sns_provider.set_compute_providers(compute_providers)\n    sns_provider.set_queue_provider(sqs_provider)\n    local_endpoints[\"sns\"] = f\"http://127.0.0.1:{sns_port}\"\n\n    eb_provider, eb_providers = _create_eventbridge_providers(app_model, graph)\n    providers.update(eb_providers)\n    eb_provider.set_compute_providers(compute_providers)\n    local_endpoints[\"events\"] = f\"http://127.0.0.1:{eb_port}\"\n\n    sf_provider, sf_providers = _create_stepfunctions_providers(app_model, graph)\n    providers.update(sf_providers)\n    sf_provider.set_compute_providers(compute_providers)\n    local_endpoints[\"stepfunctions\"] = f\"http://127.0.0.1:{sf_port}\"\n\n    cognito_provider, cognito_providers = _create_cognito_providers(\n        app_model, data_dir, compute_providers\n    )\n    providers.update(cognito_providers)\n    local_endpoints[\"cognito-idp\"] = f\"http://127.0.0.1:{cognito_port}\"\n\n    api_provider, api_providers = _create_api_providers(\n        app_model, graph, compute_providers, api_port\n    )\n    providers.update(api_providers)\n\n    return sns_provider, eb_provider, sf_provider, cognito_provider\n\n\ndef _create_providers(\n    app_model: AppModel,\n    graph: AppGraph,\n    config: LdkConfig,\n    data_dir: Path,\n) -> tuple[dict[str, Provider], dict[str, ICompute]]:\n    \"\"\"Instantiate providers from the parsed app model.\n\n    Returns a tuple of (provider map, compute_providers).\n    \"\"\"\n    providers: dict[str, Provider] = {}\n\n    # Port allocation: base+1 DynamoDB, +2 SQS, +3 S3, +4 SNS, +5 EventBridge,\n    # +6 Step Functions, +7 Cognito, +12 SSM, +13 Secrets Manager\n    dynamo_port = config.port + 1\n    sqs_port = config.port + 2\n    s3_port = config.port + 3\n    sns_port = config.port + 4\n    eb_port = config.port + 5\n    sf_port = config.port + 6\n    cognito_port = config.port + 7\n    ssm_port = config.port + 12\n    secretsmanager_port = config.port + 13\n\n    # 1. Storage providers (no deps)\n    dynamo_provider, dynamo_providers = _create_dynamo_providers(app_model, graph, data_dir)\n    providers.update(dynamo_providers)\n\n    sqs_provider, sqs_providers = _create_sqs_providers(app_model, graph)\n    providers.update(sqs_providers)\n\n    s3_provider, s3_providers = _create_s3_providers(app_model, graph, data_dir)\n    providers.update(s3_providers)\n\n    # 2. Build local_endpoints for SDK env redirection\n    local_endpoints: dict[str, str] = {}\n    local_endpoints[\"dynamodb\"] = f\"http://127.0.0.1:{dynamo_port}\"\n    local_endpoints[\"sqs\"] = f\"http://127.0.0.1:{sqs_port}\"\n    local_endpoints[\"s3\"] = f\"http://127.0.0.1:{s3_port}\"\n\n    # 3. Compute (Lambda — Node.js + Python)\n    sdk_env = build_sdk_env(local_endpoints)\n    compute_providers, compute_graph_providers = _create_compute_providers(\n        app_model, graph, local_endpoints, sdk_env\n    )\n    providers.update(compute_graph_providers)\n\n    # 4-6. Messaging, ECS, Cognito, API Gateway\n    sns_provider, eb_provider, sf_provider, cognito_provider = _wire_remaining_providers(\n        app_model,\n        graph,\n        providers,\n        compute_providers,\n        sqs_provider,\n        local_endpoints,\n        data_dir,\n        config.port,\n        sns_port=sns_port,\n        eb_port=eb_port,\n        sf_port=sf_port,\n        cognito_port=cognito_port,\n    )\n    ecs_provider, ecs_providers = _create_ecs_providers(app_model, graph)\n    providers.update(ecs_providers)\n\n    # 7. Add SSM and Secrets Manager endpoints, rebuild SDK env, update compute\n    local_endpoints[\"ssm\"] = f\"http://127.0.0.1:{ssm_port}\"\n    local_endpoints[\"secretsmanager\"] = f\"http://127.0.0.1:{secretsmanager_port}\"\n    sdk_env = build_sdk_env(local_endpoints)\n    for compute in compute_providers.values():\n        if hasattr(compute, \"_sdk_env\"):\n            compute._sdk_env = sdk_env\n\n    # 8. Create HTTP servers for each active service\n    _register_http_providers(\n        providers,\n        dynamo_provider=dynamo_provider,\n        sqs_provider=sqs_provider,\n        s3_provider=s3_provider,\n        sns_provider=sns_provider,\n        eb_provider=eb_provider,\n        sf_provider=sf_provider,\n        cognito_provider=cognito_provider,\n        ports={\n            \"dynamodb\": dynamo_port,\n            \"sqs\": sqs_port,\n            \"s3\": s3_port,\n            \"sns\": sns_port,\n            \"eventbridge\": eb_port,\n            \"stepfunctions\": sf_port,\n            \"cognito\": cognito_port,\n        },\n    )\n\n    # 9. SSM Parameter Store and Secrets Manager (pre-seeded from CloudFormation)\n    from lws.providers.secretsmanager.routes import create_secretsmanager_app\n    from lws.providers.ssm.routes import create_ssm_app\n\n    ssm_params = [\n        {\"name\": p.name, \"type\": p.type, \"value\": p.value, \"description\": p.description}\n        for p in app_model.ssm_parameters\n    ]\n    sm_secrets = [\n        {\"name\": s.name, \"description\": s.description, \"secret_string\": s.secret_string}\n        for s in app_model.secrets\n    ]\n\n    providers[\"__ssm_http__\"] = _HttpServiceProvider(\n        \"ssm-http\", lambda: create_ssm_app(ssm_params), ssm_port\n    )\n    providers[\"__secretsmanager_http__\"] = _HttpServiceProvider(\n        \"secretsmanager-http\", lambda: create_secretsmanager_app(sm_secrets), secretsmanager_port\n    )\n\n    return providers, compute_providers\n\n\ndef _register_http_providers(\n    providers: dict[str, Provider],\n    *,\n    dynamo_provider: SqliteDynamoProvider,\n    sqs_provider: SqsProvider,\n    s3_provider: S3Provider,\n    sns_provider: SnsProvider,\n    eb_provider: EventBridgeProvider,\n    sf_provider: StepFunctionsProvider,\n    cognito_provider: CognitoProvider,\n    ports: dict[str, int],\n) -> None:\n    \"\"\"Register HTTP service providers for each active backend.\"\"\"\n    from lws.providers.cognito.routes import create_cognito_app\n    from lws.providers.eventbridge.routes import create_eventbridge_app\n    from lws.providers.stepfunctions.routes import create_stepfunctions_app\n\n    http_services: list[tuple[str, Any, Callable[[], Any]]] = []\n    http_services.append(\n        (\"dynamodb\", ports[\"dynamodb\"], lambda p=dynamo_provider: create_dynamodb_app(p))\n    )\n    http_services.append(\n        (\"sqs\", ports[\"sqs\"], lambda p=sqs_provider, pt=ports[\"sqs\"]: create_sqs_app(p, pt))\n    )\n    http_services.append((\"s3\", ports[\"s3\"], lambda p=s3_provider: create_s3_app(p)))\n    http_services.append((\"sns\", ports[\"sns\"], lambda p=sns_provider: create_sns_app(p)))\n    http_services.append(\n        (\"eventbridge\", ports[\"eventbridge\"], lambda p=eb_provider: create_eventbridge_app(p))\n    )\n    http_services.append(\n        (\n            \"stepfunctions\",\n            ports[\"stepfunctions\"],\n            lambda p=sf_provider: create_stepfunctions_app(p),\n        )\n    )\n    http_services.append(\n        (\"cognito\", ports[\"cognito\"], lambda p=cognito_provider: create_cognito_app(p))\n    )\n\n    for svc_name, port, factory in http_services:\n        providers[f\"__{svc_name}_http__\"] = _HttpServiceProvider(f\"{svc_name}-http\", factory, port)\n\n\nclass _HttpServiceProvider(Provider):\n    \"\"\"Generic wrapper that runs any FastAPI app as a uvicorn-served Provider.\"\"\"\n\n    def __init__(self, service_name: str, app_factory: Callable[[], Any], port: int) -> None:\n        self._service_name = service_name\n        self._app_factory = app_factory\n        self._port = port\n        self._server: uvicorn.Server | None = None\n        self._task: asyncio.Task | None = None  # type: ignore[type-arg]\n\n    @property\n    def name(self) -> str:\n        return self._service_name\n\n    async def start(self) -> None:\n        http_app = self._app_factory()\n        uvi_config = uvicorn.Config(\n            app=http_app,\n            host=\"0.0.0.0\",\n            port=self._port,\n            log_level=\"warning\",\n        )\n        self._server = uvicorn.Server(uvi_config)\n        self._task = asyncio.create_task(self._server.serve())\n        # Wait for the server to actually bind before reporting as started\n        for _ in range(50):\n            if self._server.started:\n                break\n            await asyncio.sleep(0.1)\n\n    async def stop(self) -> None:\n        if self._server is not None:\n            self._server.should_exit = True\n        if self._task is not None:\n            await self._task\n            self._task = None\n        self._server = None\n\n    async def health_check(self) -> bool:\n        return self._server is not None\n\n\ndef _build_resource_metadata(app_model: AppModel, port: int) -> dict[str, Any]:\n    \"\"\"Build resource metadata for the ``/_ldk/resources`` endpoint.\"\"\"\n    metadata: dict[str, Any] = {\"port\": port, \"services\": {}}\n    services = metadata[\"services\"]\n    ports = _service_ports(port)\n\n    _add_api_metadata(services, app_model, port)\n    _add_service_metadata(services, app_model, ports)\n    return metadata\n\n\ndef _service_ports(port: int) -> dict[str, int]:\n    \"\"\"Return a mapping of service name to port number.\"\"\"\n    return {\n        \"dynamodb\": port + 1,\n        \"sqs\": port + 2,\n        \"s3\": port + 3,\n        \"sns\": port + 4,\n        \"events\": port + 5,\n        \"stepfunctions\": port + 6,\n        \"cognito-idp\": port + 7,\n        \"ssm\": port + 12,\n        \"secretsmanager\": port + 13,\n    }\n\n\ndef _add_api_metadata(services: dict[str, Any], app_model: AppModel, port: int) -> None:\n    \"\"\"Add API Gateway metadata to services.\"\"\"\n    if not app_model.apis:\n        return\n    routes = []\n    for api_def in app_model.apis:\n        for r in api_def.routes:\n            routes.append(\n                {\n                    \"name\": api_def.name,\n                    \"path\": r.path,\n                    \"method\": r.method,\n                    \"handler\": r.handler_name or \"\",\n                }\n            )\n    services[\"apigateway\"] = {\"port\": port, \"resources\": routes}\n\n\ndef _add_service_metadata(\n    services: dict[str, Any], app_model: AppModel, ports: dict[str, int]\n) -> None:\n    \"\"\"Add non-API service metadata to services.\"\"\"\n    if app_model.functions:\n        services[\"lambda\"] = {\n            \"resources\": [\n                {\n                    \"name\": f.name,\n                    \"runtime\": f.runtime,\n                    \"arn\": f\"arn:aws:lambda:us-east-1:000000000000:function:{f.name}\",\n                }\n                for f in app_model.functions\n            ],\n        }\n    if app_model.tables:\n        services[\"dynamodb\"] = {\n            \"port\": ports[\"dynamodb\"],\n            \"resources\": [{\"name\": t.name} for t in app_model.tables],\n        }\n    if app_model.queues:\n        sqs_port = ports[\"sqs\"]\n        services[\"sqs\"] = {\n            \"port\": sqs_port,\n            \"resources\": [\n                {\n                    \"name\": q.name,\n                    \"queue_url\": f\"http://localhost:{sqs_port}/000000000000/{q.name}\",\n                }\n                for q in app_model.queues\n            ],\n        }\n    if app_model.buckets:\n        services[\"s3\"] = {\n            \"port\": ports[\"s3\"],\n            \"resources\": [{\"name\": b.name} for b in app_model.buckets],\n        }\n    if app_model.topics:\n        services[\"sns\"] = {\n            \"port\": ports[\"sns\"],\n            \"resources\": [\n                {\n                    \"name\": t.name,\n                    \"arn\": t.topic_arn or f\"arn:aws:sns:us-east-1:000000000000:{t.name}\",\n                }\n                for t in app_model.topics\n            ],\n        }\n    if app_model.event_buses:\n        services[\"events\"] = {\n            \"port\": ports[\"events\"],\n            \"resources\": [\n                {\n                    \"name\": b.name,\n                    \"arn\": b.bus_arn or f\"arn:aws:events:us-east-1:000000000000:event-bus/{b.name}\",\n                }\n                for b in app_model.event_buses\n            ],\n        }\n    if app_model.state_machines:\n        services[\"stepfunctions\"] = {\n            \"port\": ports[\"stepfunctions\"],\n            \"resources\": [\n                {\n                    \"name\": sm.name,\n                    \"arn\": f\"arn:aws:states:us-east-1:000000000000:stateMachine:{sm.name}\",\n                }\n                for sm in app_model.state_machines\n            ],\n        }\n    if app_model.user_pools:\n        services[\"cognito-idp\"] = {\n            \"port\": ports[\"cognito-idp\"],\n            \"resources\": [\n                {\"name\": p.user_pool_name, \"user_pool_id\": f\"us-east-1_{p.logical_id}\"}\n                for p in app_model.user_pools\n            ],\n        }\n\n\ndef _mount_management_api(\n    providers: dict[str, Provider],\n    orchestrator: Orchestrator,\n    compute_providers: dict[str, ICompute],\n    port: int,\n    resource_metadata: dict[str, Any] | None = None,\n) -> None:\n    \"\"\"Mount the management API router on the API Gateway app or create a standalone one.\"\"\"\n    from fastapi import FastAPI\n\n    from lws.api.management import create_management_router\n\n    mgmt_router = create_management_router(\n        orchestrator, compute_providers, providers, resource_metadata=resource_metadata\n    )\n\n    # Try to find an existing API Gateway provider to mount on\n    for key, prov in providers.items():\n        if isinstance(prov, ApiGatewayProvider):\n            prov.app.include_router(mgmt_router)\n            return\n\n    # No API Gateway — create a standalone FastAPI app for management\n    mgmt_app = FastAPI(title=\"LDK Management\")\n    mgmt_app.include_router(mgmt_router)\n    providers[\"__management_http__\"] = _HttpServiceProvider(\n        \"management-http\", lambda: mgmt_app, port\n    )\n\n\ndef _find_node_id(graph: AppGraph, node_type: NodeType, name: str) -> str | None:\n    \"\"\"Find a graph node ID by type and name.\"\"\"\n    for nid, node in graph.nodes.items():\n        if node.node_type == node_type and nid == name:\n            return nid\n    # Fallback: check config\n    for nid, node in graph.nodes.items():\n        if node.node_type == node_type:\n            if node.config.get(\"table_name\") == name or node.config.get(\"handler\") == name:\n                return nid\n    return name\n\n\ndef _build_key_schema(raw_schema: list[dict[str, str]]) -> KeySchema:\n    \"\"\"Convert raw key schema dicts to a KeySchema dataclass.\"\"\"\n    pk: KeyAttribute | None = None\n    sk: KeyAttribute | None = None\n    for ks in raw_schema:\n        attr = KeyAttribute(name=ks.get(\"attribute_name\", \"pk\"), type=ks.get(\"type\", \"S\"))\n        if ks.get(\"key_type\") == \"RANGE\":\n            sk = attr\n        else:\n            pk = attr\n    if pk is None:\n        pk = KeyAttribute(name=\"pk\", type=\"S\")\n    return KeySchema(partition_key=pk, sort_key=sk)\n\n\ndef _build_gsi(raw_gsi: dict) -> GsiDefinition:\n    \"\"\"Convert a raw GSI dict to a GsiDefinition dataclass.\"\"\"\n    index_name = raw_gsi.get(\"index_name\", raw_gsi.get(\"IndexName\", \"gsi\"))\n    ks_raw = raw_gsi.get(\"key_schema\", [])\n    ks = _build_key_schema(ks_raw)\n    projection = raw_gsi.get(\"projection_type\", \"ALL\")\n    return GsiDefinition(index_name=index_name, key_schema=ks, projection_type=projection)\n","structuredPatch":[{"oldStart":351,"oldLines":6,"newStart":351,"newLines":8,"lines":["         \"state_machines\": (\"name\", \"state_machines\"),","         \"ecs_services\": (\"service_name\", \"ecs_services\"),","         \"user_pools\": (\"user_pool_name\", \"user_pools\"),","+        \"ssm_parameters\": (\"name\", \"ssm_parameters\"),","+        \"secrets\": (\"name\", \"secrets\"),","     }","     for key, (attr, model_attr) in _RESOURCE_ATTRS.items():","         items = getattr(app_model, model_attr, [])"]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"6e1ad753-d6ca-45e6-ba4c-ab90cfbfaa20"}
{"parentUuid":"c8d9c4f1-3d95-4bd3-800c-6c2a5e2d12d9","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","message":{"model":"claude-opus-4-6","id":"msg_014f6dkUcFQZZGSP64MbSwrS","type":"message","role":"assistant","content":[{"type":"text","text":"Now add to `_add_resource_details`:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":324,"cache_read_input_tokens":70657,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":324},"output_tokens":2,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CY1FMLwpa5UY1ppMWLUNo","type":"assistant","uuid":"29227944-7f49-49fd-bf23-aa980db35832","timestamp":"2026-02-10T23:22:25.261Z"}
{"parentUuid":"29227944-7f49-49fd-bf23-aa980db35832","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","message":{"model":"claude-opus-4-6","id":"msg_014f6dkUcFQZZGSP64MbSwrS","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01GUmzjFTKM5wK61aWMxe9Uz","name":"Edit","input":{"replace_all":false,"file_path":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services/src/lws/cli/ldk.py","old_string":"    for p in app_model.user_pools:\n        details[f\"User Pool:{p.user_pool_name}\"] = (\n            f\"lws cognito-idp sign-up --user-pool-name {p.user_pool_name}\"\n        )","new_string":"    for p in app_model.user_pools:\n        details[f\"User Pool:{p.user_pool_name}\"] = (\n            f\"lws cognito-idp sign-up --user-pool-name {p.user_pool_name}\"\n        )\n    for p in app_model.ssm_parameters:\n        details[f\"Parameter:{p.name}\"] = f\"lws ssm get-parameter --name {p.name}\"\n    for s in app_model.secrets:\n        details[f\"Secret:{s.name}\"] = f\"lws secretsmanager get-secret-value --secret-id {s.name}\""}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":324,"cache_read_input_tokens":70657,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":324},"output_tokens":2,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CY1FMLwpa5UY1ppMWLUNo","type":"assistant","uuid":"92a40da6-afde-4bd0-9e9b-b61b5106bb90","timestamp":"2026-02-10T23:22:28.518Z"}
{"parentUuid":"92a40da6-afde-4bd0-9e9b-b61b5106bb90","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"callback"},"parentToolUseID":"toolu_01GUmzjFTKM5wK61aWMxe9Uz","toolUseID":"toolu_01GUmzjFTKM5wK61aWMxe9Uz","timestamp":"2026-02-10T23:22:28.528Z","uuid":"fb17e333-1226-4a43-97c7-7f44c4d5f0d0"}
{"parentUuid":"92a40da6-afde-4bd0-9e9b-b61b5106bb90","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01GUmzjFTKM5wK61aWMxe9Uz","type":"tool_result","content":"The file /Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services/src/lws/cli/ldk.py has been updated successfully."}]},"uuid":"07948bc9-b1c4-4802-bb46-10efd4f07f54","timestamp":"2026-02-10T23:22:28.527Z","toolUseResult":{"filePath":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services/src/lws/cli/ldk.py","oldString":"    for p in app_model.user_pools:\n        details[f\"User Pool:{p.user_pool_name}\"] = (\n            f\"lws cognito-idp sign-up --user-pool-name {p.user_pool_name}\"\n        )","newString":"    for p in app_model.user_pools:\n        details[f\"User Pool:{p.user_pool_name}\"] = (\n            f\"lws cognito-idp sign-up --user-pool-name {p.user_pool_name}\"\n        )\n    for p in app_model.ssm_parameters:\n        details[f\"Parameter:{p.name}\"] = f\"lws ssm get-parameter --name {p.name}\"\n    for s in app_model.secrets:\n        details[f\"Secret:{s.name}\"] = f\"lws secretsmanager get-secret-value --secret-id {s.name}\"","originalFile":"\"\"\"LDK CLI entry point.\n\nProvides the ``ldk dev``, ``ldk invoke``, and ``ldk reset`` commands.\n``ldk dev`` parses a CDK cloud assembly, builds the application graph,\nstarts local providers, and watches for file changes.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport asyncio\nimport json\nimport logging\nimport shutil\nfrom collections.abc import Callable\nfrom pathlib import Path\nfrom typing import Any\n\nimport typer\nimport uvicorn\nfrom rich.console import Console\nfrom rich.syntax import Syntax\n\nfrom lws.cli.display import (\n    print_banner,\n    print_error,\n    print_resource_summary,\n    print_startup_complete,\n)\nfrom lws.config.loader import ConfigError, LdkConfig, load_config\nfrom lws.graph.builder import AppGraph, NodeType, build_graph\nfrom lws.interfaces import (\n    ComputeConfig,\n    GsiDefinition,\n    ICompute,\n    KeyAttribute,\n    KeySchema,\n    Provider,\n    TableConfig,\n)\nfrom lws.parser.assembly import AppModel, parse_assembly\nfrom lws.providers.apigateway.provider import ApiGatewayProvider, RouteConfig\nfrom lws.providers.cognito.provider import CognitoProvider\nfrom lws.providers.cognito.user_store import PasswordPolicy, UserPoolConfig\nfrom lws.providers.dynamodb.provider import SqliteDynamoProvider\nfrom lws.providers.dynamodb.routes import create_dynamodb_app\nfrom lws.providers.ecs.provider import EcsProvider\nfrom lws.providers.eventbridge.provider import (\n    EventBridgeProvider,\n    EventBusConfig,\n    RuleConfig,\n    RuleTarget,\n)\nfrom lws.providers.lambda_runtime.nodejs import NodeJsCompute\nfrom lws.providers.lambda_runtime.python import PythonCompute\nfrom lws.providers.s3.provider import S3Provider\nfrom lws.providers.s3.routes import create_s3_app\nfrom lws.providers.sns.provider import SnsProvider, TopicConfig\nfrom lws.providers.sns.routes import create_sns_app\nfrom lws.providers.sqs.provider import QueueConfig, RedrivePolicy, SqsProvider\nfrom lws.providers.sqs.routes import create_sqs_app\nfrom lws.providers.stepfunctions.provider import (\n    StateMachineConfig,\n    StepFunctionsProvider,\n    WorkflowType,\n)\nfrom lws.runtime.env_builder import build_lambda_env\nfrom lws.runtime.orchestrator import Orchestrator\nfrom lws.runtime.sdk_env import build_sdk_env\nfrom lws.runtime.synth import SynthError, ensure_synth\nfrom lws.runtime.watcher import FileWatcher\n\n_console = Console()\n\napp = typer.Typer(name=\"ldk\", help=\"Local Development Kit - Run AWS CDK applications locally\")\n\n__version__ = \"0.4.0\"\n\n\n@app.callback()\ndef main() -> None:\n    \"\"\"LDK - Local Development Kit.\"\"\"\n\n\n@app.command()\ndef dev(\n    port: int = typer.Option(None, \"--port\", \"-p\", help=\"API Gateway listen port\"),\n    no_persist: bool = typer.Option(False, \"--no-persist\", help=\"Disable data persistence\"),\n    force_synth: bool = typer.Option(False, \"--force-synth\", help=\"Force CDK synth\"),\n    log_level: str = typer.Option(\n        None, \"--log-level\", \"-l\", help=\"Log level (debug/info/warning/error)\"\n    ),\n    project_dir: Path = typer.Option(\".\", \"--project-dir\", \"-d\", help=\"Project root directory\"),\n    mode: str = typer.Option(None, \"--mode\", \"-m\", help=\"Project mode (cdk or terraform)\"),\n) -> None:\n    \"\"\"Start the local development environment.\"\"\"\n    try:\n        asyncio.run(_run_dev(project_dir, port, no_persist, force_synth, log_level, mode))\n    except KeyboardInterrupt:\n        pass\n\n\n@app.command()\ndef invoke(\n    function_name: str = typer.Option(..., \"--function-name\", \"-f\", help=\"Lambda function name\"),\n    event: str = typer.Option(None, \"--event\", \"-e\", help=\"Inline JSON event payload\"),\n    event_file: Path = typer.Option(None, \"--event-file\", help=\"Path to JSON event file\"),\n    project_dir: Path = typer.Option(\".\", \"--project-dir\", \"-d\", help=\"Project root directory\"),\n    port: int = typer.Option(None, \"--port\", \"-p\", help=\"Management API port\"),\n) -> None:\n    \"\"\"Invoke a Lambda function directly.\"\"\"\n    asyncio.run(_run_invoke(function_name, event, event_file, project_dir, port))\n\n\nasync def _run_invoke(\n    function_name: str,\n    event_json: str | None,\n    event_file: Path | None,\n    project_dir: Path,\n    port_override: int | None,\n) -> None:\n    \"\"\"Async implementation of the ``ldk invoke`` command.\"\"\"\n    # Resolve event payload\n    event_payload = _resolve_event_payload(event_json, event_file)\n\n    # Try connecting to running ldk dev via management API\n    project_dir = project_dir.resolve()\n    config = _load_config_quiet(project_dir)\n    mgmt_port = port_override or config.port\n\n    if await _try_management_invoke(mgmt_port, function_name, event_payload):\n        return\n\n    # Fallback: one-shot invocation\n    _console.print(\"[dim]No running ldk dev found, performing one-shot invocation...[/dim]\")\n    await _oneshot_invoke(project_dir, config, function_name, event_payload)\n\n\ndef _resolve_event_payload(event_json: str | None, event_file: Path | None) -> dict:\n    \"\"\"Parse event payload from CLI args.\"\"\"\n    if event_json is not None:\n        try:\n            return json.loads(event_json)\n        except json.JSONDecodeError as exc:\n            print_error(\"Invalid JSON in --event\", str(exc))\n            raise typer.Exit(1)\n\n    if event_file is not None:\n        if not event_file.exists():\n            print_error(\"Event file not found\", str(event_file))\n            raise typer.Exit(1)\n        try:\n            return json.loads(event_file.read_text())\n        except json.JSONDecodeError as exc:\n            print_error(\"Invalid JSON in event file\", str(exc))\n            raise typer.Exit(1)\n\n    return {}\n\n\nasync def _try_management_invoke(port: int, function_name: str, event: dict) -> bool:\n    \"\"\"Try to invoke via the management API. Return True if successful.\"\"\"\n    try:\n        import httpx\n\n        async with httpx.AsyncClient() as client:\n            resp = await client.post(\n                f\"http://localhost:{port}/_ldk/invoke\",\n                json={\"function_name\": function_name, \"event\": event},\n                timeout=30.0,\n            )\n            result = resp.json()\n            formatted = json.dumps(result, indent=2)\n            syntax = Syntax(formatted, \"json\", theme=\"monokai\")\n            _console.print(syntax)\n            return True\n    except Exception:\n        return False\n\n\nasync def _oneshot_invoke(\n    project_dir: Path, config: LdkConfig, function_name: str, event: dict\n) -> None:\n    \"\"\"Perform a one-shot Lambda invocation without a running server.\"\"\"\n    try:\n        import uuid as _uuid\n\n        from lws.interfaces import InvocationResult, LambdaContext\n\n        cdk_out = project_dir / config.cdk_out_dir\n        if not cdk_out.exists():\n            print_error(\"CDK output not found\", f\"Run 'cdk synth' first in {project_dir}\")\n            raise typer.Exit(1)\n\n        app_model = parse_assembly(cdk_out)\n        func_def = next((f for f in app_model.functions if f.name == function_name), None)\n        if func_def is None:\n            print_error(\"Function not found\", f\"No function named '{function_name}'\")\n            raise typer.Exit(1)\n\n        sdk_env = build_sdk_env({})\n        func_env = build_lambda_env(\n            function_name=func_def.name,\n            function_env=func_def.environment,\n            local_endpoints={},\n            resolved_refs={},\n        )\n        compute_config = ComputeConfig(\n            function_name=func_def.name,\n            handler=func_def.handler,\n            runtime=func_def.runtime,\n            code_path=func_def.code_path or Path(\".\"),\n            timeout=func_def.timeout,\n            memory_size=func_def.memory,\n            environment=func_env,\n        )\n        compute = NodeJsCompute(config=compute_config, sdk_env=sdk_env)\n        await compute.start()\n\n        request_id = str(_uuid.uuid4())\n        context = LambdaContext(\n            function_name=function_name,\n            memory_limit_in_mb=compute_config.memory_size,\n            timeout_seconds=compute_config.timeout,\n            aws_request_id=request_id,\n            invoked_function_arn=(\n                f\"arn:aws:lambda:us-east-1:000000000000:function:{function_name}\"\n            ),\n        )\n\n        result: InvocationResult = await compute.invoke(event, context)\n        await compute.stop()\n\n        output = result.payload if result.error is None else {\"error\": result.error}\n        formatted = json.dumps(output, indent=2, default=str)\n        syntax = Syntax(formatted, \"json\", theme=\"monokai\")\n        _console.print(syntax)\n\n    except typer.Exit:\n        raise\n    except Exception as exc:\n        print_error(\"Invocation failed\", str(exc))\n        raise typer.Exit(1)\n\n\n@app.command()\ndef reset(\n    yes: bool = typer.Option(False, \"--yes\", \"-y\", help=\"Skip confirmation prompt\"),\n    project_dir: Path = typer.Option(\".\", \"--project-dir\", \"-d\", help=\"Project root directory\"),\n    port: int = typer.Option(None, \"--port\", \"-p\", help=\"Management API port\"),\n) -> None:\n    \"\"\"Reset all LDK local state (databases, queues, etc.).\"\"\"\n    project_dir = project_dir.resolve()\n    config = _load_config_quiet(project_dir)\n    data_dir = project_dir / config.data_dir\n\n    if not data_dir.exists():\n        _console.print(\"[dim]No data directory found. Nothing to reset.[/dim]\")\n        return\n\n    # List contents to be deleted\n    items = list(data_dir.iterdir())\n    if not items:\n        _console.print(\"[dim]Data directory is empty. Nothing to reset.[/dim]\")\n        return\n\n    _console.print(f\"[bold]Will delete all files under:[/bold] {data_dir}\")\n    for item in items:\n        kind = \"dir\" if item.is_dir() else \"file\"\n        _console.print(f\"  [dim]{kind}:[/dim] {item.name}\")\n\n    if not yes:\n        confirm = typer.confirm(\"Are you sure you want to delete all local state?\")\n        if not confirm:\n            _console.print(\"[dim]Aborted.[/dim]\")\n            return\n\n    # Delete contents\n    deleted_count = 0\n    for item in items:\n        if item.is_dir():\n            shutil.rmtree(item)\n        else:\n            item.unlink()\n        deleted_count += 1\n\n    _console.print(f\"[green]Deleted {deleted_count} item(s) from {data_dir}[/green]\")\n\n    # Notify running ldk dev if possible\n    mgmt_port = port or config.port\n    asyncio.run(_try_management_reset(mgmt_port))\n\n\nasync def _try_management_reset(port: int) -> None:\n    \"\"\"Try to notify running ldk dev of the reset via management API.\"\"\"\n    try:\n        import httpx\n\n        async with httpx.AsyncClient() as client:\n            resp = await client.post(\n                f\"http://localhost:{port}/_ldk/reset\",\n                timeout=5.0,\n            )\n            if resp.status_code == 200:\n                _console.print(\"[dim]Notified running ldk dev of reset.[/dim]\")\n    except Exception:\n        pass  # Server not running, that's fine\n\n\ndef _load_config_quiet(project_dir: Path) -> LdkConfig:\n    \"\"\"Load config without printing errors. Falls back to defaults.\"\"\"\n    try:\n        return load_config(project_dir)\n    except ConfigError:\n        return LdkConfig()\n\n\ndef _load_and_apply_config(\n    project_dir: Path,\n    port_override: int | None,\n    no_persist: bool,\n    log_level_override: str | None,\n) -> LdkConfig:\n    \"\"\"Load config and apply CLI overrides.\"\"\"\n    try:\n        config = load_config(project_dir)\n    except ConfigError as exc:\n        print_error(\"Configuration error\", str(exc))\n        raise typer.Exit(1)\n\n    if port_override is not None:\n        config.port = port_override\n    if log_level_override is not None:\n        config.log_level = log_level_override\n    if no_persist:\n        config.persist = False\n\n    logging.basicConfig(\n        level=getattr(logging, config.log_level.upper(), logging.INFO),\n        format=\"%(levelname)s %(name)s: %(message)s\",\n    )\n    return config\n\n\ndef _collect_extra_resources(app_model: AppModel) -> dict[str, list[str]]:\n    \"\"\"Collect extra resource name lists from the app model for display.\"\"\"\n    extras: dict[str, list[str]] = {}\n    _RESOURCE_ATTRS = {\n        \"queues\": (\"name\", \"queues\"),\n        \"buckets\": (\"name\", \"buckets\"),\n        \"topics\": (\"name\", \"topics\"),\n        \"state_machines\": (\"name\", \"state_machines\"),\n        \"ecs_services\": (\"service_name\", \"ecs_services\"),\n        \"user_pools\": (\"user_pool_name\", \"user_pools\"),\n        \"ssm_parameters\": (\"name\", \"ssm_parameters\"),\n        \"secrets\": (\"name\", \"secrets\"),\n    }\n    for key, (attr, model_attr) in _RESOURCE_ATTRS.items():\n        items = getattr(app_model, model_attr, [])\n        if items:\n            extras[key] = [getattr(item, attr, str(item)) for item in items]\n    return extras\n\n\ndef _build_local_details(app_model: AppModel, port: int) -> dict[str, str]:\n    \"\"\"Build a mapping of ``\"Type:Name\"`` to local detail strings.\"\"\"\n    details: dict[str, str] = {}\n\n    _add_api_details(details, app_model)\n    _add_resource_details(details, app_model)\n    return details\n\n\ndef _add_api_details(details: dict[str, str], app_model: AppModel) -> None:\n    \"\"\"Add API route and Lambda function details.\"\"\"\n    for api_def in app_model.apis:\n        for r in api_def.routes:\n            details[f\"API Route:{r.path}\"] = (\n                f\"lws apigateway test-invoke-method --resource {r.path} --http-method {r.method}\"\n            )\n    for f in app_model.functions:\n        details[f\"Function:{f.name}\"] = f\"ldk invoke {f.name}\"\n\n\ndef _add_resource_details(details: dict[str, str], app_model: AppModel) -> None:\n    \"\"\"Add service resource details (DynamoDB, SQS, S3, etc.).\"\"\"\n    for t in app_model.tables:\n        details[f\"Table:{t.name}\"] = f\"lws dynamodb scan --table-name {t.name}\"\n    for q in app_model.queues:\n        details[f\"Queue:{q.name}\"] = f\"lws sqs receive-message --queue-name {q.name}\"\n    for b in app_model.buckets:\n        details[f\"Bucket:{b.name}\"] = f\"lws s3api list-objects-v2 --bucket {b.name}\"\n    for t in app_model.topics:\n        details[f\"Topic:{t.name}\"] = f\"lws sns publish --topic-name {t.name} --message '...'\"\n    for b in app_model.event_buses:\n        details[f\"Event Bus:{b.name}\"] = f\"lws events list-rules --event-bus-name {b.name}\"\n    for sm in app_model.state_machines:\n        details[f\"State Machine:{sm.name}\"] = f\"lws stepfunctions start-execution --name {sm.name}\"\n    for p in app_model.user_pools:\n        details[f\"User Pool:{p.user_pool_name}\"] = (\n            f\"lws cognito-idp sign-up --user-pool-name {p.user_pool_name}\"\n        )\n\n\ndef _display_summary(app_model: AppModel, port: int) -> None:\n    \"\"\"Print resource summary and startup-complete banner.\"\"\"\n    routes_info = [\n        {\"method\": r.method, \"path\": r.path, \"handler\": r.handler_name or \"\"}\n        for api_def in app_model.apis\n        for r in api_def.routes\n    ]\n    tables_info = [t.name for t in app_model.tables]\n    functions_info = [f\"{f.name} ({f.runtime})\" for f in app_model.functions]\n\n    extra_resources = _collect_extra_resources(app_model)\n    local_details = _build_local_details(app_model, port)\n    print_resource_summary(\n        routes_info, tables_info, functions_info, local_details=local_details, **extra_resources\n    )\n\n    extra_counts = {f\"num_{k}\": len(v) for k, v in extra_resources.items()}\n    print_startup_complete(\n        port,\n        num_routes=len(routes_info),\n        num_tables=len(tables_info),\n        num_functions=len(functions_info),\n        **extra_counts,\n    )\n\n\ndef _resolve_mode(project_dir: Path, config: LdkConfig, mode_override: str | None) -> str:\n    \"\"\"Resolve the project mode from CLI flag, config, or auto-detection.\n\n    Returns ``\"cdk\"`` or ``\"terraform\"``.\n    Raises ``typer.Exit(1)`` on error.\n    \"\"\"\n    from lws.terraform.detect import detect_project_type\n\n    mode = mode_override or config.mode\n    if mode:\n        if mode not in (\"cdk\", \"terraform\"):\n            print_error(\"Invalid mode\", f\"Must be 'cdk' or 'terraform', got '{mode}'\")\n            raise typer.Exit(1)\n        return mode\n\n    detected = detect_project_type(project_dir)\n    if detected == \"ambiguous\":\n        print_error(\n            \"Ambiguous project\",\n            \"Both .tf files and cdk.out found. Use --mode cdk or --mode terraform.\",\n        )\n        raise typer.Exit(1)\n    if detected == \"none\":\n        print_error(\n            \"No project found\",\n            \"No .tf files or cdk.out directory found. \"\n            \"Run from a CDK or Terraform project directory.\",\n        )\n        raise typer.Exit(1)\n    return detected\n\n\nasync def _run_dev_terraform(project_dir: Path, config: LdkConfig) -> None:\n    \"\"\"Run the dev server in Terraform mode.\n\n    Starts all service providers in always-on mode, generates the\n    Terraform provider override file, and waits for shutdown.\n    \"\"\"\n    from lws.terraform.gitignore import ensure_gitignore\n    from lws.terraform.override import cleanup_override, generate_override\n\n    port = config.port\n    data_dir = project_dir / config.data_dir\n    data_dir.mkdir(parents=True, exist_ok=True)\n\n    # Generate override file\n    try:\n        override_path = generate_override(port, project_dir)\n    except FileExistsError as exc:\n        print_error(\"Override file conflict\", str(exc))\n        raise typer.Exit(1)\n\n    ensure_gitignore(project_dir)\n\n    # Create all providers in always-on mode (no app model)\n    providers, ports = _create_terraform_providers(config, data_dir, project_dir)\n\n    orchestrator = Orchestrator()\n\n    # Enable WebSocket log streaming\n    from lws.logging.logger import WebSocketLogHandler, set_ws_handler\n\n    ws_log_handler = WebSocketLogHandler()\n    set_ws_handler(ws_log_handler)\n\n    # Build resource metadata so the CLI client can discover services\n    resource_metadata: dict[str, Any] = {\n        \"port\": port,\n        \"services\": {\n            svc_name: {\"port\": svc_port, \"resources\": []} for svc_name, svc_port in ports.items()\n        },\n    }\n\n    # Mount management API (no compute providers in terraform mode)\n    _mount_management_api(providers, orchestrator, {}, port, resource_metadata)\n\n    for key in providers:\n        pass  # All keys are already in the dict\n\n    startup_order = list(providers.keys())\n\n    try:\n        await orchestrator.start(providers, startup_order)\n    except Exception as exc:\n        cleanup_override(project_dir)\n        print_error(\"Failed to start providers\", str(exc))\n        raise typer.Exit(1)\n\n    # Display summary\n    _console.print()\n    _console.print(\"[bold green]Terraform mode active[/bold green]\")\n    _console.print(f\"  Override file: {override_path}\")\n    _console.print()\n    _console.print(\"[bold]Service endpoints:[/bold]\")\n    for svc_name, svc_port in sorted(ports.items()):\n        _console.print(f\"  {svc_name:20s} http://localhost:{svc_port}\")\n    _console.print()\n    _console.print(\"[dim]Run 'terraform init && terraform apply' to create resources.[/dim]\")\n    _console.print(f\"  Dashboard: http://localhost:{config.port}/_ldk/gui\")\n    _console.print()\n\n    try:\n        await orchestrator.wait_for_shutdown()\n    finally:\n        cleanup_override(project_dir)\n        set_ws_handler(None)\n        await orchestrator.stop()\n        typer.echo(\"Goodbye\")\n\n\ndef _create_terraform_providers(\n    config: LdkConfig,\n    data_dir: Path,\n    project_dir: Path | None = None,\n) -> tuple[dict[str, Provider], dict[str, int]]:\n    \"\"\"Create all service providers for Terraform mode (no app model).\"\"\"\n    providers: dict[str, Provider] = {}\n\n    port = config.port\n    ports = {\n        \"dynamodb\": port + 1,\n        \"sqs\": port + 2,\n        \"s3\": port + 3,\n        \"sns\": port + 4,\n        \"eventbridge\": port + 5,\n        \"stepfunctions\": port + 6,\n        \"cognito\": port + 7,\n        \"apigateway\": port + 8,\n        \"lambda\": port + 9,\n        \"iam\": port + 10,\n        \"sts\": port + 11,\n        \"ssm\": port + 12,\n        \"secretsmanager\": port + 13,\n    }\n\n    dynamo_provider = SqliteDynamoProvider(data_dir=data_dir, tables=[])\n    sqs_provider = SqsProvider()\n    s3_provider = S3Provider(data_dir=data_dir)\n    sns_provider = SnsProvider()\n    eb_provider = EventBridgeProvider()\n    sf_provider = StepFunctionsProvider()\n\n    pool_config = UserPoolConfig(\n        user_pool_id=\"us-east-1_default\",\n        user_pool_name=\"default\",\n    )\n    cognito_provider = CognitoProvider(data_dir=data_dir, config=pool_config)\n\n    _register_http_providers(\n        providers,\n        dynamo_provider=dynamo_provider,\n        sqs_provider=sqs_provider,\n        s3_provider=s3_provider,\n        sns_provider=sns_provider,\n        eb_provider=eb_provider,\n        sf_provider=sf_provider,\n        cognito_provider=cognito_provider,\n        ports=ports,\n    )\n\n    # Shared Lambda registry for Lambda management and API Gateway V2 proxy\n    from lws.providers.lambda_runtime.routes import LambdaRegistry, create_lambda_management_app\n\n    lambda_registry = LambdaRegistry()\n\n    # Wire Lambda registry compute providers into Step Functions so SFN can\n    # invoke Lambda functions that Terraform creates dynamically.\n    sf_provider.set_compute_providers(lambda_registry._compute)\n\n    # Build SDK env so Lambda functions can reach local services\n    local_endpoints: dict[str, str] = {\n        \"dynamodb\": f\"http://127.0.0.1:{ports['dynamodb']}\",\n        \"sqs\": f\"http://127.0.0.1:{ports['sqs']}\",\n        \"s3\": f\"http://127.0.0.1:{ports['s3']}\",\n        \"sns\": f\"http://127.0.0.1:{ports['sns']}\",\n        \"events\": f\"http://127.0.0.1:{ports['eventbridge']}\",\n        \"stepfunctions\": f\"http://127.0.0.1:{ports['stepfunctions']}\",\n        \"cognito-idp\": f\"http://127.0.0.1:{ports['cognito']}\",\n        \"ssm\": f\"http://127.0.0.1:{ports['ssm']}\",\n        \"secretsmanager\": f\"http://127.0.0.1:{ports['secretsmanager']}\",\n    }\n    sdk_env = build_sdk_env(local_endpoints)\n\n    # Lambda management API\n    providers[\"__lambda_http__\"] = _HttpServiceProvider(\n        \"lambda-http\",\n        lambda: create_lambda_management_app(lambda_registry, project_dir, sdk_env),\n        ports[\"lambda\"],\n    )\n\n    # API Gateway management API with V2 support and Lambda proxy\n    from lws.providers.apigateway.routes import create_apigateway_management_app\n\n    providers[\"__apigateway_http__\"] = _HttpServiceProvider(\n        \"apigateway-http\",\n        lambda: create_apigateway_management_app(lambda_registry),\n        ports[\"apigateway\"],\n    )\n\n    # IAM stub\n    from lws.providers.iam.routes import create_iam_app\n\n    providers[\"__iam_http__\"] = _HttpServiceProvider(\"iam-http\", create_iam_app, ports[\"iam\"])\n\n    # STS stub\n    from lws.providers.sts.routes import create_sts_app\n\n    providers[\"__sts_http__\"] = _HttpServiceProvider(\"sts-http\", create_sts_app, ports[\"sts\"])\n\n    # SSM Parameter Store\n    from lws.providers.ssm.routes import create_ssm_app\n\n    providers[\"__ssm_http__\"] = _HttpServiceProvider(\"ssm-http\", create_ssm_app, ports[\"ssm\"])\n\n    # Secrets Manager\n    from lws.providers.secretsmanager.routes import create_secretsmanager_app\n\n    providers[\"__secretsmanager_http__\"] = _HttpServiceProvider(\n        \"secretsmanager-http\", create_secretsmanager_app, ports[\"secretsmanager\"]\n    )\n\n    return providers, ports\n\n\ndef _has_any_resources(app_model: AppModel) -> bool:\n    \"\"\"Return True if the app model contains at least one resource.\"\"\"\n    return bool(\n        app_model.functions\n        or app_model.tables\n        or app_model.apis\n        or app_model.queues\n        or app_model.buckets\n        or app_model.topics\n        or app_model.event_buses\n        or app_model.state_machines\n        or app_model.ecs_services\n        or app_model.user_pools\n    )\n\n\nasync def _run_dev(\n    project_dir: Path,\n    port_override: int | None,\n    no_persist: bool,\n    force_synth: bool,\n    log_level_override: str | None,\n    mode_override: str | None = None,\n) -> None:\n    \"\"\"Async implementation of the ``ldk dev`` command.\"\"\"\n    project_dir = project_dir.resolve()\n    config = _load_and_apply_config(project_dir, port_override, no_persist, log_level_override)\n    print_banner(__version__, project_dir.name)\n\n    # Resolve project mode\n    resolved_mode = _resolve_mode(project_dir, config, mode_override)\n    if resolved_mode == \"terraform\":\n        await _run_dev_terraform(project_dir, config)\n        return\n\n    try:\n        cdk_out = await ensure_synth(project_dir, force=force_synth)\n    except SynthError as exc:\n        print_error(\"CDK synth failed\", str(exc))\n        raise typer.Exit(1)\n\n    app_model = parse_assembly(cdk_out)\n    if not _has_any_resources(app_model):\n        print_error(\"No resources found in cloud assembly\", str(cdk_out))\n        raise typer.Exit(1)\n\n    graph = build_graph(app_model)\n    startup_order = graph.topological_sort()\n\n    data_dir = project_dir / config.data_dir\n    data_dir.mkdir(parents=True, exist_ok=True)\n    providers, compute_providers = _create_providers(app_model, graph, config, data_dir)\n\n    orchestrator = Orchestrator()\n\n    # Enable WebSocket log streaming\n    from lws.logging.logger import WebSocketLogHandler, set_ws_handler\n\n    ws_log_handler = WebSocketLogHandler()\n    set_ws_handler(ws_log_handler)\n\n    # Mount management API\n    resource_metadata = _build_resource_metadata(app_model, config.port)\n    _mount_management_api(\n        providers, orchestrator, compute_providers, config.port, resource_metadata\n    )\n\n    # Append non-graph provider keys (HTTP servers, management) to startup order.\n    # This must happen after _mount_management_api so the fallback management\n    # HTTP server (when no API Gateway exists) is included in the startup order.\n    for key in providers:\n        if key not in startup_order:\n            startup_order.append(key)\n\n    try:\n        await orchestrator.start(providers, startup_order)\n    except Exception as exc:\n        print_error(\"Failed to start providers\", str(exc))\n        raise typer.Exit(1)\n\n    _display_summary(app_model, config.port)\n    typer.echo(f\"  Dashboard: http://localhost:{config.port}/_ldk/gui\")\n\n    watcher = FileWatcher(\n        watch_dir=project_dir,\n        include_patterns=config.watch_include,\n        exclude_patterns=config.watch_exclude,\n    )\n    watcher.on_change(lambda path: logging.getLogger(\"ldk.watcher\").info(\"Changed: %s\", path))\n    watcher.start()\n\n    try:\n        await orchestrator.wait_for_shutdown()\n    finally:\n        watcher.stop()\n        set_ws_handler(None)\n        await orchestrator.stop()\n        typer.echo(\"Goodbye\")\n\n\ndef _create_dynamo_providers(\n    app_model: AppModel,\n    graph: AppGraph,\n    data_dir: Path,\n) -> tuple[SqliteDynamoProvider, dict[str, Provider]]:\n    \"\"\"Create DynamoDB table providers from the app model.\n\n    Always returns a provider (even with no CDK tables) so the DynamoDB\n    HTTP endpoint is available for Terraform/CLI table creation.\n    \"\"\"\n    providers: dict[str, Provider] = {}\n    table_configs: list[TableConfig] = []\n    for table in app_model.tables:\n        ks = _build_key_schema(table.key_schema)\n        gsi_defs = [_build_gsi(g) for g in table.gsi_definitions]\n        table_configs.append(\n            TableConfig(table_name=table.name, key_schema=ks, gsi_definitions=gsi_defs)\n        )\n\n    dynamo_provider = SqliteDynamoProvider(data_dir=data_dir, tables=table_configs)\n    for table in app_model.tables:\n        node_id = _find_node_id(graph, NodeType.DYNAMODB_TABLE, table.name)\n        if node_id:\n            providers[node_id] = dynamo_provider\n    return dynamo_provider, providers\n\n\ndef _create_compute_providers(\n    app_model: AppModel,\n    graph: AppGraph,\n    local_endpoints: dict[str, str],\n    sdk_env: dict[str, str],\n) -> tuple[dict[str, ICompute], dict[str, Provider]]:\n    \"\"\"Create Lambda compute providers from the app model (Node.js + Python).\"\"\"\n    providers: dict[str, Provider] = {}\n    compute_providers: dict[str, ICompute] = {}\n    for func in app_model.functions:\n        func_env = build_lambda_env(\n            function_name=func.name,\n            function_env=func.environment,\n            local_endpoints=local_endpoints,\n            resolved_refs={},\n        )\n        compute_config = ComputeConfig(\n            function_name=func.name,\n            handler=func.handler,\n            runtime=func.runtime,\n            code_path=func.code_path or Path(\".\"),\n            timeout=func.timeout,\n            memory_size=func.memory,\n            environment=func_env,\n        )\n        if func.runtime.startswith(\"python\"):\n            compute: ICompute = PythonCompute(config=compute_config, sdk_env=sdk_env)\n        elif func.runtime.startswith(\"nodejs\"):\n            compute = NodeJsCompute(config=compute_config, sdk_env=sdk_env)\n        else:\n            logging.getLogger(\"ldk.cli\").warning(\n                \"Unsupported runtime %s for %s, skipping\", func.runtime, func.name\n            )\n            continue\n        compute_providers[func.name] = compute\n        node_id = _find_node_id(graph, NodeType.LAMBDA_FUNCTION, func.name)\n        if node_id:\n            providers[node_id] = compute\n    return compute_providers, providers\n\n\ndef _create_api_providers(\n    app_model: AppModel,\n    graph: AppGraph,\n    compute_providers: dict[str, ICompute],\n    port: int,\n) -> tuple[ApiGatewayProvider | None, dict[str, Provider]]:\n    \"\"\"Create API Gateway providers from the app model.\"\"\"\n    providers: dict[str, Provider] = {}\n    api_provider: ApiGatewayProvider | None = None\n    for api_def in app_model.apis:\n        route_configs = [\n            RouteConfig(method=r.method, path=r.path, handler_name=r.handler_name)\n            for r in api_def.routes\n            if r.handler_name and r.handler_name in compute_providers\n        ]\n        if route_configs:\n            api_provider = ApiGatewayProvider(\n                routes=route_configs, compute_providers=compute_providers, port=port\n            )\n            node_id = _find_node_id(graph, NodeType.API_GATEWAY, api_def.name)\n            if node_id:\n                providers[node_id] = api_provider\n    return api_provider, providers\n\n\ndef _create_sqs_providers(\n    app_model: AppModel,\n    graph: AppGraph,\n) -> tuple[SqsProvider, dict[str, Provider]]:\n    \"\"\"Create SQS queue providers from the app model.\n\n    Always returns a provider (even with no CDK queues) so the SQS\n    HTTP endpoint is available for Terraform/CLI queue creation.\n    \"\"\"\n    providers: dict[str, Provider] = {}\n    queue_configs = []\n    for q in app_model.queues:\n        redrive = None\n        if q.redrive_target:\n            redrive = RedrivePolicy(\n                dead_letter_queue_name=q.redrive_target, max_receive_count=q.max_receive_count\n            )\n        queue_configs.append(\n            QueueConfig(\n                queue_name=q.name,\n                visibility_timeout=q.visibility_timeout,\n                is_fifo=q.is_fifo,\n                content_based_dedup=q.content_based_dedup,\n                redrive_policy=redrive,\n            )\n        )\n    sqs_provider = SqsProvider(queues=queue_configs if queue_configs else None)\n    for q in app_model.queues:\n        node_id = _find_node_id(graph, NodeType.SQS_QUEUE, q.name)\n        if node_id:\n            providers[node_id] = sqs_provider\n    return sqs_provider, providers\n\n\ndef _create_s3_providers(\n    app_model: AppModel,\n    graph: AppGraph,\n    data_dir: Path,\n) -> tuple[S3Provider, dict[str, Provider]]:\n    \"\"\"Create S3 bucket providers from the app model.\n\n    Always returns a provider (even with no CDK buckets) so the S3\n    HTTP endpoint is available for Terraform/CLI bucket creation.\n    \"\"\"\n    providers: dict[str, Provider] = {}\n    bucket_names = [b.name for b in app_model.buckets]\n    s3_provider = S3Provider(data_dir=data_dir, buckets=bucket_names if bucket_names else None)\n    for b in app_model.buckets:\n        node_id = _find_node_id(graph, NodeType.S3_BUCKET, b.name)\n        if node_id:\n            providers[node_id] = s3_provider\n    return s3_provider, providers\n\n\ndef _create_sns_providers(\n    app_model: AppModel,\n    graph: AppGraph,\n) -> tuple[SnsProvider, dict[str, Provider]]:\n    \"\"\"Create SNS topic providers from the app model.\n\n    Always returns a provider (even with no CDK topics) so the SNS\n    HTTP endpoint is available for Terraform/CLI topic creation.\n    \"\"\"\n    providers: dict[str, Provider] = {}\n    topic_configs = [\n        TopicConfig(topic_name=t.name, topic_arn=t.topic_arn) for t in app_model.topics\n    ]\n    sns_provider = SnsProvider(topics=topic_configs if topic_configs else None)\n    for t in app_model.topics:\n        node_id = _find_node_id(graph, NodeType.SNS_TOPIC, t.name)\n        if node_id:\n            providers[node_id] = sns_provider\n    return sns_provider, providers\n\n\ndef _create_eventbridge_providers(\n    app_model: AppModel,\n    graph: AppGraph,\n) -> tuple[EventBridgeProvider, dict[str, Provider]]:\n    \"\"\"Create EventBridge providers from the app model.\n\n    Always returns a provider (even with no CDK buses) so the EventBridge\n    HTTP endpoint is available for Terraform/CLI event bus creation.\n    \"\"\"\n    providers: dict[str, Provider] = {}\n    bus_configs = [\n        EventBusConfig(bus_name=b.name, bus_arn=b.bus_arn) for b in app_model.event_buses\n    ]\n    rule_configs = []\n    for r in app_model.event_rules:\n        targets = [\n            RuleTarget(target_id=t[\"target_id\"], arn=t[\"arn\"], input_path=t.get(\"input_path\"))\n            for t in r.targets\n        ]\n        rule_configs.append(\n            RuleConfig(\n                rule_name=r.rule_name,\n                event_bus_name=r.event_bus_name,\n                event_pattern=r.event_pattern,\n                schedule_expression=r.schedule_expression,\n                targets=targets,\n            )\n        )\n    eb_provider = EventBridgeProvider(\n        buses=bus_configs if bus_configs else None,\n        rules=rule_configs if rule_configs else None,\n    )\n    for b in app_model.event_buses:\n        node_id = _find_node_id(graph, NodeType.EVENT_BUS, b.name)\n        if node_id:\n            providers[node_id] = eb_provider\n    return eb_provider, providers\n\n\ndef _create_stepfunctions_providers(\n    app_model: AppModel,\n    graph: AppGraph,\n) -> tuple[StepFunctionsProvider, dict[str, Provider]]:\n    \"\"\"Create Step Functions providers from the app model.\n\n    Always returns a provider (even with no CDK state machines) so the\n    Step Functions HTTP endpoint is available for Terraform/CLI creation.\n    \"\"\"\n    providers: dict[str, Provider] = {}\n    sm_configs = []\n    for sm in app_model.state_machines:\n        wf_type = WorkflowType.EXPRESS if sm.workflow_type == \"EXPRESS\" else WorkflowType.STANDARD\n        sm_configs.append(\n            StateMachineConfig(\n                name=sm.name,\n                definition=sm.definition,\n                workflow_type=wf_type,\n                role_arn=sm.role_arn,\n                definition_substitutions=sm.definition_substitutions,\n            )\n        )\n    sf_provider = StepFunctionsProvider(\n        state_machines=sm_configs if sm_configs else None,\n    )\n    for sm in app_model.state_machines:\n        node_id = _find_node_id(graph, NodeType.STATE_MACHINE, sm.name)\n        if node_id:\n            providers[node_id] = sf_provider\n    return sf_provider, providers\n\n\ndef _create_ecs_providers(\n    app_model: AppModel,\n    graph: AppGraph,\n) -> tuple[EcsProvider, dict[str, Provider]]:\n    \"\"\"Create ECS service providers from the app model.\n\n    Always returns a provider (even with no CDK services).\n    \"\"\"\n    providers: dict[str, Provider] = {}\n    ecs_provider = EcsProvider(\n        services=app_model.ecs_services if app_model.ecs_services else None,\n    )\n    for svc in app_model.ecs_services:\n        svc_name = getattr(svc, \"service_name\", str(id(svc)))\n        node_id = _find_node_id(graph, NodeType.ECS_SERVICE, svc_name)\n        if node_id:\n            providers[node_id] = ecs_provider\n    return ecs_provider, providers\n\n\ndef _create_cognito_providers(\n    app_model: AppModel,\n    data_dir: Path,\n    compute_providers: dict[str, ICompute],\n) -> tuple[CognitoProvider, dict[str, Provider]]:\n    \"\"\"Create Cognito user pool providers from the app model.\n\n    Always returns a provider (even with no CDK user pools) so the\n    Cognito HTTP endpoint is available for Terraform/CLI user pool creation.\n    \"\"\"\n    providers: dict[str, Provider] = {}\n    if not app_model.user_pools:\n        pool_config = UserPoolConfig(\n            user_pool_id=\"us-east-1_default\",\n            user_pool_name=\"default\",\n        )\n        cognito_provider = CognitoProvider(data_dir=data_dir, config=pool_config)\n        return cognito_provider, providers\n    # Use the first user pool (multi-pool support can be added later)\n    pool = app_model.user_pools[0]\n    pw = pool.password_policy\n    password_policy = PasswordPolicy(\n        minimum_length=int(pw.get(\"MinimumLength\", 8)),\n        require_lowercase=bool(pw.get(\"RequireLowercase\", True)),\n        require_uppercase=bool(pw.get(\"RequireUppercase\", True)),\n        require_digits=bool(pw.get(\"RequireNumbers\", pw.get(\"RequireDigits\", True))),\n        require_symbols=bool(pw.get(\"RequireSymbols\", False)),\n    )\n    pool_config = UserPoolConfig(\n        user_pool_id=f\"us-east-1_{pool.logical_id}\",\n        user_pool_name=pool.user_pool_name,\n        password_policy=password_policy,\n        auto_confirm=pool.auto_confirm,\n        client_id=pool.client_id or \"local-client-id\",\n        pre_authentication_trigger=pool.pre_auth_trigger,\n        post_confirmation_trigger=pool.post_confirm_trigger,\n    )\n    trigger_funcs = {}\n    if pool.pre_auth_trigger and pool.pre_auth_trigger in compute_providers:\n        trigger_funcs[\"PreAuthentication\"] = compute_providers[pool.pre_auth_trigger]\n    if pool.post_confirm_trigger and pool.post_confirm_trigger in compute_providers:\n        trigger_funcs[\"PostConfirmation\"] = compute_providers[pool.post_confirm_trigger]\n    cognito_provider = CognitoProvider(\n        data_dir=data_dir, config=pool_config, trigger_functions=trigger_funcs or None\n    )\n    providers[f\"__cognito_{pool.logical_id}__\"] = cognito_provider\n    return cognito_provider, providers\n\n\ndef _wire_remaining_providers(\n    app_model: AppModel,\n    graph: AppGraph,\n    providers: dict[str, Provider],\n    compute_providers: dict[str, ICompute],\n    sqs_provider: SqsProvider,\n    local_endpoints: dict[str, str],\n    data_dir: Path,\n    api_port: int,\n    *,\n    sns_port: int,\n    eb_port: int,\n    sf_port: int,\n    cognito_port: int,\n) -> tuple[\n    SnsProvider,\n    EventBridgeProvider,\n    StepFunctionsProvider,\n    CognitoProvider,\n]:\n    \"\"\"Wire messaging, cognito, and API Gateway providers.\"\"\"\n    sns_provider, sns_providers = _create_sns_providers(app_model, graph)\n    providers.update(sns_providers)\n    sns_provider.set_compute_providers(compute_providers)\n    sns_provider.set_queue_provider(sqs_provider)\n    local_endpoints[\"sns\"] = f\"http://127.0.0.1:{sns_port}\"\n\n    eb_provider, eb_providers = _create_eventbridge_providers(app_model, graph)\n    providers.update(eb_providers)\n    eb_provider.set_compute_providers(compute_providers)\n    local_endpoints[\"events\"] = f\"http://127.0.0.1:{eb_port}\"\n\n    sf_provider, sf_providers = _create_stepfunctions_providers(app_model, graph)\n    providers.update(sf_providers)\n    sf_provider.set_compute_providers(compute_providers)\n    local_endpoints[\"stepfunctions\"] = f\"http://127.0.0.1:{sf_port}\"\n\n    cognito_provider, cognito_providers = _create_cognito_providers(\n        app_model, data_dir, compute_providers\n    )\n    providers.update(cognito_providers)\n    local_endpoints[\"cognito-idp\"] = f\"http://127.0.0.1:{cognito_port}\"\n\n    api_provider, api_providers = _create_api_providers(\n        app_model, graph, compute_providers, api_port\n    )\n    providers.update(api_providers)\n\n    return sns_provider, eb_provider, sf_provider, cognito_provider\n\n\ndef _create_providers(\n    app_model: AppModel,\n    graph: AppGraph,\n    config: LdkConfig,\n    data_dir: Path,\n) -> tuple[dict[str, Provider], dict[str, ICompute]]:\n    \"\"\"Instantiate providers from the parsed app model.\n\n    Returns a tuple of (provider map, compute_providers).\n    \"\"\"\n    providers: dict[str, Provider] = {}\n\n    # Port allocation: base+1 DynamoDB, +2 SQS, +3 S3, +4 SNS, +5 EventBridge,\n    # +6 Step Functions, +7 Cognito, +12 SSM, +13 Secrets Manager\n    dynamo_port = config.port + 1\n    sqs_port = config.port + 2\n    s3_port = config.port + 3\n    sns_port = config.port + 4\n    eb_port = config.port + 5\n    sf_port = config.port + 6\n    cognito_port = config.port + 7\n    ssm_port = config.port + 12\n    secretsmanager_port = config.port + 13\n\n    # 1. Storage providers (no deps)\n    dynamo_provider, dynamo_providers = _create_dynamo_providers(app_model, graph, data_dir)\n    providers.update(dynamo_providers)\n\n    sqs_provider, sqs_providers = _create_sqs_providers(app_model, graph)\n    providers.update(sqs_providers)\n\n    s3_provider, s3_providers = _create_s3_providers(app_model, graph, data_dir)\n    providers.update(s3_providers)\n\n    # 2. Build local_endpoints for SDK env redirection\n    local_endpoints: dict[str, str] = {}\n    local_endpoints[\"dynamodb\"] = f\"http://127.0.0.1:{dynamo_port}\"\n    local_endpoints[\"sqs\"] = f\"http://127.0.0.1:{sqs_port}\"\n    local_endpoints[\"s3\"] = f\"http://127.0.0.1:{s3_port}\"\n\n    # 3. Compute (Lambda — Node.js + Python)\n    sdk_env = build_sdk_env(local_endpoints)\n    compute_providers, compute_graph_providers = _create_compute_providers(\n        app_model, graph, local_endpoints, sdk_env\n    )\n    providers.update(compute_graph_providers)\n\n    # 4-6. Messaging, ECS, Cognito, API Gateway\n    sns_provider, eb_provider, sf_provider, cognito_provider = _wire_remaining_providers(\n        app_model,\n        graph,\n        providers,\n        compute_providers,\n        sqs_provider,\n        local_endpoints,\n        data_dir,\n        config.port,\n        sns_port=sns_port,\n        eb_port=eb_port,\n        sf_port=sf_port,\n        cognito_port=cognito_port,\n    )\n    ecs_provider, ecs_providers = _create_ecs_providers(app_model, graph)\n    providers.update(ecs_providers)\n\n    # 7. Add SSM and Secrets Manager endpoints, rebuild SDK env, update compute\n    local_endpoints[\"ssm\"] = f\"http://127.0.0.1:{ssm_port}\"\n    local_endpoints[\"secretsmanager\"] = f\"http://127.0.0.1:{secretsmanager_port}\"\n    sdk_env = build_sdk_env(local_endpoints)\n    for compute in compute_providers.values():\n        if hasattr(compute, \"_sdk_env\"):\n            compute._sdk_env = sdk_env\n\n    # 8. Create HTTP servers for each active service\n    _register_http_providers(\n        providers,\n        dynamo_provider=dynamo_provider,\n        sqs_provider=sqs_provider,\n        s3_provider=s3_provider,\n        sns_provider=sns_provider,\n        eb_provider=eb_provider,\n        sf_provider=sf_provider,\n        cognito_provider=cognito_provider,\n        ports={\n            \"dynamodb\": dynamo_port,\n            \"sqs\": sqs_port,\n            \"s3\": s3_port,\n            \"sns\": sns_port,\n            \"eventbridge\": eb_port,\n            \"stepfunctions\": sf_port,\n            \"cognito\": cognito_port,\n        },\n    )\n\n    # 9. SSM Parameter Store and Secrets Manager (pre-seeded from CloudFormation)\n    from lws.providers.secretsmanager.routes import create_secretsmanager_app\n    from lws.providers.ssm.routes import create_ssm_app\n\n    ssm_params = [\n        {\"name\": p.name, \"type\": p.type, \"value\": p.value, \"description\": p.description}\n        for p in app_model.ssm_parameters\n    ]\n    sm_secrets = [\n        {\"name\": s.name, \"description\": s.description, \"secret_string\": s.secret_string}\n        for s in app_model.secrets\n    ]\n\n    providers[\"__ssm_http__\"] = _HttpServiceProvider(\n        \"ssm-http\", lambda: create_ssm_app(ssm_params), ssm_port\n    )\n    providers[\"__secretsmanager_http__\"] = _HttpServiceProvider(\n        \"secretsmanager-http\", lambda: create_secretsmanager_app(sm_secrets), secretsmanager_port\n    )\n\n    return providers, compute_providers\n\n\ndef _register_http_providers(\n    providers: dict[str, Provider],\n    *,\n    dynamo_provider: SqliteDynamoProvider,\n    sqs_provider: SqsProvider,\n    s3_provider: S3Provider,\n    sns_provider: SnsProvider,\n    eb_provider: EventBridgeProvider,\n    sf_provider: StepFunctionsProvider,\n    cognito_provider: CognitoProvider,\n    ports: dict[str, int],\n) -> None:\n    \"\"\"Register HTTP service providers for each active backend.\"\"\"\n    from lws.providers.cognito.routes import create_cognito_app\n    from lws.providers.eventbridge.routes import create_eventbridge_app\n    from lws.providers.stepfunctions.routes import create_stepfunctions_app\n\n    http_services: list[tuple[str, Any, Callable[[], Any]]] = []\n    http_services.append(\n        (\"dynamodb\", ports[\"dynamodb\"], lambda p=dynamo_provider: create_dynamodb_app(p))\n    )\n    http_services.append(\n        (\"sqs\", ports[\"sqs\"], lambda p=sqs_provider, pt=ports[\"sqs\"]: create_sqs_app(p, pt))\n    )\n    http_services.append((\"s3\", ports[\"s3\"], lambda p=s3_provider: create_s3_app(p)))\n    http_services.append((\"sns\", ports[\"sns\"], lambda p=sns_provider: create_sns_app(p)))\n    http_services.append(\n        (\"eventbridge\", ports[\"eventbridge\"], lambda p=eb_provider: create_eventbridge_app(p))\n    )\n    http_services.append(\n        (\n            \"stepfunctions\",\n            ports[\"stepfunctions\"],\n            lambda p=sf_provider: create_stepfunctions_app(p),\n        )\n    )\n    http_services.append(\n        (\"cognito\", ports[\"cognito\"], lambda p=cognito_provider: create_cognito_app(p))\n    )\n\n    for svc_name, port, factory in http_services:\n        providers[f\"__{svc_name}_http__\"] = _HttpServiceProvider(f\"{svc_name}-http\", factory, port)\n\n\nclass _HttpServiceProvider(Provider):\n    \"\"\"Generic wrapper that runs any FastAPI app as a uvicorn-served Provider.\"\"\"\n\n    def __init__(self, service_name: str, app_factory: Callable[[], Any], port: int) -> None:\n        self._service_name = service_name\n        self._app_factory = app_factory\n        self._port = port\n        self._server: uvicorn.Server | None = None\n        self._task: asyncio.Task | None = None  # type: ignore[type-arg]\n\n    @property\n    def name(self) -> str:\n        return self._service_name\n\n    async def start(self) -> None:\n        http_app = self._app_factory()\n        uvi_config = uvicorn.Config(\n            app=http_app,\n            host=\"0.0.0.0\",\n            port=self._port,\n            log_level=\"warning\",\n        )\n        self._server = uvicorn.Server(uvi_config)\n        self._task = asyncio.create_task(self._server.serve())\n        # Wait for the server to actually bind before reporting as started\n        for _ in range(50):\n            if self._server.started:\n                break\n            await asyncio.sleep(0.1)\n\n    async def stop(self) -> None:\n        if self._server is not None:\n            self._server.should_exit = True\n        if self._task is not None:\n            await self._task\n            self._task = None\n        self._server = None\n\n    async def health_check(self) -> bool:\n        return self._server is not None\n\n\ndef _build_resource_metadata(app_model: AppModel, port: int) -> dict[str, Any]:\n    \"\"\"Build resource metadata for the ``/_ldk/resources`` endpoint.\"\"\"\n    metadata: dict[str, Any] = {\"port\": port, \"services\": {}}\n    services = metadata[\"services\"]\n    ports = _service_ports(port)\n\n    _add_api_metadata(services, app_model, port)\n    _add_service_metadata(services, app_model, ports)\n    return metadata\n\n\ndef _service_ports(port: int) -> dict[str, int]:\n    \"\"\"Return a mapping of service name to port number.\"\"\"\n    return {\n        \"dynamodb\": port + 1,\n        \"sqs\": port + 2,\n        \"s3\": port + 3,\n        \"sns\": port + 4,\n        \"events\": port + 5,\n        \"stepfunctions\": port + 6,\n        \"cognito-idp\": port + 7,\n        \"ssm\": port + 12,\n        \"secretsmanager\": port + 13,\n    }\n\n\ndef _add_api_metadata(services: dict[str, Any], app_model: AppModel, port: int) -> None:\n    \"\"\"Add API Gateway metadata to services.\"\"\"\n    if not app_model.apis:\n        return\n    routes = []\n    for api_def in app_model.apis:\n        for r in api_def.routes:\n            routes.append(\n                {\n                    \"name\": api_def.name,\n                    \"path\": r.path,\n                    \"method\": r.method,\n                    \"handler\": r.handler_name or \"\",\n                }\n            )\n    services[\"apigateway\"] = {\"port\": port, \"resources\": routes}\n\n\ndef _add_service_metadata(\n    services: dict[str, Any], app_model: AppModel, ports: dict[str, int]\n) -> None:\n    \"\"\"Add non-API service metadata to services.\"\"\"\n    if app_model.functions:\n        services[\"lambda\"] = {\n            \"resources\": [\n                {\n                    \"name\": f.name,\n                    \"runtime\": f.runtime,\n                    \"arn\": f\"arn:aws:lambda:us-east-1:000000000000:function:{f.name}\",\n                }\n                for f in app_model.functions\n            ],\n        }\n    if app_model.tables:\n        services[\"dynamodb\"] = {\n            \"port\": ports[\"dynamodb\"],\n            \"resources\": [{\"name\": t.name} for t in app_model.tables],\n        }\n    if app_model.queues:\n        sqs_port = ports[\"sqs\"]\n        services[\"sqs\"] = {\n            \"port\": sqs_port,\n            \"resources\": [\n                {\n                    \"name\": q.name,\n                    \"queue_url\": f\"http://localhost:{sqs_port}/000000000000/{q.name}\",\n                }\n                for q in app_model.queues\n            ],\n        }\n    if app_model.buckets:\n        services[\"s3\"] = {\n            \"port\": ports[\"s3\"],\n            \"resources\": [{\"name\": b.name} for b in app_model.buckets],\n        }\n    if app_model.topics:\n        services[\"sns\"] = {\n            \"port\": ports[\"sns\"],\n            \"resources\": [\n                {\n                    \"name\": t.name,\n                    \"arn\": t.topic_arn or f\"arn:aws:sns:us-east-1:000000000000:{t.name}\",\n                }\n                for t in app_model.topics\n            ],\n        }\n    if app_model.event_buses:\n        services[\"events\"] = {\n            \"port\": ports[\"events\"],\n            \"resources\": [\n                {\n                    \"name\": b.name,\n                    \"arn\": b.bus_arn or f\"arn:aws:events:us-east-1:000000000000:event-bus/{b.name}\",\n                }\n                for b in app_model.event_buses\n            ],\n        }\n    if app_model.state_machines:\n        services[\"stepfunctions\"] = {\n            \"port\": ports[\"stepfunctions\"],\n            \"resources\": [\n                {\n                    \"name\": sm.name,\n                    \"arn\": f\"arn:aws:states:us-east-1:000000000000:stateMachine:{sm.name}\",\n                }\n                for sm in app_model.state_machines\n            ],\n        }\n    if app_model.user_pools:\n        services[\"cognito-idp\"] = {\n            \"port\": ports[\"cognito-idp\"],\n            \"resources\": [\n                {\"name\": p.user_pool_name, \"user_pool_id\": f\"us-east-1_{p.logical_id}\"}\n                for p in app_model.user_pools\n            ],\n        }\n\n\ndef _mount_management_api(\n    providers: dict[str, Provider],\n    orchestrator: Orchestrator,\n    compute_providers: dict[str, ICompute],\n    port: int,\n    resource_metadata: dict[str, Any] | None = None,\n) -> None:\n    \"\"\"Mount the management API router on the API Gateway app or create a standalone one.\"\"\"\n    from fastapi import FastAPI\n\n    from lws.api.management import create_management_router\n\n    mgmt_router = create_management_router(\n        orchestrator, compute_providers, providers, resource_metadata=resource_metadata\n    )\n\n    # Try to find an existing API Gateway provider to mount on\n    for key, prov in providers.items():\n        if isinstance(prov, ApiGatewayProvider):\n            prov.app.include_router(mgmt_router)\n            return\n\n    # No API Gateway — create a standalone FastAPI app for management\n    mgmt_app = FastAPI(title=\"LDK Management\")\n    mgmt_app.include_router(mgmt_router)\n    providers[\"__management_http__\"] = _HttpServiceProvider(\n        \"management-http\", lambda: mgmt_app, port\n    )\n\n\ndef _find_node_id(graph: AppGraph, node_type: NodeType, name: str) -> str | None:\n    \"\"\"Find a graph node ID by type and name.\"\"\"\n    for nid, node in graph.nodes.items():\n        if node.node_type == node_type and nid == name:\n            return nid\n    # Fallback: check config\n    for nid, node in graph.nodes.items():\n        if node.node_type == node_type:\n            if node.config.get(\"table_name\") == name or node.config.get(\"handler\") == name:\n                return nid\n    return name\n\n\ndef _build_key_schema(raw_schema: list[dict[str, str]]) -> KeySchema:\n    \"\"\"Convert raw key schema dicts to a KeySchema dataclass.\"\"\"\n    pk: KeyAttribute | None = None\n    sk: KeyAttribute | None = None\n    for ks in raw_schema:\n        attr = KeyAttribute(name=ks.get(\"attribute_name\", \"pk\"), type=ks.get(\"type\", \"S\"))\n        if ks.get(\"key_type\") == \"RANGE\":\n            sk = attr\n        else:\n            pk = attr\n    if pk is None:\n        pk = KeyAttribute(name=\"pk\", type=\"S\")\n    return KeySchema(partition_key=pk, sort_key=sk)\n\n\ndef _build_gsi(raw_gsi: dict) -> GsiDefinition:\n    \"\"\"Convert a raw GSI dict to a GsiDefinition dataclass.\"\"\"\n    index_name = raw_gsi.get(\"index_name\", raw_gsi.get(\"IndexName\", \"gsi\"))\n    ks_raw = raw_gsi.get(\"key_schema\", [])\n    ks = _build_key_schema(ks_raw)\n    projection = raw_gsi.get(\"projection_type\", \"ALL\")\n    return GsiDefinition(index_name=index_name, key_schema=ks, projection_type=projection)\n","structuredPatch":[{"oldStart":399,"oldLines":6,"newStart":399,"newLines":10,"lines":["         details[f\"User Pool:{p.user_pool_name}\"] = (","             f\"lws cognito-idp sign-up --user-pool-name {p.user_pool_name}\"","         )","+    for p in app_model.ssm_parameters:","+        details[f\"Parameter:{p.name}\"] = f\"lws ssm get-parameter --name {p.name}\"","+    for s in app_model.secrets:","+        details[f\"Secret:{s.name}\"] = f\"lws secretsmanager get-secret-value --secret-id {s.name}\""," "," "," def _display_summary(app_model: AppModel, port: int) -> None:"]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"92a40da6-afde-4bd0-9e9b-b61b5106bb90"}
{"parentUuid":"07948bc9-b1c4-4802-bb46-10efd4f07f54","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","message":{"model":"claude-opus-4-6","id":"msg_0174qhEkYZWeekGMWnxdvSn4","type":"message","role":"assistant","content":[{"type":"text","text":"Now update `_has_any_resources` to include the new fields:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":432,"cache_read_input_tokens":70981,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":432},"output_tokens":2,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CY1FMjmkySMcpqTN5TTAD","type":"assistant","uuid":"74a56ac0-2eb7-4a0a-8b96-f06902d0000e","timestamp":"2026-02-10T23:22:31.562Z"}
{"parentUuid":"74a56ac0-2eb7-4a0a-8b96-f06902d0000e","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","message":{"model":"claude-opus-4-6","id":"msg_0174qhEkYZWeekGMWnxdvSn4","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01YFmJnpF6xmSg7xcMVwgUCS","name":"Edit","input":{"replace_all":false,"file_path":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services/src/lws/cli/ldk.py","old_string":"    return bool(\n        app_model.functions\n        or app_model.tables\n        or app_model.apis\n        or app_model.queues\n        or app_model.buckets\n        or app_model.topics\n        or app_model.event_buses\n        or app_model.state_machines\n        or app_model.ecs_services\n        or app_model.user_pools\n    )","new_string":"    return bool(\n        app_model.functions\n        or app_model.tables\n        or app_model.apis\n        or app_model.queues\n        or app_model.buckets\n        or app_model.topics\n        or app_model.event_buses\n        or app_model.state_machines\n        or app_model.ecs_services\n        or app_model.user_pools\n        or app_model.ssm_parameters\n        or app_model.secrets\n    )"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":432,"cache_read_input_tokens":70981,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":432},"output_tokens":2,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CY1FMjmkySMcpqTN5TTAD","type":"assistant","uuid":"f457d6ed-5306-4fbe-8a0c-898e6048397c","timestamp":"2026-02-10T23:22:34.652Z"}
{"parentUuid":"f457d6ed-5306-4fbe-8a0c-898e6048397c","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"callback"},"parentToolUseID":"toolu_01YFmJnpF6xmSg7xcMVwgUCS","toolUseID":"toolu_01YFmJnpF6xmSg7xcMVwgUCS","timestamp":"2026-02-10T23:22:34.662Z","uuid":"c1d660d3-b0a4-4054-b020-16ab41b97ad1"}
{"parentUuid":"f457d6ed-5306-4fbe-8a0c-898e6048397c","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01YFmJnpF6xmSg7xcMVwgUCS","type":"tool_result","content":"The file /Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services/src/lws/cli/ldk.py has been updated successfully."}]},"uuid":"fad36a06-9630-4620-9019-af4db5273e80","timestamp":"2026-02-10T23:22:34.661Z","toolUseResult":{"filePath":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services/src/lws/cli/ldk.py","oldString":"    return bool(\n        app_model.functions\n        or app_model.tables\n        or app_model.apis\n        or app_model.queues\n        or app_model.buckets\n        or app_model.topics\n        or app_model.event_buses\n        or app_model.state_machines\n        or app_model.ecs_services\n        or app_model.user_pools\n    )","newString":"    return bool(\n        app_model.functions\n        or app_model.tables\n        or app_model.apis\n        or app_model.queues\n        or app_model.buckets\n        or app_model.topics\n        or app_model.event_buses\n        or app_model.state_machines\n        or app_model.ecs_services\n        or app_model.user_pools\n        or app_model.ssm_parameters\n        or app_model.secrets\n    )","originalFile":"\"\"\"LDK CLI entry point.\n\nProvides the ``ldk dev``, ``ldk invoke``, and ``ldk reset`` commands.\n``ldk dev`` parses a CDK cloud assembly, builds the application graph,\nstarts local providers, and watches for file changes.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport asyncio\nimport json\nimport logging\nimport shutil\nfrom collections.abc import Callable\nfrom pathlib import Path\nfrom typing import Any\n\nimport typer\nimport uvicorn\nfrom rich.console import Console\nfrom rich.syntax import Syntax\n\nfrom lws.cli.display import (\n    print_banner,\n    print_error,\n    print_resource_summary,\n    print_startup_complete,\n)\nfrom lws.config.loader import ConfigError, LdkConfig, load_config\nfrom lws.graph.builder import AppGraph, NodeType, build_graph\nfrom lws.interfaces import (\n    ComputeConfig,\n    GsiDefinition,\n    ICompute,\n    KeyAttribute,\n    KeySchema,\n    Provider,\n    TableConfig,\n)\nfrom lws.parser.assembly import AppModel, parse_assembly\nfrom lws.providers.apigateway.provider import ApiGatewayProvider, RouteConfig\nfrom lws.providers.cognito.provider import CognitoProvider\nfrom lws.providers.cognito.user_store import PasswordPolicy, UserPoolConfig\nfrom lws.providers.dynamodb.provider import SqliteDynamoProvider\nfrom lws.providers.dynamodb.routes import create_dynamodb_app\nfrom lws.providers.ecs.provider import EcsProvider\nfrom lws.providers.eventbridge.provider import (\n    EventBridgeProvider,\n    EventBusConfig,\n    RuleConfig,\n    RuleTarget,\n)\nfrom lws.providers.lambda_runtime.nodejs import NodeJsCompute\nfrom lws.providers.lambda_runtime.python import PythonCompute\nfrom lws.providers.s3.provider import S3Provider\nfrom lws.providers.s3.routes import create_s3_app\nfrom lws.providers.sns.provider import SnsProvider, TopicConfig\nfrom lws.providers.sns.routes import create_sns_app\nfrom lws.providers.sqs.provider import QueueConfig, RedrivePolicy, SqsProvider\nfrom lws.providers.sqs.routes import create_sqs_app\nfrom lws.providers.stepfunctions.provider import (\n    StateMachineConfig,\n    StepFunctionsProvider,\n    WorkflowType,\n)\nfrom lws.runtime.env_builder import build_lambda_env\nfrom lws.runtime.orchestrator import Orchestrator\nfrom lws.runtime.sdk_env import build_sdk_env\nfrom lws.runtime.synth import SynthError, ensure_synth\nfrom lws.runtime.watcher import FileWatcher\n\n_console = Console()\n\napp = typer.Typer(name=\"ldk\", help=\"Local Development Kit - Run AWS CDK applications locally\")\n\n__version__ = \"0.4.0\"\n\n\n@app.callback()\ndef main() -> None:\n    \"\"\"LDK - Local Development Kit.\"\"\"\n\n\n@app.command()\ndef dev(\n    port: int = typer.Option(None, \"--port\", \"-p\", help=\"API Gateway listen port\"),\n    no_persist: bool = typer.Option(False, \"--no-persist\", help=\"Disable data persistence\"),\n    force_synth: bool = typer.Option(False, \"--force-synth\", help=\"Force CDK synth\"),\n    log_level: str = typer.Option(\n        None, \"--log-level\", \"-l\", help=\"Log level (debug/info/warning/error)\"\n    ),\n    project_dir: Path = typer.Option(\".\", \"--project-dir\", \"-d\", help=\"Project root directory\"),\n    mode: str = typer.Option(None, \"--mode\", \"-m\", help=\"Project mode (cdk or terraform)\"),\n) -> None:\n    \"\"\"Start the local development environment.\"\"\"\n    try:\n        asyncio.run(_run_dev(project_dir, port, no_persist, force_synth, log_level, mode))\n    except KeyboardInterrupt:\n        pass\n\n\n@app.command()\ndef invoke(\n    function_name: str = typer.Option(..., \"--function-name\", \"-f\", help=\"Lambda function name\"),\n    event: str = typer.Option(None, \"--event\", \"-e\", help=\"Inline JSON event payload\"),\n    event_file: Path = typer.Option(None, \"--event-file\", help=\"Path to JSON event file\"),\n    project_dir: Path = typer.Option(\".\", \"--project-dir\", \"-d\", help=\"Project root directory\"),\n    port: int = typer.Option(None, \"--port\", \"-p\", help=\"Management API port\"),\n) -> None:\n    \"\"\"Invoke a Lambda function directly.\"\"\"\n    asyncio.run(_run_invoke(function_name, event, event_file, project_dir, port))\n\n\nasync def _run_invoke(\n    function_name: str,\n    event_json: str | None,\n    event_file: Path | None,\n    project_dir: Path,\n    port_override: int | None,\n) -> None:\n    \"\"\"Async implementation of the ``ldk invoke`` command.\"\"\"\n    # Resolve event payload\n    event_payload = _resolve_event_payload(event_json, event_file)\n\n    # Try connecting to running ldk dev via management API\n    project_dir = project_dir.resolve()\n    config = _load_config_quiet(project_dir)\n    mgmt_port = port_override or config.port\n\n    if await _try_management_invoke(mgmt_port, function_name, event_payload):\n        return\n\n    # Fallback: one-shot invocation\n    _console.print(\"[dim]No running ldk dev found, performing one-shot invocation...[/dim]\")\n    await _oneshot_invoke(project_dir, config, function_name, event_payload)\n\n\ndef _resolve_event_payload(event_json: str | None, event_file: Path | None) -> dict:\n    \"\"\"Parse event payload from CLI args.\"\"\"\n    if event_json is not None:\n        try:\n            return json.loads(event_json)\n        except json.JSONDecodeError as exc:\n            print_error(\"Invalid JSON in --event\", str(exc))\n            raise typer.Exit(1)\n\n    if event_file is not None:\n        if not event_file.exists():\n            print_error(\"Event file not found\", str(event_file))\n            raise typer.Exit(1)\n        try:\n            return json.loads(event_file.read_text())\n        except json.JSONDecodeError as exc:\n            print_error(\"Invalid JSON in event file\", str(exc))\n            raise typer.Exit(1)\n\n    return {}\n\n\nasync def _try_management_invoke(port: int, function_name: str, event: dict) -> bool:\n    \"\"\"Try to invoke via the management API. Return True if successful.\"\"\"\n    try:\n        import httpx\n\n        async with httpx.AsyncClient() as client:\n            resp = await client.post(\n                f\"http://localhost:{port}/_ldk/invoke\",\n                json={\"function_name\": function_name, \"event\": event},\n                timeout=30.0,\n            )\n            result = resp.json()\n            formatted = json.dumps(result, indent=2)\n            syntax = Syntax(formatted, \"json\", theme=\"monokai\")\n            _console.print(syntax)\n            return True\n    except Exception:\n        return False\n\n\nasync def _oneshot_invoke(\n    project_dir: Path, config: LdkConfig, function_name: str, event: dict\n) -> None:\n    \"\"\"Perform a one-shot Lambda invocation without a running server.\"\"\"\n    try:\n        import uuid as _uuid\n\n        from lws.interfaces import InvocationResult, LambdaContext\n\n        cdk_out = project_dir / config.cdk_out_dir\n        if not cdk_out.exists():\n            print_error(\"CDK output not found\", f\"Run 'cdk synth' first in {project_dir}\")\n            raise typer.Exit(1)\n\n        app_model = parse_assembly(cdk_out)\n        func_def = next((f for f in app_model.functions if f.name == function_name), None)\n        if func_def is None:\n            print_error(\"Function not found\", f\"No function named '{function_name}'\")\n            raise typer.Exit(1)\n\n        sdk_env = build_sdk_env({})\n        func_env = build_lambda_env(\n            function_name=func_def.name,\n            function_env=func_def.environment,\n            local_endpoints={},\n            resolved_refs={},\n        )\n        compute_config = ComputeConfig(\n            function_name=func_def.name,\n            handler=func_def.handler,\n            runtime=func_def.runtime,\n            code_path=func_def.code_path or Path(\".\"),\n            timeout=func_def.timeout,\n            memory_size=func_def.memory,\n            environment=func_env,\n        )\n        compute = NodeJsCompute(config=compute_config, sdk_env=sdk_env)\n        await compute.start()\n\n        request_id = str(_uuid.uuid4())\n        context = LambdaContext(\n            function_name=function_name,\n            memory_limit_in_mb=compute_config.memory_size,\n            timeout_seconds=compute_config.timeout,\n            aws_request_id=request_id,\n            invoked_function_arn=(\n                f\"arn:aws:lambda:us-east-1:000000000000:function:{function_name}\"\n            ),\n        )\n\n        result: InvocationResult = await compute.invoke(event, context)\n        await compute.stop()\n\n        output = result.payload if result.error is None else {\"error\": result.error}\n        formatted = json.dumps(output, indent=2, default=str)\n        syntax = Syntax(formatted, \"json\", theme=\"monokai\")\n        _console.print(syntax)\n\n    except typer.Exit:\n        raise\n    except Exception as exc:\n        print_error(\"Invocation failed\", str(exc))\n        raise typer.Exit(1)\n\n\n@app.command()\ndef reset(\n    yes: bool = typer.Option(False, \"--yes\", \"-y\", help=\"Skip confirmation prompt\"),\n    project_dir: Path = typer.Option(\".\", \"--project-dir\", \"-d\", help=\"Project root directory\"),\n    port: int = typer.Option(None, \"--port\", \"-p\", help=\"Management API port\"),\n) -> None:\n    \"\"\"Reset all LDK local state (databases, queues, etc.).\"\"\"\n    project_dir = project_dir.resolve()\n    config = _load_config_quiet(project_dir)\n    data_dir = project_dir / config.data_dir\n\n    if not data_dir.exists():\n        _console.print(\"[dim]No data directory found. Nothing to reset.[/dim]\")\n        return\n\n    # List contents to be deleted\n    items = list(data_dir.iterdir())\n    if not items:\n        _console.print(\"[dim]Data directory is empty. Nothing to reset.[/dim]\")\n        return\n\n    _console.print(f\"[bold]Will delete all files under:[/bold] {data_dir}\")\n    for item in items:\n        kind = \"dir\" if item.is_dir() else \"file\"\n        _console.print(f\"  [dim]{kind}:[/dim] {item.name}\")\n\n    if not yes:\n        confirm = typer.confirm(\"Are you sure you want to delete all local state?\")\n        if not confirm:\n            _console.print(\"[dim]Aborted.[/dim]\")\n            return\n\n    # Delete contents\n    deleted_count = 0\n    for item in items:\n        if item.is_dir():\n            shutil.rmtree(item)\n        else:\n            item.unlink()\n        deleted_count += 1\n\n    _console.print(f\"[green]Deleted {deleted_count} item(s) from {data_dir}[/green]\")\n\n    # Notify running ldk dev if possible\n    mgmt_port = port or config.port\n    asyncio.run(_try_management_reset(mgmt_port))\n\n\nasync def _try_management_reset(port: int) -> None:\n    \"\"\"Try to notify running ldk dev of the reset via management API.\"\"\"\n    try:\n        import httpx\n\n        async with httpx.AsyncClient() as client:\n            resp = await client.post(\n                f\"http://localhost:{port}/_ldk/reset\",\n                timeout=5.0,\n            )\n            if resp.status_code == 200:\n                _console.print(\"[dim]Notified running ldk dev of reset.[/dim]\")\n    except Exception:\n        pass  # Server not running, that's fine\n\n\ndef _load_config_quiet(project_dir: Path) -> LdkConfig:\n    \"\"\"Load config without printing errors. Falls back to defaults.\"\"\"\n    try:\n        return load_config(project_dir)\n    except ConfigError:\n        return LdkConfig()\n\n\ndef _load_and_apply_config(\n    project_dir: Path,\n    port_override: int | None,\n    no_persist: bool,\n    log_level_override: str | None,\n) -> LdkConfig:\n    \"\"\"Load config and apply CLI overrides.\"\"\"\n    try:\n        config = load_config(project_dir)\n    except ConfigError as exc:\n        print_error(\"Configuration error\", str(exc))\n        raise typer.Exit(1)\n\n    if port_override is not None:\n        config.port = port_override\n    if log_level_override is not None:\n        config.log_level = log_level_override\n    if no_persist:\n        config.persist = False\n\n    logging.basicConfig(\n        level=getattr(logging, config.log_level.upper(), logging.INFO),\n        format=\"%(levelname)s %(name)s: %(message)s\",\n    )\n    return config\n\n\ndef _collect_extra_resources(app_model: AppModel) -> dict[str, list[str]]:\n    \"\"\"Collect extra resource name lists from the app model for display.\"\"\"\n    extras: dict[str, list[str]] = {}\n    _RESOURCE_ATTRS = {\n        \"queues\": (\"name\", \"queues\"),\n        \"buckets\": (\"name\", \"buckets\"),\n        \"topics\": (\"name\", \"topics\"),\n        \"state_machines\": (\"name\", \"state_machines\"),\n        \"ecs_services\": (\"service_name\", \"ecs_services\"),\n        \"user_pools\": (\"user_pool_name\", \"user_pools\"),\n        \"ssm_parameters\": (\"name\", \"ssm_parameters\"),\n        \"secrets\": (\"name\", \"secrets\"),\n    }\n    for key, (attr, model_attr) in _RESOURCE_ATTRS.items():\n        items = getattr(app_model, model_attr, [])\n        if items:\n            extras[key] = [getattr(item, attr, str(item)) for item in items]\n    return extras\n\n\ndef _build_local_details(app_model: AppModel, port: int) -> dict[str, str]:\n    \"\"\"Build a mapping of ``\"Type:Name\"`` to local detail strings.\"\"\"\n    details: dict[str, str] = {}\n\n    _add_api_details(details, app_model)\n    _add_resource_details(details, app_model)\n    return details\n\n\ndef _add_api_details(details: dict[str, str], app_model: AppModel) -> None:\n    \"\"\"Add API route and Lambda function details.\"\"\"\n    for api_def in app_model.apis:\n        for r in api_def.routes:\n            details[f\"API Route:{r.path}\"] = (\n                f\"lws apigateway test-invoke-method --resource {r.path} --http-method {r.method}\"\n            )\n    for f in app_model.functions:\n        details[f\"Function:{f.name}\"] = f\"ldk invoke {f.name}\"\n\n\ndef _add_resource_details(details: dict[str, str], app_model: AppModel) -> None:\n    \"\"\"Add service resource details (DynamoDB, SQS, S3, etc.).\"\"\"\n    for t in app_model.tables:\n        details[f\"Table:{t.name}\"] = f\"lws dynamodb scan --table-name {t.name}\"\n    for q in app_model.queues:\n        details[f\"Queue:{q.name}\"] = f\"lws sqs receive-message --queue-name {q.name}\"\n    for b in app_model.buckets:\n        details[f\"Bucket:{b.name}\"] = f\"lws s3api list-objects-v2 --bucket {b.name}\"\n    for t in app_model.topics:\n        details[f\"Topic:{t.name}\"] = f\"lws sns publish --topic-name {t.name} --message '...'\"\n    for b in app_model.event_buses:\n        details[f\"Event Bus:{b.name}\"] = f\"lws events list-rules --event-bus-name {b.name}\"\n    for sm in app_model.state_machines:\n        details[f\"State Machine:{sm.name}\"] = f\"lws stepfunctions start-execution --name {sm.name}\"\n    for p in app_model.user_pools:\n        details[f\"User Pool:{p.user_pool_name}\"] = (\n            f\"lws cognito-idp sign-up --user-pool-name {p.user_pool_name}\"\n        )\n    for p in app_model.ssm_parameters:\n        details[f\"Parameter:{p.name}\"] = f\"lws ssm get-parameter --name {p.name}\"\n    for s in app_model.secrets:\n        details[f\"Secret:{s.name}\"] = f\"lws secretsmanager get-secret-value --secret-id {s.name}\"\n\n\ndef _display_summary(app_model: AppModel, port: int) -> None:\n    \"\"\"Print resource summary and startup-complete banner.\"\"\"\n    routes_info = [\n        {\"method\": r.method, \"path\": r.path, \"handler\": r.handler_name or \"\"}\n        for api_def in app_model.apis\n        for r in api_def.routes\n    ]\n    tables_info = [t.name for t in app_model.tables]\n    functions_info = [f\"{f.name} ({f.runtime})\" for f in app_model.functions]\n\n    extra_resources = _collect_extra_resources(app_model)\n    local_details = _build_local_details(app_model, port)\n    print_resource_summary(\n        routes_info, tables_info, functions_info, local_details=local_details, **extra_resources\n    )\n\n    extra_counts = {f\"num_{k}\": len(v) for k, v in extra_resources.items()}\n    print_startup_complete(\n        port,\n        num_routes=len(routes_info),\n        num_tables=len(tables_info),\n        num_functions=len(functions_info),\n        **extra_counts,\n    )\n\n\ndef _resolve_mode(project_dir: Path, config: LdkConfig, mode_override: str | None) -> str:\n    \"\"\"Resolve the project mode from CLI flag, config, or auto-detection.\n\n    Returns ``\"cdk\"`` or ``\"terraform\"``.\n    Raises ``typer.Exit(1)`` on error.\n    \"\"\"\n    from lws.terraform.detect import detect_project_type\n\n    mode = mode_override or config.mode\n    if mode:\n        if mode not in (\"cdk\", \"terraform\"):\n            print_error(\"Invalid mode\", f\"Must be 'cdk' or 'terraform', got '{mode}'\")\n            raise typer.Exit(1)\n        return mode\n\n    detected = detect_project_type(project_dir)\n    if detected == \"ambiguous\":\n        print_error(\n            \"Ambiguous project\",\n            \"Both .tf files and cdk.out found. Use --mode cdk or --mode terraform.\",\n        )\n        raise typer.Exit(1)\n    if detected == \"none\":\n        print_error(\n            \"No project found\",\n            \"No .tf files or cdk.out directory found. \"\n            \"Run from a CDK or Terraform project directory.\",\n        )\n        raise typer.Exit(1)\n    return detected\n\n\nasync def _run_dev_terraform(project_dir: Path, config: LdkConfig) -> None:\n    \"\"\"Run the dev server in Terraform mode.\n\n    Starts all service providers in always-on mode, generates the\n    Terraform provider override file, and waits for shutdown.\n    \"\"\"\n    from lws.terraform.gitignore import ensure_gitignore\n    from lws.terraform.override import cleanup_override, generate_override\n\n    port = config.port\n    data_dir = project_dir / config.data_dir\n    data_dir.mkdir(parents=True, exist_ok=True)\n\n    # Generate override file\n    try:\n        override_path = generate_override(port, project_dir)\n    except FileExistsError as exc:\n        print_error(\"Override file conflict\", str(exc))\n        raise typer.Exit(1)\n\n    ensure_gitignore(project_dir)\n\n    # Create all providers in always-on mode (no app model)\n    providers, ports = _create_terraform_providers(config, data_dir, project_dir)\n\n    orchestrator = Orchestrator()\n\n    # Enable WebSocket log streaming\n    from lws.logging.logger import WebSocketLogHandler, set_ws_handler\n\n    ws_log_handler = WebSocketLogHandler()\n    set_ws_handler(ws_log_handler)\n\n    # Build resource metadata so the CLI client can discover services\n    resource_metadata: dict[str, Any] = {\n        \"port\": port,\n        \"services\": {\n            svc_name: {\"port\": svc_port, \"resources\": []} for svc_name, svc_port in ports.items()\n        },\n    }\n\n    # Mount management API (no compute providers in terraform mode)\n    _mount_management_api(providers, orchestrator, {}, port, resource_metadata)\n\n    for key in providers:\n        pass  # All keys are already in the dict\n\n    startup_order = list(providers.keys())\n\n    try:\n        await orchestrator.start(providers, startup_order)\n    except Exception as exc:\n        cleanup_override(project_dir)\n        print_error(\"Failed to start providers\", str(exc))\n        raise typer.Exit(1)\n\n    # Display summary\n    _console.print()\n    _console.print(\"[bold green]Terraform mode active[/bold green]\")\n    _console.print(f\"  Override file: {override_path}\")\n    _console.print()\n    _console.print(\"[bold]Service endpoints:[/bold]\")\n    for svc_name, svc_port in sorted(ports.items()):\n        _console.print(f\"  {svc_name:20s} http://localhost:{svc_port}\")\n    _console.print()\n    _console.print(\"[dim]Run 'terraform init && terraform apply' to create resources.[/dim]\")\n    _console.print(f\"  Dashboard: http://localhost:{config.port}/_ldk/gui\")\n    _console.print()\n\n    try:\n        await orchestrator.wait_for_shutdown()\n    finally:\n        cleanup_override(project_dir)\n        set_ws_handler(None)\n        await orchestrator.stop()\n        typer.echo(\"Goodbye\")\n\n\ndef _create_terraform_providers(\n    config: LdkConfig,\n    data_dir: Path,\n    project_dir: Path | None = None,\n) -> tuple[dict[str, Provider], dict[str, int]]:\n    \"\"\"Create all service providers for Terraform mode (no app model).\"\"\"\n    providers: dict[str, Provider] = {}\n\n    port = config.port\n    ports = {\n        \"dynamodb\": port + 1,\n        \"sqs\": port + 2,\n        \"s3\": port + 3,\n        \"sns\": port + 4,\n        \"eventbridge\": port + 5,\n        \"stepfunctions\": port + 6,\n        \"cognito\": port + 7,\n        \"apigateway\": port + 8,\n        \"lambda\": port + 9,\n        \"iam\": port + 10,\n        \"sts\": port + 11,\n        \"ssm\": port + 12,\n        \"secretsmanager\": port + 13,\n    }\n\n    dynamo_provider = SqliteDynamoProvider(data_dir=data_dir, tables=[])\n    sqs_provider = SqsProvider()\n    s3_provider = S3Provider(data_dir=data_dir)\n    sns_provider = SnsProvider()\n    eb_provider = EventBridgeProvider()\n    sf_provider = StepFunctionsProvider()\n\n    pool_config = UserPoolConfig(\n        user_pool_id=\"us-east-1_default\",\n        user_pool_name=\"default\",\n    )\n    cognito_provider = CognitoProvider(data_dir=data_dir, config=pool_config)\n\n    _register_http_providers(\n        providers,\n        dynamo_provider=dynamo_provider,\n        sqs_provider=sqs_provider,\n        s3_provider=s3_provider,\n        sns_provider=sns_provider,\n        eb_provider=eb_provider,\n        sf_provider=sf_provider,\n        cognito_provider=cognito_provider,\n        ports=ports,\n    )\n\n    # Shared Lambda registry for Lambda management and API Gateway V2 proxy\n    from lws.providers.lambda_runtime.routes import LambdaRegistry, create_lambda_management_app\n\n    lambda_registry = LambdaRegistry()\n\n    # Wire Lambda registry compute providers into Step Functions so SFN can\n    # invoke Lambda functions that Terraform creates dynamically.\n    sf_provider.set_compute_providers(lambda_registry._compute)\n\n    # Build SDK env so Lambda functions can reach local services\n    local_endpoints: dict[str, str] = {\n        \"dynamodb\": f\"http://127.0.0.1:{ports['dynamodb']}\",\n        \"sqs\": f\"http://127.0.0.1:{ports['sqs']}\",\n        \"s3\": f\"http://127.0.0.1:{ports['s3']}\",\n        \"sns\": f\"http://127.0.0.1:{ports['sns']}\",\n        \"events\": f\"http://127.0.0.1:{ports['eventbridge']}\",\n        \"stepfunctions\": f\"http://127.0.0.1:{ports['stepfunctions']}\",\n        \"cognito-idp\": f\"http://127.0.0.1:{ports['cognito']}\",\n        \"ssm\": f\"http://127.0.0.1:{ports['ssm']}\",\n        \"secretsmanager\": f\"http://127.0.0.1:{ports['secretsmanager']}\",\n    }\n    sdk_env = build_sdk_env(local_endpoints)\n\n    # Lambda management API\n    providers[\"__lambda_http__\"] = _HttpServiceProvider(\n        \"lambda-http\",\n        lambda: create_lambda_management_app(lambda_registry, project_dir, sdk_env),\n        ports[\"lambda\"],\n    )\n\n    # API Gateway management API with V2 support and Lambda proxy\n    from lws.providers.apigateway.routes import create_apigateway_management_app\n\n    providers[\"__apigateway_http__\"] = _HttpServiceProvider(\n        \"apigateway-http\",\n        lambda: create_apigateway_management_app(lambda_registry),\n        ports[\"apigateway\"],\n    )\n\n    # IAM stub\n    from lws.providers.iam.routes import create_iam_app\n\n    providers[\"__iam_http__\"] = _HttpServiceProvider(\"iam-http\", create_iam_app, ports[\"iam\"])\n\n    # STS stub\n    from lws.providers.sts.routes import create_sts_app\n\n    providers[\"__sts_http__\"] = _HttpServiceProvider(\"sts-http\", create_sts_app, ports[\"sts\"])\n\n    # SSM Parameter Store\n    from lws.providers.ssm.routes import create_ssm_app\n\n    providers[\"__ssm_http__\"] = _HttpServiceProvider(\"ssm-http\", create_ssm_app, ports[\"ssm\"])\n\n    # Secrets Manager\n    from lws.providers.secretsmanager.routes import create_secretsmanager_app\n\n    providers[\"__secretsmanager_http__\"] = _HttpServiceProvider(\n        \"secretsmanager-http\", create_secretsmanager_app, ports[\"secretsmanager\"]\n    )\n\n    return providers, ports\n\n\ndef _has_any_resources(app_model: AppModel) -> bool:\n    \"\"\"Return True if the app model contains at least one resource.\"\"\"\n    return bool(\n        app_model.functions\n        or app_model.tables\n        or app_model.apis\n        or app_model.queues\n        or app_model.buckets\n        or app_model.topics\n        or app_model.event_buses\n        or app_model.state_machines\n        or app_model.ecs_services\n        or app_model.user_pools\n    )\n\n\nasync def _run_dev(\n    project_dir: Path,\n    port_override: int | None,\n    no_persist: bool,\n    force_synth: bool,\n    log_level_override: str | None,\n    mode_override: str | None = None,\n) -> None:\n    \"\"\"Async implementation of the ``ldk dev`` command.\"\"\"\n    project_dir = project_dir.resolve()\n    config = _load_and_apply_config(project_dir, port_override, no_persist, log_level_override)\n    print_banner(__version__, project_dir.name)\n\n    # Resolve project mode\n    resolved_mode = _resolve_mode(project_dir, config, mode_override)\n    if resolved_mode == \"terraform\":\n        await _run_dev_terraform(project_dir, config)\n        return\n\n    try:\n        cdk_out = await ensure_synth(project_dir, force=force_synth)\n    except SynthError as exc:\n        print_error(\"CDK synth failed\", str(exc))\n        raise typer.Exit(1)\n\n    app_model = parse_assembly(cdk_out)\n    if not _has_any_resources(app_model):\n        print_error(\"No resources found in cloud assembly\", str(cdk_out))\n        raise typer.Exit(1)\n\n    graph = build_graph(app_model)\n    startup_order = graph.topological_sort()\n\n    data_dir = project_dir / config.data_dir\n    data_dir.mkdir(parents=True, exist_ok=True)\n    providers, compute_providers = _create_providers(app_model, graph, config, data_dir)\n\n    orchestrator = Orchestrator()\n\n    # Enable WebSocket log streaming\n    from lws.logging.logger import WebSocketLogHandler, set_ws_handler\n\n    ws_log_handler = WebSocketLogHandler()\n    set_ws_handler(ws_log_handler)\n\n    # Mount management API\n    resource_metadata = _build_resource_metadata(app_model, config.port)\n    _mount_management_api(\n        providers, orchestrator, compute_providers, config.port, resource_metadata\n    )\n\n    # Append non-graph provider keys (HTTP servers, management) to startup order.\n    # This must happen after _mount_management_api so the fallback management\n    # HTTP server (when no API Gateway exists) is included in the startup order.\n    for key in providers:\n        if key not in startup_order:\n            startup_order.append(key)\n\n    try:\n        await orchestrator.start(providers, startup_order)\n    except Exception as exc:\n        print_error(\"Failed to start providers\", str(exc))\n        raise typer.Exit(1)\n\n    _display_summary(app_model, config.port)\n    typer.echo(f\"  Dashboard: http://localhost:{config.port}/_ldk/gui\")\n\n    watcher = FileWatcher(\n        watch_dir=project_dir,\n        include_patterns=config.watch_include,\n        exclude_patterns=config.watch_exclude,\n    )\n    watcher.on_change(lambda path: logging.getLogger(\"ldk.watcher\").info(\"Changed: %s\", path))\n    watcher.start()\n\n    try:\n        await orchestrator.wait_for_shutdown()\n    finally:\n        watcher.stop()\n        set_ws_handler(None)\n        await orchestrator.stop()\n        typer.echo(\"Goodbye\")\n\n\ndef _create_dynamo_providers(\n    app_model: AppModel,\n    graph: AppGraph,\n    data_dir: Path,\n) -> tuple[SqliteDynamoProvider, dict[str, Provider]]:\n    \"\"\"Create DynamoDB table providers from the app model.\n\n    Always returns a provider (even with no CDK tables) so the DynamoDB\n    HTTP endpoint is available for Terraform/CLI table creation.\n    \"\"\"\n    providers: dict[str, Provider] = {}\n    table_configs: list[TableConfig] = []\n    for table in app_model.tables:\n        ks = _build_key_schema(table.key_schema)\n        gsi_defs = [_build_gsi(g) for g in table.gsi_definitions]\n        table_configs.append(\n            TableConfig(table_name=table.name, key_schema=ks, gsi_definitions=gsi_defs)\n        )\n\n    dynamo_provider = SqliteDynamoProvider(data_dir=data_dir, tables=table_configs)\n    for table in app_model.tables:\n        node_id = _find_node_id(graph, NodeType.DYNAMODB_TABLE, table.name)\n        if node_id:\n            providers[node_id] = dynamo_provider\n    return dynamo_provider, providers\n\n\ndef _create_compute_providers(\n    app_model: AppModel,\n    graph: AppGraph,\n    local_endpoints: dict[str, str],\n    sdk_env: dict[str, str],\n) -> tuple[dict[str, ICompute], dict[str, Provider]]:\n    \"\"\"Create Lambda compute providers from the app model (Node.js + Python).\"\"\"\n    providers: dict[str, Provider] = {}\n    compute_providers: dict[str, ICompute] = {}\n    for func in app_model.functions:\n        func_env = build_lambda_env(\n            function_name=func.name,\n            function_env=func.environment,\n            local_endpoints=local_endpoints,\n            resolved_refs={},\n        )\n        compute_config = ComputeConfig(\n            function_name=func.name,\n            handler=func.handler,\n            runtime=func.runtime,\n            code_path=func.code_path or Path(\".\"),\n            timeout=func.timeout,\n            memory_size=func.memory,\n            environment=func_env,\n        )\n        if func.runtime.startswith(\"python\"):\n            compute: ICompute = PythonCompute(config=compute_config, sdk_env=sdk_env)\n        elif func.runtime.startswith(\"nodejs\"):\n            compute = NodeJsCompute(config=compute_config, sdk_env=sdk_env)\n        else:\n            logging.getLogger(\"ldk.cli\").warning(\n                \"Unsupported runtime %s for %s, skipping\", func.runtime, func.name\n            )\n            continue\n        compute_providers[func.name] = compute\n        node_id = _find_node_id(graph, NodeType.LAMBDA_FUNCTION, func.name)\n        if node_id:\n            providers[node_id] = compute\n    return compute_providers, providers\n\n\ndef _create_api_providers(\n    app_model: AppModel,\n    graph: AppGraph,\n    compute_providers: dict[str, ICompute],\n    port: int,\n) -> tuple[ApiGatewayProvider | None, dict[str, Provider]]:\n    \"\"\"Create API Gateway providers from the app model.\"\"\"\n    providers: dict[str, Provider] = {}\n    api_provider: ApiGatewayProvider | None = None\n    for api_def in app_model.apis:\n        route_configs = [\n            RouteConfig(method=r.method, path=r.path, handler_name=r.handler_name)\n            for r in api_def.routes\n            if r.handler_name and r.handler_name in compute_providers\n        ]\n        if route_configs:\n            api_provider = ApiGatewayProvider(\n                routes=route_configs, compute_providers=compute_providers, port=port\n            )\n            node_id = _find_node_id(graph, NodeType.API_GATEWAY, api_def.name)\n            if node_id:\n                providers[node_id] = api_provider\n    return api_provider, providers\n\n\ndef _create_sqs_providers(\n    app_model: AppModel,\n    graph: AppGraph,\n) -> tuple[SqsProvider, dict[str, Provider]]:\n    \"\"\"Create SQS queue providers from the app model.\n\n    Always returns a provider (even with no CDK queues) so the SQS\n    HTTP endpoint is available for Terraform/CLI queue creation.\n    \"\"\"\n    providers: dict[str, Provider] = {}\n    queue_configs = []\n    for q in app_model.queues:\n        redrive = None\n        if q.redrive_target:\n            redrive = RedrivePolicy(\n                dead_letter_queue_name=q.redrive_target, max_receive_count=q.max_receive_count\n            )\n        queue_configs.append(\n            QueueConfig(\n                queue_name=q.name,\n                visibility_timeout=q.visibility_timeout,\n                is_fifo=q.is_fifo,\n                content_based_dedup=q.content_based_dedup,\n                redrive_policy=redrive,\n            )\n        )\n    sqs_provider = SqsProvider(queues=queue_configs if queue_configs else None)\n    for q in app_model.queues:\n        node_id = _find_node_id(graph, NodeType.SQS_QUEUE, q.name)\n        if node_id:\n            providers[node_id] = sqs_provider\n    return sqs_provider, providers\n\n\ndef _create_s3_providers(\n    app_model: AppModel,\n    graph: AppGraph,\n    data_dir: Path,\n) -> tuple[S3Provider, dict[str, Provider]]:\n    \"\"\"Create S3 bucket providers from the app model.\n\n    Always returns a provider (even with no CDK buckets) so the S3\n    HTTP endpoint is available for Terraform/CLI bucket creation.\n    \"\"\"\n    providers: dict[str, Provider] = {}\n    bucket_names = [b.name for b in app_model.buckets]\n    s3_provider = S3Provider(data_dir=data_dir, buckets=bucket_names if bucket_names else None)\n    for b in app_model.buckets:\n        node_id = _find_node_id(graph, NodeType.S3_BUCKET, b.name)\n        if node_id:\n            providers[node_id] = s3_provider\n    return s3_provider, providers\n\n\ndef _create_sns_providers(\n    app_model: AppModel,\n    graph: AppGraph,\n) -> tuple[SnsProvider, dict[str, Provider]]:\n    \"\"\"Create SNS topic providers from the app model.\n\n    Always returns a provider (even with no CDK topics) so the SNS\n    HTTP endpoint is available for Terraform/CLI topic creation.\n    \"\"\"\n    providers: dict[str, Provider] = {}\n    topic_configs = [\n        TopicConfig(topic_name=t.name, topic_arn=t.topic_arn) for t in app_model.topics\n    ]\n    sns_provider = SnsProvider(topics=topic_configs if topic_configs else None)\n    for t in app_model.topics:\n        node_id = _find_node_id(graph, NodeType.SNS_TOPIC, t.name)\n        if node_id:\n            providers[node_id] = sns_provider\n    return sns_provider, providers\n\n\ndef _create_eventbridge_providers(\n    app_model: AppModel,\n    graph: AppGraph,\n) -> tuple[EventBridgeProvider, dict[str, Provider]]:\n    \"\"\"Create EventBridge providers from the app model.\n\n    Always returns a provider (even with no CDK buses) so the EventBridge\n    HTTP endpoint is available for Terraform/CLI event bus creation.\n    \"\"\"\n    providers: dict[str, Provider] = {}\n    bus_configs = [\n        EventBusConfig(bus_name=b.name, bus_arn=b.bus_arn) for b in app_model.event_buses\n    ]\n    rule_configs = []\n    for r in app_model.event_rules:\n        targets = [\n            RuleTarget(target_id=t[\"target_id\"], arn=t[\"arn\"], input_path=t.get(\"input_path\"))\n            for t in r.targets\n        ]\n        rule_configs.append(\n            RuleConfig(\n                rule_name=r.rule_name,\n                event_bus_name=r.event_bus_name,\n                event_pattern=r.event_pattern,\n                schedule_expression=r.schedule_expression,\n                targets=targets,\n            )\n        )\n    eb_provider = EventBridgeProvider(\n        buses=bus_configs if bus_configs else None,\n        rules=rule_configs if rule_configs else None,\n    )\n    for b in app_model.event_buses:\n        node_id = _find_node_id(graph, NodeType.EVENT_BUS, b.name)\n        if node_id:\n            providers[node_id] = eb_provider\n    return eb_provider, providers\n\n\ndef _create_stepfunctions_providers(\n    app_model: AppModel,\n    graph: AppGraph,\n) -> tuple[StepFunctionsProvider, dict[str, Provider]]:\n    \"\"\"Create Step Functions providers from the app model.\n\n    Always returns a provider (even with no CDK state machines) so the\n    Step Functions HTTP endpoint is available for Terraform/CLI creation.\n    \"\"\"\n    providers: dict[str, Provider] = {}\n    sm_configs = []\n    for sm in app_model.state_machines:\n        wf_type = WorkflowType.EXPRESS if sm.workflow_type == \"EXPRESS\" else WorkflowType.STANDARD\n        sm_configs.append(\n            StateMachineConfig(\n                name=sm.name,\n                definition=sm.definition,\n                workflow_type=wf_type,\n                role_arn=sm.role_arn,\n                definition_substitutions=sm.definition_substitutions,\n            )\n        )\n    sf_provider = StepFunctionsProvider(\n        state_machines=sm_configs if sm_configs else None,\n    )\n    for sm in app_model.state_machines:\n        node_id = _find_node_id(graph, NodeType.STATE_MACHINE, sm.name)\n        if node_id:\n            providers[node_id] = sf_provider\n    return sf_provider, providers\n\n\ndef _create_ecs_providers(\n    app_model: AppModel,\n    graph: AppGraph,\n) -> tuple[EcsProvider, dict[str, Provider]]:\n    \"\"\"Create ECS service providers from the app model.\n\n    Always returns a provider (even with no CDK services).\n    \"\"\"\n    providers: dict[str, Provider] = {}\n    ecs_provider = EcsProvider(\n        services=app_model.ecs_services if app_model.ecs_services else None,\n    )\n    for svc in app_model.ecs_services:\n        svc_name = getattr(svc, \"service_name\", str(id(svc)))\n        node_id = _find_node_id(graph, NodeType.ECS_SERVICE, svc_name)\n        if node_id:\n            providers[node_id] = ecs_provider\n    return ecs_provider, providers\n\n\ndef _create_cognito_providers(\n    app_model: AppModel,\n    data_dir: Path,\n    compute_providers: dict[str, ICompute],\n) -> tuple[CognitoProvider, dict[str, Provider]]:\n    \"\"\"Create Cognito user pool providers from the app model.\n\n    Always returns a provider (even with no CDK user pools) so the\n    Cognito HTTP endpoint is available for Terraform/CLI user pool creation.\n    \"\"\"\n    providers: dict[str, Provider] = {}\n    if not app_model.user_pools:\n        pool_config = UserPoolConfig(\n            user_pool_id=\"us-east-1_default\",\n            user_pool_name=\"default\",\n        )\n        cognito_provider = CognitoProvider(data_dir=data_dir, config=pool_config)\n        return cognito_provider, providers\n    # Use the first user pool (multi-pool support can be added later)\n    pool = app_model.user_pools[0]\n    pw = pool.password_policy\n    password_policy = PasswordPolicy(\n        minimum_length=int(pw.get(\"MinimumLength\", 8)),\n        require_lowercase=bool(pw.get(\"RequireLowercase\", True)),\n        require_uppercase=bool(pw.get(\"RequireUppercase\", True)),\n        require_digits=bool(pw.get(\"RequireNumbers\", pw.get(\"RequireDigits\", True))),\n        require_symbols=bool(pw.get(\"RequireSymbols\", False)),\n    )\n    pool_config = UserPoolConfig(\n        user_pool_id=f\"us-east-1_{pool.logical_id}\",\n        user_pool_name=pool.user_pool_name,\n        password_policy=password_policy,\n        auto_confirm=pool.auto_confirm,\n        client_id=pool.client_id or \"local-client-id\",\n        pre_authentication_trigger=pool.pre_auth_trigger,\n        post_confirmation_trigger=pool.post_confirm_trigger,\n    )\n    trigger_funcs = {}\n    if pool.pre_auth_trigger and pool.pre_auth_trigger in compute_providers:\n        trigger_funcs[\"PreAuthentication\"] = compute_providers[pool.pre_auth_trigger]\n    if pool.post_confirm_trigger and pool.post_confirm_trigger in compute_providers:\n        trigger_funcs[\"PostConfirmation\"] = compute_providers[pool.post_confirm_trigger]\n    cognito_provider = CognitoProvider(\n        data_dir=data_dir, config=pool_config, trigger_functions=trigger_funcs or None\n    )\n    providers[f\"__cognito_{pool.logical_id}__\"] = cognito_provider\n    return cognito_provider, providers\n\n\ndef _wire_remaining_providers(\n    app_model: AppModel,\n    graph: AppGraph,\n    providers: dict[str, Provider],\n    compute_providers: dict[str, ICompute],\n    sqs_provider: SqsProvider,\n    local_endpoints: dict[str, str],\n    data_dir: Path,\n    api_port: int,\n    *,\n    sns_port: int,\n    eb_port: int,\n    sf_port: int,\n    cognito_port: int,\n) -> tuple[\n    SnsProvider,\n    EventBridgeProvider,\n    StepFunctionsProvider,\n    CognitoProvider,\n]:\n    \"\"\"Wire messaging, cognito, and API Gateway providers.\"\"\"\n    sns_provider, sns_providers = _create_sns_providers(app_model, graph)\n    providers.update(sns_providers)\n    sns_provider.set_compute_providers(compute_providers)\n    sns_provider.set_queue_provider(sqs_provider)\n    local_endpoints[\"sns\"] = f\"http://127.0.0.1:{sns_port}\"\n\n    eb_provider, eb_providers = _create_eventbridge_providers(app_model, graph)\n    providers.update(eb_providers)\n    eb_provider.set_compute_providers(compute_providers)\n    local_endpoints[\"events\"] = f\"http://127.0.0.1:{eb_port}\"\n\n    sf_provider, sf_providers = _create_stepfunctions_providers(app_model, graph)\n    providers.update(sf_providers)\n    sf_provider.set_compute_providers(compute_providers)\n    local_endpoints[\"stepfunctions\"] = f\"http://127.0.0.1:{sf_port}\"\n\n    cognito_provider, cognito_providers = _create_cognito_providers(\n        app_model, data_dir, compute_providers\n    )\n    providers.update(cognito_providers)\n    local_endpoints[\"cognito-idp\"] = f\"http://127.0.0.1:{cognito_port}\"\n\n    api_provider, api_providers = _create_api_providers(\n        app_model, graph, compute_providers, api_port\n    )\n    providers.update(api_providers)\n\n    return sns_provider, eb_provider, sf_provider, cognito_provider\n\n\ndef _create_providers(\n    app_model: AppModel,\n    graph: AppGraph,\n    config: LdkConfig,\n    data_dir: Path,\n) -> tuple[dict[str, Provider], dict[str, ICompute]]:\n    \"\"\"Instantiate providers from the parsed app model.\n\n    Returns a tuple of (provider map, compute_providers).\n    \"\"\"\n    providers: dict[str, Provider] = {}\n\n    # Port allocation: base+1 DynamoDB, +2 SQS, +3 S3, +4 SNS, +5 EventBridge,\n    # +6 Step Functions, +7 Cognito, +12 SSM, +13 Secrets Manager\n    dynamo_port = config.port + 1\n    sqs_port = config.port + 2\n    s3_port = config.port + 3\n    sns_port = config.port + 4\n    eb_port = config.port + 5\n    sf_port = config.port + 6\n    cognito_port = config.port + 7\n    ssm_port = config.port + 12\n    secretsmanager_port = config.port + 13\n\n    # 1. Storage providers (no deps)\n    dynamo_provider, dynamo_providers = _create_dynamo_providers(app_model, graph, data_dir)\n    providers.update(dynamo_providers)\n\n    sqs_provider, sqs_providers = _create_sqs_providers(app_model, graph)\n    providers.update(sqs_providers)\n\n    s3_provider, s3_providers = _create_s3_providers(app_model, graph, data_dir)\n    providers.update(s3_providers)\n\n    # 2. Build local_endpoints for SDK env redirection\n    local_endpoints: dict[str, str] = {}\n    local_endpoints[\"dynamodb\"] = f\"http://127.0.0.1:{dynamo_port}\"\n    local_endpoints[\"sqs\"] = f\"http://127.0.0.1:{sqs_port}\"\n    local_endpoints[\"s3\"] = f\"http://127.0.0.1:{s3_port}\"\n\n    # 3. Compute (Lambda — Node.js + Python)\n    sdk_env = build_sdk_env(local_endpoints)\n    compute_providers, compute_graph_providers = _create_compute_providers(\n        app_model, graph, local_endpoints, sdk_env\n    )\n    providers.update(compute_graph_providers)\n\n    # 4-6. Messaging, ECS, Cognito, API Gateway\n    sns_provider, eb_provider, sf_provider, cognito_provider = _wire_remaining_providers(\n        app_model,\n        graph,\n        providers,\n        compute_providers,\n        sqs_provider,\n        local_endpoints,\n        data_dir,\n        config.port,\n        sns_port=sns_port,\n        eb_port=eb_port,\n        sf_port=sf_port,\n        cognito_port=cognito_port,\n    )\n    ecs_provider, ecs_providers = _create_ecs_providers(app_model, graph)\n    providers.update(ecs_providers)\n\n    # 7. Add SSM and Secrets Manager endpoints, rebuild SDK env, update compute\n    local_endpoints[\"ssm\"] = f\"http://127.0.0.1:{ssm_port}\"\n    local_endpoints[\"secretsmanager\"] = f\"http://127.0.0.1:{secretsmanager_port}\"\n    sdk_env = build_sdk_env(local_endpoints)\n    for compute in compute_providers.values():\n        if hasattr(compute, \"_sdk_env\"):\n            compute._sdk_env = sdk_env\n\n    # 8. Create HTTP servers for each active service\n    _register_http_providers(\n        providers,\n        dynamo_provider=dynamo_provider,\n        sqs_provider=sqs_provider,\n        s3_provider=s3_provider,\n        sns_provider=sns_provider,\n        eb_provider=eb_provider,\n        sf_provider=sf_provider,\n        cognito_provider=cognito_provider,\n        ports={\n            \"dynamodb\": dynamo_port,\n            \"sqs\": sqs_port,\n            \"s3\": s3_port,\n            \"sns\": sns_port,\n            \"eventbridge\": eb_port,\n            \"stepfunctions\": sf_port,\n            \"cognito\": cognito_port,\n        },\n    )\n\n    # 9. SSM Parameter Store and Secrets Manager (pre-seeded from CloudFormation)\n    from lws.providers.secretsmanager.routes import create_secretsmanager_app\n    from lws.providers.ssm.routes import create_ssm_app\n\n    ssm_params = [\n        {\"name\": p.name, \"type\": p.type, \"value\": p.value, \"description\": p.description}\n        for p in app_model.ssm_parameters\n    ]\n    sm_secrets = [\n        {\"name\": s.name, \"description\": s.description, \"secret_string\": s.secret_string}\n        for s in app_model.secrets\n    ]\n\n    providers[\"__ssm_http__\"] = _HttpServiceProvider(\n        \"ssm-http\", lambda: create_ssm_app(ssm_params), ssm_port\n    )\n    providers[\"__secretsmanager_http__\"] = _HttpServiceProvider(\n        \"secretsmanager-http\", lambda: create_secretsmanager_app(sm_secrets), secretsmanager_port\n    )\n\n    return providers, compute_providers\n\n\ndef _register_http_providers(\n    providers: dict[str, Provider],\n    *,\n    dynamo_provider: SqliteDynamoProvider,\n    sqs_provider: SqsProvider,\n    s3_provider: S3Provider,\n    sns_provider: SnsProvider,\n    eb_provider: EventBridgeProvider,\n    sf_provider: StepFunctionsProvider,\n    cognito_provider: CognitoProvider,\n    ports: dict[str, int],\n) -> None:\n    \"\"\"Register HTTP service providers for each active backend.\"\"\"\n    from lws.providers.cognito.routes import create_cognito_app\n    from lws.providers.eventbridge.routes import create_eventbridge_app\n    from lws.providers.stepfunctions.routes import create_stepfunctions_app\n\n    http_services: list[tuple[str, Any, Callable[[], Any]]] = []\n    http_services.append(\n        (\"dynamodb\", ports[\"dynamodb\"], lambda p=dynamo_provider: create_dynamodb_app(p))\n    )\n    http_services.append(\n        (\"sqs\", ports[\"sqs\"], lambda p=sqs_provider, pt=ports[\"sqs\"]: create_sqs_app(p, pt))\n    )\n    http_services.append((\"s3\", ports[\"s3\"], lambda p=s3_provider: create_s3_app(p)))\n    http_services.append((\"sns\", ports[\"sns\"], lambda p=sns_provider: create_sns_app(p)))\n    http_services.append(\n        (\"eventbridge\", ports[\"eventbridge\"], lambda p=eb_provider: create_eventbridge_app(p))\n    )\n    http_services.append(\n        (\n            \"stepfunctions\",\n            ports[\"stepfunctions\"],\n            lambda p=sf_provider: create_stepfunctions_app(p),\n        )\n    )\n    http_services.append(\n        (\"cognito\", ports[\"cognito\"], lambda p=cognito_provider: create_cognito_app(p))\n    )\n\n    for svc_name, port, factory in http_services:\n        providers[f\"__{svc_name}_http__\"] = _HttpServiceProvider(f\"{svc_name}-http\", factory, port)\n\n\nclass _HttpServiceProvider(Provider):\n    \"\"\"Generic wrapper that runs any FastAPI app as a uvicorn-served Provider.\"\"\"\n\n    def __init__(self, service_name: str, app_factory: Callable[[], Any], port: int) -> None:\n        self._service_name = service_name\n        self._app_factory = app_factory\n        self._port = port\n        self._server: uvicorn.Server | None = None\n        self._task: asyncio.Task | None = None  # type: ignore[type-arg]\n\n    @property\n    def name(self) -> str:\n        return self._service_name\n\n    async def start(self) -> None:\n        http_app = self._app_factory()\n        uvi_config = uvicorn.Config(\n            app=http_app,\n            host=\"0.0.0.0\",\n            port=self._port,\n            log_level=\"warning\",\n        )\n        self._server = uvicorn.Server(uvi_config)\n        self._task = asyncio.create_task(self._server.serve())\n        # Wait for the server to actually bind before reporting as started\n        for _ in range(50):\n            if self._server.started:\n                break\n            await asyncio.sleep(0.1)\n\n    async def stop(self) -> None:\n        if self._server is not None:\n            self._server.should_exit = True\n        if self._task is not None:\n            await self._task\n            self._task = None\n        self._server = None\n\n    async def health_check(self) -> bool:\n        return self._server is not None\n\n\ndef _build_resource_metadata(app_model: AppModel, port: int) -> dict[str, Any]:\n    \"\"\"Build resource metadata for the ``/_ldk/resources`` endpoint.\"\"\"\n    metadata: dict[str, Any] = {\"port\": port, \"services\": {}}\n    services = metadata[\"services\"]\n    ports = _service_ports(port)\n\n    _add_api_metadata(services, app_model, port)\n    _add_service_metadata(services, app_model, ports)\n    return metadata\n\n\ndef _service_ports(port: int) -> dict[str, int]:\n    \"\"\"Return a mapping of service name to port number.\"\"\"\n    return {\n        \"dynamodb\": port + 1,\n        \"sqs\": port + 2,\n        \"s3\": port + 3,\n        \"sns\": port + 4,\n        \"events\": port + 5,\n        \"stepfunctions\": port + 6,\n        \"cognito-idp\": port + 7,\n        \"ssm\": port + 12,\n        \"secretsmanager\": port + 13,\n    }\n\n\ndef _add_api_metadata(services: dict[str, Any], app_model: AppModel, port: int) -> None:\n    \"\"\"Add API Gateway metadata to services.\"\"\"\n    if not app_model.apis:\n        return\n    routes = []\n    for api_def in app_model.apis:\n        for r in api_def.routes:\n            routes.append(\n                {\n                    \"name\": api_def.name,\n                    \"path\": r.path,\n                    \"method\": r.method,\n                    \"handler\": r.handler_name or \"\",\n                }\n            )\n    services[\"apigateway\"] = {\"port\": port, \"resources\": routes}\n\n\ndef _add_service_metadata(\n    services: dict[str, Any], app_model: AppModel, ports: dict[str, int]\n) -> None:\n    \"\"\"Add non-API service metadata to services.\"\"\"\n    if app_model.functions:\n        services[\"lambda\"] = {\n            \"resources\": [\n                {\n                    \"name\": f.name,\n                    \"runtime\": f.runtime,\n                    \"arn\": f\"arn:aws:lambda:us-east-1:000000000000:function:{f.name}\",\n                }\n                for f in app_model.functions\n            ],\n        }\n    if app_model.tables:\n        services[\"dynamodb\"] = {\n            \"port\": ports[\"dynamodb\"],\n            \"resources\": [{\"name\": t.name} for t in app_model.tables],\n        }\n    if app_model.queues:\n        sqs_port = ports[\"sqs\"]\n        services[\"sqs\"] = {\n            \"port\": sqs_port,\n            \"resources\": [\n                {\n                    \"name\": q.name,\n                    \"queue_url\": f\"http://localhost:{sqs_port}/000000000000/{q.name}\",\n                }\n                for q in app_model.queues\n            ],\n        }\n    if app_model.buckets:\n        services[\"s3\"] = {\n            \"port\": ports[\"s3\"],\n            \"resources\": [{\"name\": b.name} for b in app_model.buckets],\n        }\n    if app_model.topics:\n        services[\"sns\"] = {\n            \"port\": ports[\"sns\"],\n            \"resources\": [\n                {\n                    \"name\": t.name,\n                    \"arn\": t.topic_arn or f\"arn:aws:sns:us-east-1:000000000000:{t.name}\",\n                }\n                for t in app_model.topics\n            ],\n        }\n    if app_model.event_buses:\n        services[\"events\"] = {\n            \"port\": ports[\"events\"],\n            \"resources\": [\n                {\n                    \"name\": b.name,\n                    \"arn\": b.bus_arn or f\"arn:aws:events:us-east-1:000000000000:event-bus/{b.name}\",\n                }\n                for b in app_model.event_buses\n            ],\n        }\n    if app_model.state_machines:\n        services[\"stepfunctions\"] = {\n            \"port\": ports[\"stepfunctions\"],\n            \"resources\": [\n                {\n                    \"name\": sm.name,\n                    \"arn\": f\"arn:aws:states:us-east-1:000000000000:stateMachine:{sm.name}\",\n                }\n                for sm in app_model.state_machines\n            ],\n        }\n    if app_model.user_pools:\n        services[\"cognito-idp\"] = {\n            \"port\": ports[\"cognito-idp\"],\n            \"resources\": [\n                {\"name\": p.user_pool_name, \"user_pool_id\": f\"us-east-1_{p.logical_id}\"}\n                for p in app_model.user_pools\n            ],\n        }\n\n\ndef _mount_management_api(\n    providers: dict[str, Provider],\n    orchestrator: Orchestrator,\n    compute_providers: dict[str, ICompute],\n    port: int,\n    resource_metadata: dict[str, Any] | None = None,\n) -> None:\n    \"\"\"Mount the management API router on the API Gateway app or create a standalone one.\"\"\"\n    from fastapi import FastAPI\n\n    from lws.api.management import create_management_router\n\n    mgmt_router = create_management_router(\n        orchestrator, compute_providers, providers, resource_metadata=resource_metadata\n    )\n\n    # Try to find an existing API Gateway provider to mount on\n    for key, prov in providers.items():\n        if isinstance(prov, ApiGatewayProvider):\n            prov.app.include_router(mgmt_router)\n            return\n\n    # No API Gateway — create a standalone FastAPI app for management\n    mgmt_app = FastAPI(title=\"LDK Management\")\n    mgmt_app.include_router(mgmt_router)\n    providers[\"__management_http__\"] = _HttpServiceProvider(\n        \"management-http\", lambda: mgmt_app, port\n    )\n\n\ndef _find_node_id(graph: AppGraph, node_type: NodeType, name: str) -> str | None:\n    \"\"\"Find a graph node ID by type and name.\"\"\"\n    for nid, node in graph.nodes.items():\n        if node.node_type == node_type and nid == name:\n            return nid\n    # Fallback: check config\n    for nid, node in graph.nodes.items():\n        if node.node_type == node_type:\n            if node.config.get(\"table_name\") == name or node.config.get(\"handler\") == name:\n                return nid\n    return name\n\n\ndef _build_key_schema(raw_schema: list[dict[str, str]]) -> KeySchema:\n    \"\"\"Convert raw key schema dicts to a KeySchema dataclass.\"\"\"\n    pk: KeyAttribute | None = None\n    sk: KeyAttribute | None = None\n    for ks in raw_schema:\n        attr = KeyAttribute(name=ks.get(\"attribute_name\", \"pk\"), type=ks.get(\"type\", \"S\"))\n        if ks.get(\"key_type\") == \"RANGE\":\n            sk = attr\n        else:\n            pk = attr\n    if pk is None:\n        pk = KeyAttribute(name=\"pk\", type=\"S\")\n    return KeySchema(partition_key=pk, sort_key=sk)\n\n\ndef _build_gsi(raw_gsi: dict) -> GsiDefinition:\n    \"\"\"Convert a raw GSI dict to a GsiDefinition dataclass.\"\"\"\n    index_name = raw_gsi.get(\"index_name\", raw_gsi.get(\"IndexName\", \"gsi\"))\n    ks_raw = raw_gsi.get(\"key_schema\", [])\n    ks = _build_key_schema(ks_raw)\n    projection = raw_gsi.get(\"projection_type\", \"ALL\")\n    return GsiDefinition(index_name=index_name, key_schema=ks, projection_type=projection)\n","structuredPatch":[{"oldStart":668,"oldLines":6,"newStart":668,"newLines":8,"lines":["         or app_model.state_machines","         or app_model.ecs_services","         or app_model.user_pools","+        or app_model.ssm_parameters","+        or app_model.secrets","     )"," "," "]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"f457d6ed-5306-4fbe-8a0c-898e6048397c"}
{"parentUuid":"fad36a06-9630-4620-9019-af4db5273e80","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","message":{"model":"claude-opus-4-6","id":"msg_01LVXsYyUFWvXxJDAUGRewBw","type":"message","role":"assistant","content":[{"type":"text","text":"Also add SSM/SecretsManager to `_add_service_metadata` for the management API:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":431,"cache_read_input_tokens":71413,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":431},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CY1FNBwrrBB9upJgxozFD","type":"assistant","uuid":"193b1827-7de9-4b01-a82d-56d7d750d3a6","timestamp":"2026-02-10T23:22:37.084Z"}
{"parentUuid":"193b1827-7de9-4b01-a82d-56d7d750d3a6","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","message":{"model":"claude-opus-4-6","id":"msg_01LVXsYyUFWvXxJDAUGRewBw","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_018dj4iTkAGSmBDLMhEDKkTP","name":"Read","input":{"file_path":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services/src/lws/cli/ldk.py","offset":1419,"limit":30}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":431,"cache_read_input_tokens":71413,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":431},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CY1FNBwrrBB9upJgxozFD","type":"assistant","uuid":"bc3d36a1-1cab-4d05-9a21-18d492bbd562","timestamp":"2026-02-10T23:22:37.978Z"}
{"parentUuid":"bc3d36a1-1cab-4d05-9a21-18d492bbd562","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"callback"},"parentToolUseID":"toolu_018dj4iTkAGSmBDLMhEDKkTP","toolUseID":"toolu_018dj4iTkAGSmBDLMhEDKkTP","timestamp":"2026-02-10T23:22:37.986Z","uuid":"fa2f302f-27f8-482d-8a47-0646c0a3a0c7"}
{"parentUuid":"bc3d36a1-1cab-4d05-9a21-18d492bbd562","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_018dj4iTkAGSmBDLMhEDKkTP","type":"tool_result","content":"  1419→                    \"name\": b.name,\n  1420→                    \"arn\": b.bus_arn or f\"arn:aws:events:us-east-1:000000000000:event-bus/{b.name}\",\n  1421→                }\n  1422→                for b in app_model.event_buses\n  1423→            ],\n  1424→        }\n  1425→    if app_model.state_machines:\n  1426→        services[\"stepfunctions\"] = {\n  1427→            \"port\": ports[\"stepfunctions\"],\n  1428→            \"resources\": [\n  1429→                {\n  1430→                    \"name\": sm.name,\n  1431→                    \"arn\": f\"arn:aws:states:us-east-1:000000000000:stateMachine:{sm.name}\",\n  1432→                }\n  1433→                for sm in app_model.state_machines\n  1434→            ],\n  1435→        }\n  1436→    if app_model.user_pools:\n  1437→        services[\"cognito-idp\"] = {\n  1438→            \"port\": ports[\"cognito-idp\"],\n  1439→            \"resources\": [\n  1440→                {\"name\": p.user_pool_name, \"user_pool_id\": f\"us-east-1_{p.logical_id}\"}\n  1441→                for p in app_model.user_pools\n  1442→            ],\n  1443→        }\n  1444→\n  1445→\n  1446→def _mount_management_api(\n  1447→    providers: dict[str, Provider],\n  1448→    orchestrator: Orchestrator,\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"b77861e0-af1b-4193-8331-1035d79f4da0","timestamp":"2026-02-10T23:22:37.985Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services/src/lws/cli/ldk.py","content":"                    \"name\": b.name,\n                    \"arn\": b.bus_arn or f\"arn:aws:events:us-east-1:000000000000:event-bus/{b.name}\",\n                }\n                for b in app_model.event_buses\n            ],\n        }\n    if app_model.state_machines:\n        services[\"stepfunctions\"] = {\n            \"port\": ports[\"stepfunctions\"],\n            \"resources\": [\n                {\n                    \"name\": sm.name,\n                    \"arn\": f\"arn:aws:states:us-east-1:000000000000:stateMachine:{sm.name}\",\n                }\n                for sm in app_model.state_machines\n            ],\n        }\n    if app_model.user_pools:\n        services[\"cognito-idp\"] = {\n            \"port\": ports[\"cognito-idp\"],\n            \"resources\": [\n                {\"name\": p.user_pool_name, \"user_pool_id\": f\"us-east-1_{p.logical_id}\"}\n                for p in app_model.user_pools\n            ],\n        }\n\n\ndef _mount_management_api(\n    providers: dict[str, Provider],\n    orchestrator: Orchestrator,","numLines":30,"startLine":1419,"totalLines":1511}},"sourceToolAssistantUUID":"bc3d36a1-1cab-4d05-9a21-18d492bbd562"}
{"parentUuid":"b77861e0-af1b-4193-8331-1035d79f4da0","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","message":{"model":"claude-opus-4-6","id":"msg_018h35NZPRH9NAsJg1HqAPfz","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01KMBy7agr5g28qc2sAAj18j","name":"Edit","input":{"replace_all":false,"file_path":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services/src/lws/cli/ldk.py","old_string":"    if app_model.user_pools:\n        services[\"cognito-idp\"] = {\n            \"port\": ports[\"cognito-idp\"],\n            \"resources\": [\n                {\"name\": p.user_pool_name, \"user_pool_id\": f\"us-east-1_{p.logical_id}\"}\n                for p in app_model.user_pools\n            ],\n        }\n\n\ndef _mount_management_api(","new_string":"    if app_model.user_pools:\n        services[\"cognito-idp\"] = {\n            \"port\": ports[\"cognito-idp\"],\n            \"resources\": [\n                {\"name\": p.user_pool_name, \"user_pool_id\": f\"us-east-1_{p.logical_id}\"}\n                for p in app_model.user_pools\n            ],\n        }\n    if app_model.ssm_parameters:\n        services[\"ssm\"] = {\n            \"port\": ports[\"ssm\"],\n            \"resources\": [{\"name\": p.name} for p in app_model.ssm_parameters],\n        }\n    if app_model.secrets:\n        services[\"secretsmanager\"] = {\n            \"port\": ports[\"secretsmanager\"],\n            \"resources\": [\n                {\n                    \"name\": s.name,\n                    \"arn\": f\"arn:aws:secretsmanager:us-east-1:000000000000:secret:{s.name}\",\n                }\n                for s in app_model.secrets\n            ],\n        }\n\n\ndef _mount_management_api("}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":892,"cache_read_input_tokens":71844,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":892},"output_tokens":25,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CY1FNRwUp6YqX1AK1amGt","type":"assistant","uuid":"4e3efb1a-8030-43f5-bd62-34fb9c1486b0","timestamp":"2026-02-10T23:22:43.869Z"}
{"parentUuid":"4e3efb1a-8030-43f5-bd62-34fb9c1486b0","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"callback"},"parentToolUseID":"toolu_01KMBy7agr5g28qc2sAAj18j","toolUseID":"toolu_01KMBy7agr5g28qc2sAAj18j","timestamp":"2026-02-10T23:22:43.876Z","uuid":"0bd8a887-d387-4ccf-8302-92b5eb30255b"}
{"parentUuid":"4e3efb1a-8030-43f5-bd62-34fb9c1486b0","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01KMBy7agr5g28qc2sAAj18j","type":"tool_result","content":"The file /Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services/src/lws/cli/ldk.py has been updated successfully."}]},"uuid":"7787707c-987e-45e4-a556-fd537c150234","timestamp":"2026-02-10T23:22:43.875Z","toolUseResult":{"filePath":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services/src/lws/cli/ldk.py","oldString":"    if app_model.user_pools:\n        services[\"cognito-idp\"] = {\n            \"port\": ports[\"cognito-idp\"],\n            \"resources\": [\n                {\"name\": p.user_pool_name, \"user_pool_id\": f\"us-east-1_{p.logical_id}\"}\n                for p in app_model.user_pools\n            ],\n        }\n\n\ndef _mount_management_api(","newString":"    if app_model.user_pools:\n        services[\"cognito-idp\"] = {\n            \"port\": ports[\"cognito-idp\"],\n            \"resources\": [\n                {\"name\": p.user_pool_name, \"user_pool_id\": f\"us-east-1_{p.logical_id}\"}\n                for p in app_model.user_pools\n            ],\n        }\n    if app_model.ssm_parameters:\n        services[\"ssm\"] = {\n            \"port\": ports[\"ssm\"],\n            \"resources\": [{\"name\": p.name} for p in app_model.ssm_parameters],\n        }\n    if app_model.secrets:\n        services[\"secretsmanager\"] = {\n            \"port\": ports[\"secretsmanager\"],\n            \"resources\": [\n                {\n                    \"name\": s.name,\n                    \"arn\": f\"arn:aws:secretsmanager:us-east-1:000000000000:secret:{s.name}\",\n                }\n                for s in app_model.secrets\n            ],\n        }\n\n\ndef _mount_management_api(","originalFile":"\"\"\"LDK CLI entry point.\n\nProvides the ``ldk dev``, ``ldk invoke``, and ``ldk reset`` commands.\n``ldk dev`` parses a CDK cloud assembly, builds the application graph,\nstarts local providers, and watches for file changes.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport asyncio\nimport json\nimport logging\nimport shutil\nfrom collections.abc import Callable\nfrom pathlib import Path\nfrom typing import Any\n\nimport typer\nimport uvicorn\nfrom rich.console import Console\nfrom rich.syntax import Syntax\n\nfrom lws.cli.display import (\n    print_banner,\n    print_error,\n    print_resource_summary,\n    print_startup_complete,\n)\nfrom lws.config.loader import ConfigError, LdkConfig, load_config\nfrom lws.graph.builder import AppGraph, NodeType, build_graph\nfrom lws.interfaces import (\n    ComputeConfig,\n    GsiDefinition,\n    ICompute,\n    KeyAttribute,\n    KeySchema,\n    Provider,\n    TableConfig,\n)\nfrom lws.parser.assembly import AppModel, parse_assembly\nfrom lws.providers.apigateway.provider import ApiGatewayProvider, RouteConfig\nfrom lws.providers.cognito.provider import CognitoProvider\nfrom lws.providers.cognito.user_store import PasswordPolicy, UserPoolConfig\nfrom lws.providers.dynamodb.provider import SqliteDynamoProvider\nfrom lws.providers.dynamodb.routes import create_dynamodb_app\nfrom lws.providers.ecs.provider import EcsProvider\nfrom lws.providers.eventbridge.provider import (\n    EventBridgeProvider,\n    EventBusConfig,\n    RuleConfig,\n    RuleTarget,\n)\nfrom lws.providers.lambda_runtime.nodejs import NodeJsCompute\nfrom lws.providers.lambda_runtime.python import PythonCompute\nfrom lws.providers.s3.provider import S3Provider\nfrom lws.providers.s3.routes import create_s3_app\nfrom lws.providers.sns.provider import SnsProvider, TopicConfig\nfrom lws.providers.sns.routes import create_sns_app\nfrom lws.providers.sqs.provider import QueueConfig, RedrivePolicy, SqsProvider\nfrom lws.providers.sqs.routes import create_sqs_app\nfrom lws.providers.stepfunctions.provider import (\n    StateMachineConfig,\n    StepFunctionsProvider,\n    WorkflowType,\n)\nfrom lws.runtime.env_builder import build_lambda_env\nfrom lws.runtime.orchestrator import Orchestrator\nfrom lws.runtime.sdk_env import build_sdk_env\nfrom lws.runtime.synth import SynthError, ensure_synth\nfrom lws.runtime.watcher import FileWatcher\n\n_console = Console()\n\napp = typer.Typer(name=\"ldk\", help=\"Local Development Kit - Run AWS CDK applications locally\")\n\n__version__ = \"0.4.0\"\n\n\n@app.callback()\ndef main() -> None:\n    \"\"\"LDK - Local Development Kit.\"\"\"\n\n\n@app.command()\ndef dev(\n    port: int = typer.Option(None, \"--port\", \"-p\", help=\"API Gateway listen port\"),\n    no_persist: bool = typer.Option(False, \"--no-persist\", help=\"Disable data persistence\"),\n    force_synth: bool = typer.Option(False, \"--force-synth\", help=\"Force CDK synth\"),\n    log_level: str = typer.Option(\n        None, \"--log-level\", \"-l\", help=\"Log level (debug/info/warning/error)\"\n    ),\n    project_dir: Path = typer.Option(\".\", \"--project-dir\", \"-d\", help=\"Project root directory\"),\n    mode: str = typer.Option(None, \"--mode\", \"-m\", help=\"Project mode (cdk or terraform)\"),\n) -> None:\n    \"\"\"Start the local development environment.\"\"\"\n    try:\n        asyncio.run(_run_dev(project_dir, port, no_persist, force_synth, log_level, mode))\n    except KeyboardInterrupt:\n        pass\n\n\n@app.command()\ndef invoke(\n    function_name: str = typer.Option(..., \"--function-name\", \"-f\", help=\"Lambda function name\"),\n    event: str = typer.Option(None, \"--event\", \"-e\", help=\"Inline JSON event payload\"),\n    event_file: Path = typer.Option(None, \"--event-file\", help=\"Path to JSON event file\"),\n    project_dir: Path = typer.Option(\".\", \"--project-dir\", \"-d\", help=\"Project root directory\"),\n    port: int = typer.Option(None, \"--port\", \"-p\", help=\"Management API port\"),\n) -> None:\n    \"\"\"Invoke a Lambda function directly.\"\"\"\n    asyncio.run(_run_invoke(function_name, event, event_file, project_dir, port))\n\n\nasync def _run_invoke(\n    function_name: str,\n    event_json: str | None,\n    event_file: Path | None,\n    project_dir: Path,\n    port_override: int | None,\n) -> None:\n    \"\"\"Async implementation of the ``ldk invoke`` command.\"\"\"\n    # Resolve event payload\n    event_payload = _resolve_event_payload(event_json, event_file)\n\n    # Try connecting to running ldk dev via management API\n    project_dir = project_dir.resolve()\n    config = _load_config_quiet(project_dir)\n    mgmt_port = port_override or config.port\n\n    if await _try_management_invoke(mgmt_port, function_name, event_payload):\n        return\n\n    # Fallback: one-shot invocation\n    _console.print(\"[dim]No running ldk dev found, performing one-shot invocation...[/dim]\")\n    await _oneshot_invoke(project_dir, config, function_name, event_payload)\n\n\ndef _resolve_event_payload(event_json: str | None, event_file: Path | None) -> dict:\n    \"\"\"Parse event payload from CLI args.\"\"\"\n    if event_json is not None:\n        try:\n            return json.loads(event_json)\n        except json.JSONDecodeError as exc:\n            print_error(\"Invalid JSON in --event\", str(exc))\n            raise typer.Exit(1)\n\n    if event_file is not None:\n        if not event_file.exists():\n            print_error(\"Event file not found\", str(event_file))\n            raise typer.Exit(1)\n        try:\n            return json.loads(event_file.read_text())\n        except json.JSONDecodeError as exc:\n            print_error(\"Invalid JSON in event file\", str(exc))\n            raise typer.Exit(1)\n\n    return {}\n\n\nasync def _try_management_invoke(port: int, function_name: str, event: dict) -> bool:\n    \"\"\"Try to invoke via the management API. Return True if successful.\"\"\"\n    try:\n        import httpx\n\n        async with httpx.AsyncClient() as client:\n            resp = await client.post(\n                f\"http://localhost:{port}/_ldk/invoke\",\n                json={\"function_name\": function_name, \"event\": event},\n                timeout=30.0,\n            )\n            result = resp.json()\n            formatted = json.dumps(result, indent=2)\n            syntax = Syntax(formatted, \"json\", theme=\"monokai\")\n            _console.print(syntax)\n            return True\n    except Exception:\n        return False\n\n\nasync def _oneshot_invoke(\n    project_dir: Path, config: LdkConfig, function_name: str, event: dict\n) -> None:\n    \"\"\"Perform a one-shot Lambda invocation without a running server.\"\"\"\n    try:\n        import uuid as _uuid\n\n        from lws.interfaces import InvocationResult, LambdaContext\n\n        cdk_out = project_dir / config.cdk_out_dir\n        if not cdk_out.exists():\n            print_error(\"CDK output not found\", f\"Run 'cdk synth' first in {project_dir}\")\n            raise typer.Exit(1)\n\n        app_model = parse_assembly(cdk_out)\n        func_def = next((f for f in app_model.functions if f.name == function_name), None)\n        if func_def is None:\n            print_error(\"Function not found\", f\"No function named '{function_name}'\")\n            raise typer.Exit(1)\n\n        sdk_env = build_sdk_env({})\n        func_env = build_lambda_env(\n            function_name=func_def.name,\n            function_env=func_def.environment,\n            local_endpoints={},\n            resolved_refs={},\n        )\n        compute_config = ComputeConfig(\n            function_name=func_def.name,\n            handler=func_def.handler,\n            runtime=func_def.runtime,\n            code_path=func_def.code_path or Path(\".\"),\n            timeout=func_def.timeout,\n            memory_size=func_def.memory,\n            environment=func_env,\n        )\n        compute = NodeJsCompute(config=compute_config, sdk_env=sdk_env)\n        await compute.start()\n\n        request_id = str(_uuid.uuid4())\n        context = LambdaContext(\n            function_name=function_name,\n            memory_limit_in_mb=compute_config.memory_size,\n            timeout_seconds=compute_config.timeout,\n            aws_request_id=request_id,\n            invoked_function_arn=(\n                f\"arn:aws:lambda:us-east-1:000000000000:function:{function_name}\"\n            ),\n        )\n\n        result: InvocationResult = await compute.invoke(event, context)\n        await compute.stop()\n\n        output = result.payload if result.error is None else {\"error\": result.error}\n        formatted = json.dumps(output, indent=2, default=str)\n        syntax = Syntax(formatted, \"json\", theme=\"monokai\")\n        _console.print(syntax)\n\n    except typer.Exit:\n        raise\n    except Exception as exc:\n        print_error(\"Invocation failed\", str(exc))\n        raise typer.Exit(1)\n\n\n@app.command()\ndef reset(\n    yes: bool = typer.Option(False, \"--yes\", \"-y\", help=\"Skip confirmation prompt\"),\n    project_dir: Path = typer.Option(\".\", \"--project-dir\", \"-d\", help=\"Project root directory\"),\n    port: int = typer.Option(None, \"--port\", \"-p\", help=\"Management API port\"),\n) -> None:\n    \"\"\"Reset all LDK local state (databases, queues, etc.).\"\"\"\n    project_dir = project_dir.resolve()\n    config = _load_config_quiet(project_dir)\n    data_dir = project_dir / config.data_dir\n\n    if not data_dir.exists():\n        _console.print(\"[dim]No data directory found. Nothing to reset.[/dim]\")\n        return\n\n    # List contents to be deleted\n    items = list(data_dir.iterdir())\n    if not items:\n        _console.print(\"[dim]Data directory is empty. Nothing to reset.[/dim]\")\n        return\n\n    _console.print(f\"[bold]Will delete all files under:[/bold] {data_dir}\")\n    for item in items:\n        kind = \"dir\" if item.is_dir() else \"file\"\n        _console.print(f\"  [dim]{kind}:[/dim] {item.name}\")\n\n    if not yes:\n        confirm = typer.confirm(\"Are you sure you want to delete all local state?\")\n        if not confirm:\n            _console.print(\"[dim]Aborted.[/dim]\")\n            return\n\n    # Delete contents\n    deleted_count = 0\n    for item in items:\n        if item.is_dir():\n            shutil.rmtree(item)\n        else:\n            item.unlink()\n        deleted_count += 1\n\n    _console.print(f\"[green]Deleted {deleted_count} item(s) from {data_dir}[/green]\")\n\n    # Notify running ldk dev if possible\n    mgmt_port = port or config.port\n    asyncio.run(_try_management_reset(mgmt_port))\n\n\nasync def _try_management_reset(port: int) -> None:\n    \"\"\"Try to notify running ldk dev of the reset via management API.\"\"\"\n    try:\n        import httpx\n\n        async with httpx.AsyncClient() as client:\n            resp = await client.post(\n                f\"http://localhost:{port}/_ldk/reset\",\n                timeout=5.0,\n            )\n            if resp.status_code == 200:\n                _console.print(\"[dim]Notified running ldk dev of reset.[/dim]\")\n    except Exception:\n        pass  # Server not running, that's fine\n\n\ndef _load_config_quiet(project_dir: Path) -> LdkConfig:\n    \"\"\"Load config without printing errors. Falls back to defaults.\"\"\"\n    try:\n        return load_config(project_dir)\n    except ConfigError:\n        return LdkConfig()\n\n\ndef _load_and_apply_config(\n    project_dir: Path,\n    port_override: int | None,\n    no_persist: bool,\n    log_level_override: str | None,\n) -> LdkConfig:\n    \"\"\"Load config and apply CLI overrides.\"\"\"\n    try:\n        config = load_config(project_dir)\n    except ConfigError as exc:\n        print_error(\"Configuration error\", str(exc))\n        raise typer.Exit(1)\n\n    if port_override is not None:\n        config.port = port_override\n    if log_level_override is not None:\n        config.log_level = log_level_override\n    if no_persist:\n        config.persist = False\n\n    logging.basicConfig(\n        level=getattr(logging, config.log_level.upper(), logging.INFO),\n        format=\"%(levelname)s %(name)s: %(message)s\",\n    )\n    return config\n\n\ndef _collect_extra_resources(app_model: AppModel) -> dict[str, list[str]]:\n    \"\"\"Collect extra resource name lists from the app model for display.\"\"\"\n    extras: dict[str, list[str]] = {}\n    _RESOURCE_ATTRS = {\n        \"queues\": (\"name\", \"queues\"),\n        \"buckets\": (\"name\", \"buckets\"),\n        \"topics\": (\"name\", \"topics\"),\n        \"state_machines\": (\"name\", \"state_machines\"),\n        \"ecs_services\": (\"service_name\", \"ecs_services\"),\n        \"user_pools\": (\"user_pool_name\", \"user_pools\"),\n        \"ssm_parameters\": (\"name\", \"ssm_parameters\"),\n        \"secrets\": (\"name\", \"secrets\"),\n    }\n    for key, (attr, model_attr) in _RESOURCE_ATTRS.items():\n        items = getattr(app_model, model_attr, [])\n        if items:\n            extras[key] = [getattr(item, attr, str(item)) for item in items]\n    return extras\n\n\ndef _build_local_details(app_model: AppModel, port: int) -> dict[str, str]:\n    \"\"\"Build a mapping of ``\"Type:Name\"`` to local detail strings.\"\"\"\n    details: dict[str, str] = {}\n\n    _add_api_details(details, app_model)\n    _add_resource_details(details, app_model)\n    return details\n\n\ndef _add_api_details(details: dict[str, str], app_model: AppModel) -> None:\n    \"\"\"Add API route and Lambda function details.\"\"\"\n    for api_def in app_model.apis:\n        for r in api_def.routes:\n            details[f\"API Route:{r.path}\"] = (\n                f\"lws apigateway test-invoke-method --resource {r.path} --http-method {r.method}\"\n            )\n    for f in app_model.functions:\n        details[f\"Function:{f.name}\"] = f\"ldk invoke {f.name}\"\n\n\ndef _add_resource_details(details: dict[str, str], app_model: AppModel) -> None:\n    \"\"\"Add service resource details (DynamoDB, SQS, S3, etc.).\"\"\"\n    for t in app_model.tables:\n        details[f\"Table:{t.name}\"] = f\"lws dynamodb scan --table-name {t.name}\"\n    for q in app_model.queues:\n        details[f\"Queue:{q.name}\"] = f\"lws sqs receive-message --queue-name {q.name}\"\n    for b in app_model.buckets:\n        details[f\"Bucket:{b.name}\"] = f\"lws s3api list-objects-v2 --bucket {b.name}\"\n    for t in app_model.topics:\n        details[f\"Topic:{t.name}\"] = f\"lws sns publish --topic-name {t.name} --message '...'\"\n    for b in app_model.event_buses:\n        details[f\"Event Bus:{b.name}\"] = f\"lws events list-rules --event-bus-name {b.name}\"\n    for sm in app_model.state_machines:\n        details[f\"State Machine:{sm.name}\"] = f\"lws stepfunctions start-execution --name {sm.name}\"\n    for p in app_model.user_pools:\n        details[f\"User Pool:{p.user_pool_name}\"] = (\n            f\"lws cognito-idp sign-up --user-pool-name {p.user_pool_name}\"\n        )\n    for p in app_model.ssm_parameters:\n        details[f\"Parameter:{p.name}\"] = f\"lws ssm get-parameter --name {p.name}\"\n    for s in app_model.secrets:\n        details[f\"Secret:{s.name}\"] = f\"lws secretsmanager get-secret-value --secret-id {s.name}\"\n\n\ndef _display_summary(app_model: AppModel, port: int) -> None:\n    \"\"\"Print resource summary and startup-complete banner.\"\"\"\n    routes_info = [\n        {\"method\": r.method, \"path\": r.path, \"handler\": r.handler_name or \"\"}\n        for api_def in app_model.apis\n        for r in api_def.routes\n    ]\n    tables_info = [t.name for t in app_model.tables]\n    functions_info = [f\"{f.name} ({f.runtime})\" for f in app_model.functions]\n\n    extra_resources = _collect_extra_resources(app_model)\n    local_details = _build_local_details(app_model, port)\n    print_resource_summary(\n        routes_info, tables_info, functions_info, local_details=local_details, **extra_resources\n    )\n\n    extra_counts = {f\"num_{k}\": len(v) for k, v in extra_resources.items()}\n    print_startup_complete(\n        port,\n        num_routes=len(routes_info),\n        num_tables=len(tables_info),\n        num_functions=len(functions_info),\n        **extra_counts,\n    )\n\n\ndef _resolve_mode(project_dir: Path, config: LdkConfig, mode_override: str | None) -> str:\n    \"\"\"Resolve the project mode from CLI flag, config, or auto-detection.\n\n    Returns ``\"cdk\"`` or ``\"terraform\"``.\n    Raises ``typer.Exit(1)`` on error.\n    \"\"\"\n    from lws.terraform.detect import detect_project_type\n\n    mode = mode_override or config.mode\n    if mode:\n        if mode not in (\"cdk\", \"terraform\"):\n            print_error(\"Invalid mode\", f\"Must be 'cdk' or 'terraform', got '{mode}'\")\n            raise typer.Exit(1)\n        return mode\n\n    detected = detect_project_type(project_dir)\n    if detected == \"ambiguous\":\n        print_error(\n            \"Ambiguous project\",\n            \"Both .tf files and cdk.out found. Use --mode cdk or --mode terraform.\",\n        )\n        raise typer.Exit(1)\n    if detected == \"none\":\n        print_error(\n            \"No project found\",\n            \"No .tf files or cdk.out directory found. \"\n            \"Run from a CDK or Terraform project directory.\",\n        )\n        raise typer.Exit(1)\n    return detected\n\n\nasync def _run_dev_terraform(project_dir: Path, config: LdkConfig) -> None:\n    \"\"\"Run the dev server in Terraform mode.\n\n    Starts all service providers in always-on mode, generates the\n    Terraform provider override file, and waits for shutdown.\n    \"\"\"\n    from lws.terraform.gitignore import ensure_gitignore\n    from lws.terraform.override import cleanup_override, generate_override\n\n    port = config.port\n    data_dir = project_dir / config.data_dir\n    data_dir.mkdir(parents=True, exist_ok=True)\n\n    # Generate override file\n    try:\n        override_path = generate_override(port, project_dir)\n    except FileExistsError as exc:\n        print_error(\"Override file conflict\", str(exc))\n        raise typer.Exit(1)\n\n    ensure_gitignore(project_dir)\n\n    # Create all providers in always-on mode (no app model)\n    providers, ports = _create_terraform_providers(config, data_dir, project_dir)\n\n    orchestrator = Orchestrator()\n\n    # Enable WebSocket log streaming\n    from lws.logging.logger import WebSocketLogHandler, set_ws_handler\n\n    ws_log_handler = WebSocketLogHandler()\n    set_ws_handler(ws_log_handler)\n\n    # Build resource metadata so the CLI client can discover services\n    resource_metadata: dict[str, Any] = {\n        \"port\": port,\n        \"services\": {\n            svc_name: {\"port\": svc_port, \"resources\": []} for svc_name, svc_port in ports.items()\n        },\n    }\n\n    # Mount management API (no compute providers in terraform mode)\n    _mount_management_api(providers, orchestrator, {}, port, resource_metadata)\n\n    for key in providers:\n        pass  # All keys are already in the dict\n\n    startup_order = list(providers.keys())\n\n    try:\n        await orchestrator.start(providers, startup_order)\n    except Exception as exc:\n        cleanup_override(project_dir)\n        print_error(\"Failed to start providers\", str(exc))\n        raise typer.Exit(1)\n\n    # Display summary\n    _console.print()\n    _console.print(\"[bold green]Terraform mode active[/bold green]\")\n    _console.print(f\"  Override file: {override_path}\")\n    _console.print()\n    _console.print(\"[bold]Service endpoints:[/bold]\")\n    for svc_name, svc_port in sorted(ports.items()):\n        _console.print(f\"  {svc_name:20s} http://localhost:{svc_port}\")\n    _console.print()\n    _console.print(\"[dim]Run 'terraform init && terraform apply' to create resources.[/dim]\")\n    _console.print(f\"  Dashboard: http://localhost:{config.port}/_ldk/gui\")\n    _console.print()\n\n    try:\n        await orchestrator.wait_for_shutdown()\n    finally:\n        cleanup_override(project_dir)\n        set_ws_handler(None)\n        await orchestrator.stop()\n        typer.echo(\"Goodbye\")\n\n\ndef _create_terraform_providers(\n    config: LdkConfig,\n    data_dir: Path,\n    project_dir: Path | None = None,\n) -> tuple[dict[str, Provider], dict[str, int]]:\n    \"\"\"Create all service providers for Terraform mode (no app model).\"\"\"\n    providers: dict[str, Provider] = {}\n\n    port = config.port\n    ports = {\n        \"dynamodb\": port + 1,\n        \"sqs\": port + 2,\n        \"s3\": port + 3,\n        \"sns\": port + 4,\n        \"eventbridge\": port + 5,\n        \"stepfunctions\": port + 6,\n        \"cognito\": port + 7,\n        \"apigateway\": port + 8,\n        \"lambda\": port + 9,\n        \"iam\": port + 10,\n        \"sts\": port + 11,\n        \"ssm\": port + 12,\n        \"secretsmanager\": port + 13,\n    }\n\n    dynamo_provider = SqliteDynamoProvider(data_dir=data_dir, tables=[])\n    sqs_provider = SqsProvider()\n    s3_provider = S3Provider(data_dir=data_dir)\n    sns_provider = SnsProvider()\n    eb_provider = EventBridgeProvider()\n    sf_provider = StepFunctionsProvider()\n\n    pool_config = UserPoolConfig(\n        user_pool_id=\"us-east-1_default\",\n        user_pool_name=\"default\",\n    )\n    cognito_provider = CognitoProvider(data_dir=data_dir, config=pool_config)\n\n    _register_http_providers(\n        providers,\n        dynamo_provider=dynamo_provider,\n        sqs_provider=sqs_provider,\n        s3_provider=s3_provider,\n        sns_provider=sns_provider,\n        eb_provider=eb_provider,\n        sf_provider=sf_provider,\n        cognito_provider=cognito_provider,\n        ports=ports,\n    )\n\n    # Shared Lambda registry for Lambda management and API Gateway V2 proxy\n    from lws.providers.lambda_runtime.routes import LambdaRegistry, create_lambda_management_app\n\n    lambda_registry = LambdaRegistry()\n\n    # Wire Lambda registry compute providers into Step Functions so SFN can\n    # invoke Lambda functions that Terraform creates dynamically.\n    sf_provider.set_compute_providers(lambda_registry._compute)\n\n    # Build SDK env so Lambda functions can reach local services\n    local_endpoints: dict[str, str] = {\n        \"dynamodb\": f\"http://127.0.0.1:{ports['dynamodb']}\",\n        \"sqs\": f\"http://127.0.0.1:{ports['sqs']}\",\n        \"s3\": f\"http://127.0.0.1:{ports['s3']}\",\n        \"sns\": f\"http://127.0.0.1:{ports['sns']}\",\n        \"events\": f\"http://127.0.0.1:{ports['eventbridge']}\",\n        \"stepfunctions\": f\"http://127.0.0.1:{ports['stepfunctions']}\",\n        \"cognito-idp\": f\"http://127.0.0.1:{ports['cognito']}\",\n        \"ssm\": f\"http://127.0.0.1:{ports['ssm']}\",\n        \"secretsmanager\": f\"http://127.0.0.1:{ports['secretsmanager']}\",\n    }\n    sdk_env = build_sdk_env(local_endpoints)\n\n    # Lambda management API\n    providers[\"__lambda_http__\"] = _HttpServiceProvider(\n        \"lambda-http\",\n        lambda: create_lambda_management_app(lambda_registry, project_dir, sdk_env),\n        ports[\"lambda\"],\n    )\n\n    # API Gateway management API with V2 support and Lambda proxy\n    from lws.providers.apigateway.routes import create_apigateway_management_app\n\n    providers[\"__apigateway_http__\"] = _HttpServiceProvider(\n        \"apigateway-http\",\n        lambda: create_apigateway_management_app(lambda_registry),\n        ports[\"apigateway\"],\n    )\n\n    # IAM stub\n    from lws.providers.iam.routes import create_iam_app\n\n    providers[\"__iam_http__\"] = _HttpServiceProvider(\"iam-http\", create_iam_app, ports[\"iam\"])\n\n    # STS stub\n    from lws.providers.sts.routes import create_sts_app\n\n    providers[\"__sts_http__\"] = _HttpServiceProvider(\"sts-http\", create_sts_app, ports[\"sts\"])\n\n    # SSM Parameter Store\n    from lws.providers.ssm.routes import create_ssm_app\n\n    providers[\"__ssm_http__\"] = _HttpServiceProvider(\"ssm-http\", create_ssm_app, ports[\"ssm\"])\n\n    # Secrets Manager\n    from lws.providers.secretsmanager.routes import create_secretsmanager_app\n\n    providers[\"__secretsmanager_http__\"] = _HttpServiceProvider(\n        \"secretsmanager-http\", create_secretsmanager_app, ports[\"secretsmanager\"]\n    )\n\n    return providers, ports\n\n\ndef _has_any_resources(app_model: AppModel) -> bool:\n    \"\"\"Return True if the app model contains at least one resource.\"\"\"\n    return bool(\n        app_model.functions\n        or app_model.tables\n        or app_model.apis\n        or app_model.queues\n        or app_model.buckets\n        or app_model.topics\n        or app_model.event_buses\n        or app_model.state_machines\n        or app_model.ecs_services\n        or app_model.user_pools\n        or app_model.ssm_parameters\n        or app_model.secrets\n    )\n\n\nasync def _run_dev(\n    project_dir: Path,\n    port_override: int | None,\n    no_persist: bool,\n    force_synth: bool,\n    log_level_override: str | None,\n    mode_override: str | None = None,\n) -> None:\n    \"\"\"Async implementation of the ``ldk dev`` command.\"\"\"\n    project_dir = project_dir.resolve()\n    config = _load_and_apply_config(project_dir, port_override, no_persist, log_level_override)\n    print_banner(__version__, project_dir.name)\n\n    # Resolve project mode\n    resolved_mode = _resolve_mode(project_dir, config, mode_override)\n    if resolved_mode == \"terraform\":\n        await _run_dev_terraform(project_dir, config)\n        return\n\n    try:\n        cdk_out = await ensure_synth(project_dir, force=force_synth)\n    except SynthError as exc:\n        print_error(\"CDK synth failed\", str(exc))\n        raise typer.Exit(1)\n\n    app_model = parse_assembly(cdk_out)\n    if not _has_any_resources(app_model):\n        print_error(\"No resources found in cloud assembly\", str(cdk_out))\n        raise typer.Exit(1)\n\n    graph = build_graph(app_model)\n    startup_order = graph.topological_sort()\n\n    data_dir = project_dir / config.data_dir\n    data_dir.mkdir(parents=True, exist_ok=True)\n    providers, compute_providers = _create_providers(app_model, graph, config, data_dir)\n\n    orchestrator = Orchestrator()\n\n    # Enable WebSocket log streaming\n    from lws.logging.logger import WebSocketLogHandler, set_ws_handler\n\n    ws_log_handler = WebSocketLogHandler()\n    set_ws_handler(ws_log_handler)\n\n    # Mount management API\n    resource_metadata = _build_resource_metadata(app_model, config.port)\n    _mount_management_api(\n        providers, orchestrator, compute_providers, config.port, resource_metadata\n    )\n\n    # Append non-graph provider keys (HTTP servers, management) to startup order.\n    # This must happen after _mount_management_api so the fallback management\n    # HTTP server (when no API Gateway exists) is included in the startup order.\n    for key in providers:\n        if key not in startup_order:\n            startup_order.append(key)\n\n    try:\n        await orchestrator.start(providers, startup_order)\n    except Exception as exc:\n        print_error(\"Failed to start providers\", str(exc))\n        raise typer.Exit(1)\n\n    _display_summary(app_model, config.port)\n    typer.echo(f\"  Dashboard: http://localhost:{config.port}/_ldk/gui\")\n\n    watcher = FileWatcher(\n        watch_dir=project_dir,\n        include_patterns=config.watch_include,\n        exclude_patterns=config.watch_exclude,\n    )\n    watcher.on_change(lambda path: logging.getLogger(\"ldk.watcher\").info(\"Changed: %s\", path))\n    watcher.start()\n\n    try:\n        await orchestrator.wait_for_shutdown()\n    finally:\n        watcher.stop()\n        set_ws_handler(None)\n        await orchestrator.stop()\n        typer.echo(\"Goodbye\")\n\n\ndef _create_dynamo_providers(\n    app_model: AppModel,\n    graph: AppGraph,\n    data_dir: Path,\n) -> tuple[SqliteDynamoProvider, dict[str, Provider]]:\n    \"\"\"Create DynamoDB table providers from the app model.\n\n    Always returns a provider (even with no CDK tables) so the DynamoDB\n    HTTP endpoint is available for Terraform/CLI table creation.\n    \"\"\"\n    providers: dict[str, Provider] = {}\n    table_configs: list[TableConfig] = []\n    for table in app_model.tables:\n        ks = _build_key_schema(table.key_schema)\n        gsi_defs = [_build_gsi(g) for g in table.gsi_definitions]\n        table_configs.append(\n            TableConfig(table_name=table.name, key_schema=ks, gsi_definitions=gsi_defs)\n        )\n\n    dynamo_provider = SqliteDynamoProvider(data_dir=data_dir, tables=table_configs)\n    for table in app_model.tables:\n        node_id = _find_node_id(graph, NodeType.DYNAMODB_TABLE, table.name)\n        if node_id:\n            providers[node_id] = dynamo_provider\n    return dynamo_provider, providers\n\n\ndef _create_compute_providers(\n    app_model: AppModel,\n    graph: AppGraph,\n    local_endpoints: dict[str, str],\n    sdk_env: dict[str, str],\n) -> tuple[dict[str, ICompute], dict[str, Provider]]:\n    \"\"\"Create Lambda compute providers from the app model (Node.js + Python).\"\"\"\n    providers: dict[str, Provider] = {}\n    compute_providers: dict[str, ICompute] = {}\n    for func in app_model.functions:\n        func_env = build_lambda_env(\n            function_name=func.name,\n            function_env=func.environment,\n            local_endpoints=local_endpoints,\n            resolved_refs={},\n        )\n        compute_config = ComputeConfig(\n            function_name=func.name,\n            handler=func.handler,\n            runtime=func.runtime,\n            code_path=func.code_path or Path(\".\"),\n            timeout=func.timeout,\n            memory_size=func.memory,\n            environment=func_env,\n        )\n        if func.runtime.startswith(\"python\"):\n            compute: ICompute = PythonCompute(config=compute_config, sdk_env=sdk_env)\n        elif func.runtime.startswith(\"nodejs\"):\n            compute = NodeJsCompute(config=compute_config, sdk_env=sdk_env)\n        else:\n            logging.getLogger(\"ldk.cli\").warning(\n                \"Unsupported runtime %s for %s, skipping\", func.runtime, func.name\n            )\n            continue\n        compute_providers[func.name] = compute\n        node_id = _find_node_id(graph, NodeType.LAMBDA_FUNCTION, func.name)\n        if node_id:\n            providers[node_id] = compute\n    return compute_providers, providers\n\n\ndef _create_api_providers(\n    app_model: AppModel,\n    graph: AppGraph,\n    compute_providers: dict[str, ICompute],\n    port: int,\n) -> tuple[ApiGatewayProvider | None, dict[str, Provider]]:\n    \"\"\"Create API Gateway providers from the app model.\"\"\"\n    providers: dict[str, Provider] = {}\n    api_provider: ApiGatewayProvider | None = None\n    for api_def in app_model.apis:\n        route_configs = [\n            RouteConfig(method=r.method, path=r.path, handler_name=r.handler_name)\n            for r in api_def.routes\n            if r.handler_name and r.handler_name in compute_providers\n        ]\n        if route_configs:\n            api_provider = ApiGatewayProvider(\n                routes=route_configs, compute_providers=compute_providers, port=port\n            )\n            node_id = _find_node_id(graph, NodeType.API_GATEWAY, api_def.name)\n            if node_id:\n                providers[node_id] = api_provider\n    return api_provider, providers\n\n\ndef _create_sqs_providers(\n    app_model: AppModel,\n    graph: AppGraph,\n) -> tuple[SqsProvider, dict[str, Provider]]:\n    \"\"\"Create SQS queue providers from the app model.\n\n    Always returns a provider (even with no CDK queues) so the SQS\n    HTTP endpoint is available for Terraform/CLI queue creation.\n    \"\"\"\n    providers: dict[str, Provider] = {}\n    queue_configs = []\n    for q in app_model.queues:\n        redrive = None\n        if q.redrive_target:\n            redrive = RedrivePolicy(\n                dead_letter_queue_name=q.redrive_target, max_receive_count=q.max_receive_count\n            )\n        queue_configs.append(\n            QueueConfig(\n                queue_name=q.name,\n                visibility_timeout=q.visibility_timeout,\n                is_fifo=q.is_fifo,\n                content_based_dedup=q.content_based_dedup,\n                redrive_policy=redrive,\n            )\n        )\n    sqs_provider = SqsProvider(queues=queue_configs if queue_configs else None)\n    for q in app_model.queues:\n        node_id = _find_node_id(graph, NodeType.SQS_QUEUE, q.name)\n        if node_id:\n            providers[node_id] = sqs_provider\n    return sqs_provider, providers\n\n\ndef _create_s3_providers(\n    app_model: AppModel,\n    graph: AppGraph,\n    data_dir: Path,\n) -> tuple[S3Provider, dict[str, Provider]]:\n    \"\"\"Create S3 bucket providers from the app model.\n\n    Always returns a provider (even with no CDK buckets) so the S3\n    HTTP endpoint is available for Terraform/CLI bucket creation.\n    \"\"\"\n    providers: dict[str, Provider] = {}\n    bucket_names = [b.name for b in app_model.buckets]\n    s3_provider = S3Provider(data_dir=data_dir, buckets=bucket_names if bucket_names else None)\n    for b in app_model.buckets:\n        node_id = _find_node_id(graph, NodeType.S3_BUCKET, b.name)\n        if node_id:\n            providers[node_id] = s3_provider\n    return s3_provider, providers\n\n\ndef _create_sns_providers(\n    app_model: AppModel,\n    graph: AppGraph,\n) -> tuple[SnsProvider, dict[str, Provider]]:\n    \"\"\"Create SNS topic providers from the app model.\n\n    Always returns a provider (even with no CDK topics) so the SNS\n    HTTP endpoint is available for Terraform/CLI topic creation.\n    \"\"\"\n    providers: dict[str, Provider] = {}\n    topic_configs = [\n        TopicConfig(topic_name=t.name, topic_arn=t.topic_arn) for t in app_model.topics\n    ]\n    sns_provider = SnsProvider(topics=topic_configs if topic_configs else None)\n    for t in app_model.topics:\n        node_id = _find_node_id(graph, NodeType.SNS_TOPIC, t.name)\n        if node_id:\n            providers[node_id] = sns_provider\n    return sns_provider, providers\n\n\ndef _create_eventbridge_providers(\n    app_model: AppModel,\n    graph: AppGraph,\n) -> tuple[EventBridgeProvider, dict[str, Provider]]:\n    \"\"\"Create EventBridge providers from the app model.\n\n    Always returns a provider (even with no CDK buses) so the EventBridge\n    HTTP endpoint is available for Terraform/CLI event bus creation.\n    \"\"\"\n    providers: dict[str, Provider] = {}\n    bus_configs = [\n        EventBusConfig(bus_name=b.name, bus_arn=b.bus_arn) for b in app_model.event_buses\n    ]\n    rule_configs = []\n    for r in app_model.event_rules:\n        targets = [\n            RuleTarget(target_id=t[\"target_id\"], arn=t[\"arn\"], input_path=t.get(\"input_path\"))\n            for t in r.targets\n        ]\n        rule_configs.append(\n            RuleConfig(\n                rule_name=r.rule_name,\n                event_bus_name=r.event_bus_name,\n                event_pattern=r.event_pattern,\n                schedule_expression=r.schedule_expression,\n                targets=targets,\n            )\n        )\n    eb_provider = EventBridgeProvider(\n        buses=bus_configs if bus_configs else None,\n        rules=rule_configs if rule_configs else None,\n    )\n    for b in app_model.event_buses:\n        node_id = _find_node_id(graph, NodeType.EVENT_BUS, b.name)\n        if node_id:\n            providers[node_id] = eb_provider\n    return eb_provider, providers\n\n\ndef _create_stepfunctions_providers(\n    app_model: AppModel,\n    graph: AppGraph,\n) -> tuple[StepFunctionsProvider, dict[str, Provider]]:\n    \"\"\"Create Step Functions providers from the app model.\n\n    Always returns a provider (even with no CDK state machines) so the\n    Step Functions HTTP endpoint is available for Terraform/CLI creation.\n    \"\"\"\n    providers: dict[str, Provider] = {}\n    sm_configs = []\n    for sm in app_model.state_machines:\n        wf_type = WorkflowType.EXPRESS if sm.workflow_type == \"EXPRESS\" else WorkflowType.STANDARD\n        sm_configs.append(\n            StateMachineConfig(\n                name=sm.name,\n                definition=sm.definition,\n                workflow_type=wf_type,\n                role_arn=sm.role_arn,\n                definition_substitutions=sm.definition_substitutions,\n            )\n        )\n    sf_provider = StepFunctionsProvider(\n        state_machines=sm_configs if sm_configs else None,\n    )\n    for sm in app_model.state_machines:\n        node_id = _find_node_id(graph, NodeType.STATE_MACHINE, sm.name)\n        if node_id:\n            providers[node_id] = sf_provider\n    return sf_provider, providers\n\n\ndef _create_ecs_providers(\n    app_model: AppModel,\n    graph: AppGraph,\n) -> tuple[EcsProvider, dict[str, Provider]]:\n    \"\"\"Create ECS service providers from the app model.\n\n    Always returns a provider (even with no CDK services).\n    \"\"\"\n    providers: dict[str, Provider] = {}\n    ecs_provider = EcsProvider(\n        services=app_model.ecs_services if app_model.ecs_services else None,\n    )\n    for svc in app_model.ecs_services:\n        svc_name = getattr(svc, \"service_name\", str(id(svc)))\n        node_id = _find_node_id(graph, NodeType.ECS_SERVICE, svc_name)\n        if node_id:\n            providers[node_id] = ecs_provider\n    return ecs_provider, providers\n\n\ndef _create_cognito_providers(\n    app_model: AppModel,\n    data_dir: Path,\n    compute_providers: dict[str, ICompute],\n) -> tuple[CognitoProvider, dict[str, Provider]]:\n    \"\"\"Create Cognito user pool providers from the app model.\n\n    Always returns a provider (even with no CDK user pools) so the\n    Cognito HTTP endpoint is available for Terraform/CLI user pool creation.\n    \"\"\"\n    providers: dict[str, Provider] = {}\n    if not app_model.user_pools:\n        pool_config = UserPoolConfig(\n            user_pool_id=\"us-east-1_default\",\n            user_pool_name=\"default\",\n        )\n        cognito_provider = CognitoProvider(data_dir=data_dir, config=pool_config)\n        return cognito_provider, providers\n    # Use the first user pool (multi-pool support can be added later)\n    pool = app_model.user_pools[0]\n    pw = pool.password_policy\n    password_policy = PasswordPolicy(\n        minimum_length=int(pw.get(\"MinimumLength\", 8)),\n        require_lowercase=bool(pw.get(\"RequireLowercase\", True)),\n        require_uppercase=bool(pw.get(\"RequireUppercase\", True)),\n        require_digits=bool(pw.get(\"RequireNumbers\", pw.get(\"RequireDigits\", True))),\n        require_symbols=bool(pw.get(\"RequireSymbols\", False)),\n    )\n    pool_config = UserPoolConfig(\n        user_pool_id=f\"us-east-1_{pool.logical_id}\",\n        user_pool_name=pool.user_pool_name,\n        password_policy=password_policy,\n        auto_confirm=pool.auto_confirm,\n        client_id=pool.client_id or \"local-client-id\",\n        pre_authentication_trigger=pool.pre_auth_trigger,\n        post_confirmation_trigger=pool.post_confirm_trigger,\n    )\n    trigger_funcs = {}\n    if pool.pre_auth_trigger and pool.pre_auth_trigger in compute_providers:\n        trigger_funcs[\"PreAuthentication\"] = compute_providers[pool.pre_auth_trigger]\n    if pool.post_confirm_trigger and pool.post_confirm_trigger in compute_providers:\n        trigger_funcs[\"PostConfirmation\"] = compute_providers[pool.post_confirm_trigger]\n    cognito_provider = CognitoProvider(\n        data_dir=data_dir, config=pool_config, trigger_functions=trigger_funcs or None\n    )\n    providers[f\"__cognito_{pool.logical_id}__\"] = cognito_provider\n    return cognito_provider, providers\n\n\ndef _wire_remaining_providers(\n    app_model: AppModel,\n    graph: AppGraph,\n    providers: dict[str, Provider],\n    compute_providers: dict[str, ICompute],\n    sqs_provider: SqsProvider,\n    local_endpoints: dict[str, str],\n    data_dir: Path,\n    api_port: int,\n    *,\n    sns_port: int,\n    eb_port: int,\n    sf_port: int,\n    cognito_port: int,\n) -> tuple[\n    SnsProvider,\n    EventBridgeProvider,\n    StepFunctionsProvider,\n    CognitoProvider,\n]:\n    \"\"\"Wire messaging, cognito, and API Gateway providers.\"\"\"\n    sns_provider, sns_providers = _create_sns_providers(app_model, graph)\n    providers.update(sns_providers)\n    sns_provider.set_compute_providers(compute_providers)\n    sns_provider.set_queue_provider(sqs_provider)\n    local_endpoints[\"sns\"] = f\"http://127.0.0.1:{sns_port}\"\n\n    eb_provider, eb_providers = _create_eventbridge_providers(app_model, graph)\n    providers.update(eb_providers)\n    eb_provider.set_compute_providers(compute_providers)\n    local_endpoints[\"events\"] = f\"http://127.0.0.1:{eb_port}\"\n\n    sf_provider, sf_providers = _create_stepfunctions_providers(app_model, graph)\n    providers.update(sf_providers)\n    sf_provider.set_compute_providers(compute_providers)\n    local_endpoints[\"stepfunctions\"] = f\"http://127.0.0.1:{sf_port}\"\n\n    cognito_provider, cognito_providers = _create_cognito_providers(\n        app_model, data_dir, compute_providers\n    )\n    providers.update(cognito_providers)\n    local_endpoints[\"cognito-idp\"] = f\"http://127.0.0.1:{cognito_port}\"\n\n    api_provider, api_providers = _create_api_providers(\n        app_model, graph, compute_providers, api_port\n    )\n    providers.update(api_providers)\n\n    return sns_provider, eb_provider, sf_provider, cognito_provider\n\n\ndef _create_providers(\n    app_model: AppModel,\n    graph: AppGraph,\n    config: LdkConfig,\n    data_dir: Path,\n) -> tuple[dict[str, Provider], dict[str, ICompute]]:\n    \"\"\"Instantiate providers from the parsed app model.\n\n    Returns a tuple of (provider map, compute_providers).\n    \"\"\"\n    providers: dict[str, Provider] = {}\n\n    # Port allocation: base+1 DynamoDB, +2 SQS, +3 S3, +4 SNS, +5 EventBridge,\n    # +6 Step Functions, +7 Cognito, +12 SSM, +13 Secrets Manager\n    dynamo_port = config.port + 1\n    sqs_port = config.port + 2\n    s3_port = config.port + 3\n    sns_port = config.port + 4\n    eb_port = config.port + 5\n    sf_port = config.port + 6\n    cognito_port = config.port + 7\n    ssm_port = config.port + 12\n    secretsmanager_port = config.port + 13\n\n    # 1. Storage providers (no deps)\n    dynamo_provider, dynamo_providers = _create_dynamo_providers(app_model, graph, data_dir)\n    providers.update(dynamo_providers)\n\n    sqs_provider, sqs_providers = _create_sqs_providers(app_model, graph)\n    providers.update(sqs_providers)\n\n    s3_provider, s3_providers = _create_s3_providers(app_model, graph, data_dir)\n    providers.update(s3_providers)\n\n    # 2. Build local_endpoints for SDK env redirection\n    local_endpoints: dict[str, str] = {}\n    local_endpoints[\"dynamodb\"] = f\"http://127.0.0.1:{dynamo_port}\"\n    local_endpoints[\"sqs\"] = f\"http://127.0.0.1:{sqs_port}\"\n    local_endpoints[\"s3\"] = f\"http://127.0.0.1:{s3_port}\"\n\n    # 3. Compute (Lambda — Node.js + Python)\n    sdk_env = build_sdk_env(local_endpoints)\n    compute_providers, compute_graph_providers = _create_compute_providers(\n        app_model, graph, local_endpoints, sdk_env\n    )\n    providers.update(compute_graph_providers)\n\n    # 4-6. Messaging, ECS, Cognito, API Gateway\n    sns_provider, eb_provider, sf_provider, cognito_provider = _wire_remaining_providers(\n        app_model,\n        graph,\n        providers,\n        compute_providers,\n        sqs_provider,\n        local_endpoints,\n        data_dir,\n        config.port,\n        sns_port=sns_port,\n        eb_port=eb_port,\n        sf_port=sf_port,\n        cognito_port=cognito_port,\n    )\n    ecs_provider, ecs_providers = _create_ecs_providers(app_model, graph)\n    providers.update(ecs_providers)\n\n    # 7. Add SSM and Secrets Manager endpoints, rebuild SDK env, update compute\n    local_endpoints[\"ssm\"] = f\"http://127.0.0.1:{ssm_port}\"\n    local_endpoints[\"secretsmanager\"] = f\"http://127.0.0.1:{secretsmanager_port}\"\n    sdk_env = build_sdk_env(local_endpoints)\n    for compute in compute_providers.values():\n        if hasattr(compute, \"_sdk_env\"):\n            compute._sdk_env = sdk_env\n\n    # 8. Create HTTP servers for each active service\n    _register_http_providers(\n        providers,\n        dynamo_provider=dynamo_provider,\n        sqs_provider=sqs_provider,\n        s3_provider=s3_provider,\n        sns_provider=sns_provider,\n        eb_provider=eb_provider,\n        sf_provider=sf_provider,\n        cognito_provider=cognito_provider,\n        ports={\n            \"dynamodb\": dynamo_port,\n            \"sqs\": sqs_port,\n            \"s3\": s3_port,\n            \"sns\": sns_port,\n            \"eventbridge\": eb_port,\n            \"stepfunctions\": sf_port,\n            \"cognito\": cognito_port,\n        },\n    )\n\n    # 9. SSM Parameter Store and Secrets Manager (pre-seeded from CloudFormation)\n    from lws.providers.secretsmanager.routes import create_secretsmanager_app\n    from lws.providers.ssm.routes import create_ssm_app\n\n    ssm_params = [\n        {\"name\": p.name, \"type\": p.type, \"value\": p.value, \"description\": p.description}\n        for p in app_model.ssm_parameters\n    ]\n    sm_secrets = [\n        {\"name\": s.name, \"description\": s.description, \"secret_string\": s.secret_string}\n        for s in app_model.secrets\n    ]\n\n    providers[\"__ssm_http__\"] = _HttpServiceProvider(\n        \"ssm-http\", lambda: create_ssm_app(ssm_params), ssm_port\n    )\n    providers[\"__secretsmanager_http__\"] = _HttpServiceProvider(\n        \"secretsmanager-http\", lambda: create_secretsmanager_app(sm_secrets), secretsmanager_port\n    )\n\n    return providers, compute_providers\n\n\ndef _register_http_providers(\n    providers: dict[str, Provider],\n    *,\n    dynamo_provider: SqliteDynamoProvider,\n    sqs_provider: SqsProvider,\n    s3_provider: S3Provider,\n    sns_provider: SnsProvider,\n    eb_provider: EventBridgeProvider,\n    sf_provider: StepFunctionsProvider,\n    cognito_provider: CognitoProvider,\n    ports: dict[str, int],\n) -> None:\n    \"\"\"Register HTTP service providers for each active backend.\"\"\"\n    from lws.providers.cognito.routes import create_cognito_app\n    from lws.providers.eventbridge.routes import create_eventbridge_app\n    from lws.providers.stepfunctions.routes import create_stepfunctions_app\n\n    http_services: list[tuple[str, Any, Callable[[], Any]]] = []\n    http_services.append(\n        (\"dynamodb\", ports[\"dynamodb\"], lambda p=dynamo_provider: create_dynamodb_app(p))\n    )\n    http_services.append(\n        (\"sqs\", ports[\"sqs\"], lambda p=sqs_provider, pt=ports[\"sqs\"]: create_sqs_app(p, pt))\n    )\n    http_services.append((\"s3\", ports[\"s3\"], lambda p=s3_provider: create_s3_app(p)))\n    http_services.append((\"sns\", ports[\"sns\"], lambda p=sns_provider: create_sns_app(p)))\n    http_services.append(\n        (\"eventbridge\", ports[\"eventbridge\"], lambda p=eb_provider: create_eventbridge_app(p))\n    )\n    http_services.append(\n        (\n            \"stepfunctions\",\n            ports[\"stepfunctions\"],\n            lambda p=sf_provider: create_stepfunctions_app(p),\n        )\n    )\n    http_services.append(\n        (\"cognito\", ports[\"cognito\"], lambda p=cognito_provider: create_cognito_app(p))\n    )\n\n    for svc_name, port, factory in http_services:\n        providers[f\"__{svc_name}_http__\"] = _HttpServiceProvider(f\"{svc_name}-http\", factory, port)\n\n\nclass _HttpServiceProvider(Provider):\n    \"\"\"Generic wrapper that runs any FastAPI app as a uvicorn-served Provider.\"\"\"\n\n    def __init__(self, service_name: str, app_factory: Callable[[], Any], port: int) -> None:\n        self._service_name = service_name\n        self._app_factory = app_factory\n        self._port = port\n        self._server: uvicorn.Server | None = None\n        self._task: asyncio.Task | None = None  # type: ignore[type-arg]\n\n    @property\n    def name(self) -> str:\n        return self._service_name\n\n    async def start(self) -> None:\n        http_app = self._app_factory()\n        uvi_config = uvicorn.Config(\n            app=http_app,\n            host=\"0.0.0.0\",\n            port=self._port,\n            log_level=\"warning\",\n        )\n        self._server = uvicorn.Server(uvi_config)\n        self._task = asyncio.create_task(self._server.serve())\n        # Wait for the server to actually bind before reporting as started\n        for _ in range(50):\n            if self._server.started:\n                break\n            await asyncio.sleep(0.1)\n\n    async def stop(self) -> None:\n        if self._server is not None:\n            self._server.should_exit = True\n        if self._task is not None:\n            await self._task\n            self._task = None\n        self._server = None\n\n    async def health_check(self) -> bool:\n        return self._server is not None\n\n\ndef _build_resource_metadata(app_model: AppModel, port: int) -> dict[str, Any]:\n    \"\"\"Build resource metadata for the ``/_ldk/resources`` endpoint.\"\"\"\n    metadata: dict[str, Any] = {\"port\": port, \"services\": {}}\n    services = metadata[\"services\"]\n    ports = _service_ports(port)\n\n    _add_api_metadata(services, app_model, port)\n    _add_service_metadata(services, app_model, ports)\n    return metadata\n\n\ndef _service_ports(port: int) -> dict[str, int]:\n    \"\"\"Return a mapping of service name to port number.\"\"\"\n    return {\n        \"dynamodb\": port + 1,\n        \"sqs\": port + 2,\n        \"s3\": port + 3,\n        \"sns\": port + 4,\n        \"events\": port + 5,\n        \"stepfunctions\": port + 6,\n        \"cognito-idp\": port + 7,\n        \"ssm\": port + 12,\n        \"secretsmanager\": port + 13,\n    }\n\n\ndef _add_api_metadata(services: dict[str, Any], app_model: AppModel, port: int) -> None:\n    \"\"\"Add API Gateway metadata to services.\"\"\"\n    if not app_model.apis:\n        return\n    routes = []\n    for api_def in app_model.apis:\n        for r in api_def.routes:\n            routes.append(\n                {\n                    \"name\": api_def.name,\n                    \"path\": r.path,\n                    \"method\": r.method,\n                    \"handler\": r.handler_name or \"\",\n                }\n            )\n    services[\"apigateway\"] = {\"port\": port, \"resources\": routes}\n\n\ndef _add_service_metadata(\n    services: dict[str, Any], app_model: AppModel, ports: dict[str, int]\n) -> None:\n    \"\"\"Add non-API service metadata to services.\"\"\"\n    if app_model.functions:\n        services[\"lambda\"] = {\n            \"resources\": [\n                {\n                    \"name\": f.name,\n                    \"runtime\": f.runtime,\n                    \"arn\": f\"arn:aws:lambda:us-east-1:000000000000:function:{f.name}\",\n                }\n                for f in app_model.functions\n            ],\n        }\n    if app_model.tables:\n        services[\"dynamodb\"] = {\n            \"port\": ports[\"dynamodb\"],\n            \"resources\": [{\"name\": t.name} for t in app_model.tables],\n        }\n    if app_model.queues:\n        sqs_port = ports[\"sqs\"]\n        services[\"sqs\"] = {\n            \"port\": sqs_port,\n            \"resources\": [\n                {\n                    \"name\": q.name,\n                    \"queue_url\": f\"http://localhost:{sqs_port}/000000000000/{q.name}\",\n                }\n                for q in app_model.queues\n            ],\n        }\n    if app_model.buckets:\n        services[\"s3\"] = {\n            \"port\": ports[\"s3\"],\n            \"resources\": [{\"name\": b.name} for b in app_model.buckets],\n        }\n    if app_model.topics:\n        services[\"sns\"] = {\n            \"port\": ports[\"sns\"],\n            \"resources\": [\n                {\n                    \"name\": t.name,\n                    \"arn\": t.topic_arn or f\"arn:aws:sns:us-east-1:000000000000:{t.name}\",\n                }\n                for t in app_model.topics\n            ],\n        }\n    if app_model.event_buses:\n        services[\"events\"] = {\n            \"port\": ports[\"events\"],\n            \"resources\": [\n                {\n                    \"name\": b.name,\n                    \"arn\": b.bus_arn or f\"arn:aws:events:us-east-1:000000000000:event-bus/{b.name}\",\n                }\n                for b in app_model.event_buses\n            ],\n        }\n    if app_model.state_machines:\n        services[\"stepfunctions\"] = {\n            \"port\": ports[\"stepfunctions\"],\n            \"resources\": [\n                {\n                    \"name\": sm.name,\n                    \"arn\": f\"arn:aws:states:us-east-1:000000000000:stateMachine:{sm.name}\",\n                }\n                for sm in app_model.state_machines\n            ],\n        }\n    if app_model.user_pools:\n        services[\"cognito-idp\"] = {\n            \"port\": ports[\"cognito-idp\"],\n            \"resources\": [\n                {\"name\": p.user_pool_name, \"user_pool_id\": f\"us-east-1_{p.logical_id}\"}\n                for p in app_model.user_pools\n            ],\n        }\n\n\ndef _mount_management_api(\n    providers: dict[str, Provider],\n    orchestrator: Orchestrator,\n    compute_providers: dict[str, ICompute],\n    port: int,\n    resource_metadata: dict[str, Any] | None = None,\n) -> None:\n    \"\"\"Mount the management API router on the API Gateway app or create a standalone one.\"\"\"\n    from fastapi import FastAPI\n\n    from lws.api.management import create_management_router\n\n    mgmt_router = create_management_router(\n        orchestrator, compute_providers, providers, resource_metadata=resource_metadata\n    )\n\n    # Try to find an existing API Gateway provider to mount on\n    for key, prov in providers.items():\n        if isinstance(prov, ApiGatewayProvider):\n            prov.app.include_router(mgmt_router)\n            return\n\n    # No API Gateway — create a standalone FastAPI app for management\n    mgmt_app = FastAPI(title=\"LDK Management\")\n    mgmt_app.include_router(mgmt_router)\n    providers[\"__management_http__\"] = _HttpServiceProvider(\n        \"management-http\", lambda: mgmt_app, port\n    )\n\n\ndef _find_node_id(graph: AppGraph, node_type: NodeType, name: str) -> str | None:\n    \"\"\"Find a graph node ID by type and name.\"\"\"\n    for nid, node in graph.nodes.items():\n        if node.node_type == node_type and nid == name:\n            return nid\n    # Fallback: check config\n    for nid, node in graph.nodes.items():\n        if node.node_type == node_type:\n            if node.config.get(\"table_name\") == name or node.config.get(\"handler\") == name:\n                return nid\n    return name\n\n\ndef _build_key_schema(raw_schema: list[dict[str, str]]) -> KeySchema:\n    \"\"\"Convert raw key schema dicts to a KeySchema dataclass.\"\"\"\n    pk: KeyAttribute | None = None\n    sk: KeyAttribute | None = None\n    for ks in raw_schema:\n        attr = KeyAttribute(name=ks.get(\"attribute_name\", \"pk\"), type=ks.get(\"type\", \"S\"))\n        if ks.get(\"key_type\") == \"RANGE\":\n            sk = attr\n        else:\n            pk = attr\n    if pk is None:\n        pk = KeyAttribute(name=\"pk\", type=\"S\")\n    return KeySchema(partition_key=pk, sort_key=sk)\n\n\ndef _build_gsi(raw_gsi: dict) -> GsiDefinition:\n    \"\"\"Convert a raw GSI dict to a GsiDefinition dataclass.\"\"\"\n    index_name = raw_gsi.get(\"index_name\", raw_gsi.get(\"IndexName\", \"gsi\"))\n    ks_raw = raw_gsi.get(\"key_schema\", [])\n    ks = _build_key_schema(ks_raw)\n    projection = raw_gsi.get(\"projection_type\", \"ALL\")\n    return GsiDefinition(index_name=index_name, key_schema=ks, projection_type=projection)\n","structuredPatch":[{"oldStart":1441,"oldLines":6,"newStart":1441,"newLines":22,"lines":["                 for p in app_model.user_pools","             ],","         }","+    if app_model.ssm_parameters:","+        services[\"ssm\"] = {","+            \"port\": ports[\"ssm\"],","+            \"resources\": [{\"name\": p.name} for p in app_model.ssm_parameters],","+        }","+    if app_model.secrets:","+        services[\"secretsmanager\"] = {","+            \"port\": ports[\"secretsmanager\"],","+            \"resources\": [","+                {","+                    \"name\": s.name,","+                    \"arn\": f\"arn:aws:secretsmanager:us-east-1:000000000000:secret:{s.name}\",","+                }","+                for s in app_model.secrets","+            ],","+        }"," "," "," def _mount_management_api("]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"4e3efb1a-8030-43f5-bd62-34fb9c1486b0"}
{"parentUuid":"7787707c-987e-45e4-a556-fd537c150234","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","message":{"model":"claude-opus-4-6","id":"msg_01Ti4JU6vPiS9WCkcYEB3mPr","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Neebsd9iBAU9sL46WCAoDg","name":"TaskUpdate","input":{"taskId":"5","status":"completed"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":573,"cache_read_input_tokens":72736,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":573},"output_tokens":26,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CY1FNsPBbQBZ9SkfVtw1y","type":"assistant","uuid":"9dfaa2f3-dc11-49f5-8bc5-fc310debfb48","timestamp":"2026-02-10T23:22:46.085Z"}
{"parentUuid":"9dfaa2f3-dc11-49f5-8bc5-fc310debfb48","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Neebsd9iBAU9sL46WCAoDg","type":"tool_result","content":"Updated task #5 status"}]},"uuid":"9b539d42-5e9c-4c37-8794-405569fcdfc8","timestamp":"2026-02-10T23:22:46.090Z","toolUseResult":{"success":true,"taskId":"5","updatedFields":["status"],"statusChange":{"from":"in_progress","to":"completed"}},"sourceToolAssistantUUID":"9dfaa2f3-dc11-49f5-8bc5-fc310debfb48"}
{"parentUuid":"9b539d42-5e9c-4c37-8794-405569fcdfc8","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","message":{"model":"claude-opus-4-6","id":"msg_01YVKsxBPKrgXbd8nUj1VVBR","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01U3FeqPM2PQ9LgiRBcHV9uN","name":"TaskUpdate","input":{"taskId":"6","status":"in_progress"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":88,"cache_read_input_tokens":73309,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":88},"output_tokens":24,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CY1FP2PAaMPX8vJj1gPd3","type":"assistant","uuid":"655533a8-6ebd-4158-b4ab-5bfeec256b0f","timestamp":"2026-02-10T23:22:48.188Z"}
{"parentUuid":"655533a8-6ebd-4158-b4ab-5bfeec256b0f","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01U3FeqPM2PQ9LgiRBcHV9uN","type":"tool_result","content":"Updated task #6 status"}]},"uuid":"e1f32176-8a53-4811-bea9-a50de2568149","timestamp":"2026-02-10T23:22:48.192Z","toolUseResult":{"success":true,"taskId":"6","updatedFields":["status"],"statusChange":{"from":"pending","to":"in_progress"}},"sourceToolAssistantUUID":"655533a8-6ebd-4158-b4ab-5bfeec256b0f"}
{"parentUuid":"e1f32176-8a53-4811-bea9-a50de2568149","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","message":{"model":"claude-opus-4-6","id":"msg_016B5yXKmsU6fKtJRfTWYmJB","type":"message","role":"assistant","content":[{"type":"text","text":"Now let's run tests and lint:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":90,"cache_read_input_tokens":73397,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":90},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CY1FPBeHVPuAiMqWTtFWH","type":"assistant","uuid":"2b418cfc-bdf9-45fe-bbfa-ed2c05d00728","timestamp":"2026-02-10T23:22:51.239Z"}
{"parentUuid":"2b418cfc-bdf9-45fe-bbfa-ed2c05d00728","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","message":{"model":"claude-opus-4-6","id":"msg_016B5yXKmsU6fKtJRfTWYmJB","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01R9tQqnVuTm3VCDwhMwN5PF","name":"Bash","input":{"command":"uv run python -m pytest tests/ -x -q 2>&1 | tail -30","description":"Run unit tests","timeout":120000}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":90,"cache_read_input_tokens":73397,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":90},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CY1FPBeHVPuAiMqWTtFWH","type":"assistant","uuid":"90097458-133a-440f-b514-c2c7f01f5c57","timestamp":"2026-02-10T23:22:52.466Z"}
{"parentUuid":"90097458-133a-440f-b514-c2c7f01f5c57","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","message":{"model":"claude-opus-4-6","id":"msg_016B5yXKmsU6fKtJRfTWYmJB","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_018WW3rhgubHZREgiLPXYsqq","name":"Bash","input":{"command":"uvx ruff check src tests 2>&1","description":"Run ruff lint","timeout":60000}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":90,"cache_read_input_tokens":73397,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":90},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CY1FPBeHVPuAiMqWTtFWH","type":"assistant","uuid":"cceede64-eb77-4b97-82db-6fd3626243c6","timestamp":"2026-02-10T23:22:53.415Z"}
{"parentUuid":"cceede64-eb77-4b97-82db-6fd3626243c6","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"progress","data":{"type":"bash_progress","output":"","fullOutput":"","elapsedTimeSeconds":2,"totalLines":0,"timeoutMs":120000},"toolUseID":"bash-progress-0","parentToolUseID":"toolu_01R9tQqnVuTm3VCDwhMwN5PF","uuid":"457ad681-0ef1-4515-8d62-8dcaa7566ba1","timestamp":"2026-02-10T23:22:54.498Z"}
{"parentUuid":"457ad681-0ef1-4515-8d62-8dcaa7566ba1","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"progress","data":{"type":"bash_progress","output":"","fullOutput":"","elapsedTimeSeconds":3,"totalLines":0,"timeoutMs":120000},"toolUseID":"bash-progress-1","parentToolUseID":"toolu_01R9tQqnVuTm3VCDwhMwN5PF","uuid":"a1d38ef7-0c80-4285-898e-39052fb48e14","timestamp":"2026-02-10T23:22:55.498Z"}
{"parentUuid":"a1d38ef7-0c80-4285-898e-39052fb48e14","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"progress","data":{"type":"bash_progress","output":"","fullOutput":"","elapsedTimeSeconds":4,"totalLines":0,"timeoutMs":120000},"toolUseID":"bash-progress-2","parentToolUseID":"toolu_01R9tQqnVuTm3VCDwhMwN5PF","uuid":"7fe47e7c-9902-4105-a612-01decb412efa","timestamp":"2026-02-10T23:22:56.505Z"}
{"parentUuid":"7fe47e7c-9902-4105-a612-01decb412efa","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"progress","data":{"type":"bash_progress","output":"","fullOutput":"","elapsedTimeSeconds":5,"totalLines":0,"timeoutMs":120000},"toolUseID":"bash-progress-3","parentToolUseID":"toolu_01R9tQqnVuTm3VCDwhMwN5PF","uuid":"19e13f43-ddd4-4f26-af06-a6e6f2758159","timestamp":"2026-02-10T23:22:57.506Z"}
{"parentUuid":"19e13f43-ddd4-4f26-af06-a6e6f2758159","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"progress","data":{"type":"bash_progress","output":"","fullOutput":"","elapsedTimeSeconds":6,"totalLines":0,"timeoutMs":120000},"toolUseID":"bash-progress-4","parentToolUseID":"toolu_01R9tQqnVuTm3VCDwhMwN5PF","uuid":"1a2e0629-3052-4e64-b7eb-ec74c88e8495","timestamp":"2026-02-10T23:22:58.508Z"}
{"parentUuid":"1a2e0629-3052-4e64-b7eb-ec74c88e8495","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"progress","data":{"type":"bash_progress","output":"","fullOutput":"","elapsedTimeSeconds":7,"totalLines":0,"timeoutMs":120000},"toolUseID":"bash-progress-5","parentToolUseID":"toolu_01R9tQqnVuTm3VCDwhMwN5PF","uuid":"494bfb3b-081e-4099-9965-af546b782261","timestamp":"2026-02-10T23:22:59.509Z"}
{"parentUuid":"494bfb3b-081e-4099-9965-af546b782261","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"progress","data":{"type":"bash_progress","output":"","fullOutput":"","elapsedTimeSeconds":8,"totalLines":0,"timeoutMs":120000},"toolUseID":"bash-progress-6","parentToolUseID":"toolu_01R9tQqnVuTm3VCDwhMwN5PF","uuid":"f9314d7d-687a-4700-a968-8f0f8218ff9a","timestamp":"2026-02-10T23:23:00.509Z"}
{"parentUuid":"f9314d7d-687a-4700-a968-8f0f8218ff9a","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"progress","data":{"type":"bash_progress","output":"","fullOutput":"","elapsedTimeSeconds":9,"totalLines":0,"timeoutMs":120000},"toolUseID":"bash-progress-7","parentToolUseID":"toolu_01R9tQqnVuTm3VCDwhMwN5PF","uuid":"d579ec24-f2bf-4760-bf78-3d770ec963c3","timestamp":"2026-02-10T23:23:01.510Z"}
{"parentUuid":"d579ec24-f2bf-4760-bf78-3d770ec963c3","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"progress","data":{"type":"bash_progress","output":"","fullOutput":"","elapsedTimeSeconds":10,"totalLines":0,"timeoutMs":120000},"toolUseID":"bash-progress-8","parentToolUseID":"toolu_01R9tQqnVuTm3VCDwhMwN5PF","uuid":"1eb822ea-7a55-4aa7-8e08-72d00611f675","timestamp":"2026-02-10T23:23:02.510Z"}
{"parentUuid":"1eb822ea-7a55-4aa7-8e08-72d00611f675","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"progress","data":{"type":"bash_progress","output":"","fullOutput":"","elapsedTimeSeconds":11,"totalLines":0,"timeoutMs":120000},"toolUseID":"bash-progress-9","parentToolUseID":"toolu_01R9tQqnVuTm3VCDwhMwN5PF","uuid":"06f85b99-4a6e-4e2c-b9b4-e0dad1b2bf20","timestamp":"2026-02-10T23:23:03.540Z"}
{"parentUuid":"06f85b99-4a6e-4e2c-b9b4-e0dad1b2bf20","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"progress","data":{"type":"bash_progress","output":"","fullOutput":"","elapsedTimeSeconds":12,"totalLines":0,"timeoutMs":120000},"toolUseID":"bash-progress-10","parentToolUseID":"toolu_01R9tQqnVuTm3VCDwhMwN5PF","uuid":"a615e7f8-4f68-48db-9ae1-071d44571507","timestamp":"2026-02-10T23:23:04.541Z"}
{"parentUuid":"a615e7f8-4f68-48db-9ae1-071d44571507","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"progress","data":{"type":"bash_progress","output":"","fullOutput":"","elapsedTimeSeconds":13,"totalLines":0,"timeoutMs":120000},"toolUseID":"bash-progress-11","parentToolUseID":"toolu_01R9tQqnVuTm3VCDwhMwN5PF","uuid":"6d0efec9-32b8-4133-8de0-0585064fef00","timestamp":"2026-02-10T23:23:05.543Z"}
{"parentUuid":"6d0efec9-32b8-4133-8de0-0585064fef00","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"progress","data":{"type":"bash_progress","output":"","fullOutput":"","elapsedTimeSeconds":14,"totalLines":0,"timeoutMs":120000},"toolUseID":"bash-progress-12","parentToolUseID":"toolu_01R9tQqnVuTm3VCDwhMwN5PF","uuid":"69e55284-cc9e-4e76-9eef-2bfc7145d4fd","timestamp":"2026-02-10T23:23:06.808Z"}
{"parentUuid":"69e55284-cc9e-4e76-9eef-2bfc7145d4fd","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"progress","data":{"type":"bash_progress","output":"","fullOutput":"","elapsedTimeSeconds":15,"totalLines":0,"timeoutMs":120000},"toolUseID":"bash-progress-13","parentToolUseID":"toolu_01R9tQqnVuTm3VCDwhMwN5PF","uuid":"730fee13-d590-4c60-bfd8-9bedf02fbf10","timestamp":"2026-02-10T23:23:07.809Z"}
{"parentUuid":"730fee13-d590-4c60-bfd8-9bedf02fbf10","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"progress","data":{"type":"bash_progress","output":"","fullOutput":"","elapsedTimeSeconds":16,"totalLines":0,"timeoutMs":120000},"toolUseID":"bash-progress-14","parentToolUseID":"toolu_01R9tQqnVuTm3VCDwhMwN5PF","uuid":"7e345bab-f0dd-45a9-865a-af00c05507d6","timestamp":"2026-02-10T23:23:08.810Z"}
{"parentUuid":"7e345bab-f0dd-45a9-865a-af00c05507d6","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"progress","data":{"type":"bash_progress","output":"","fullOutput":"","elapsedTimeSeconds":17,"totalLines":0,"timeoutMs":120000},"toolUseID":"bash-progress-15","parentToolUseID":"toolu_01R9tQqnVuTm3VCDwhMwN5PF","uuid":"56058c03-b598-4828-9ad9-e4d80073dd79","timestamp":"2026-02-10T23:23:09.811Z"}
{"parentUuid":"56058c03-b598-4828-9ad9-e4d80073dd79","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"progress","data":{"type":"bash_progress","output":"","fullOutput":"","elapsedTimeSeconds":18,"totalLines":0,"timeoutMs":120000},"toolUseID":"bash-progress-16","parentToolUseID":"toolu_01R9tQqnVuTm3VCDwhMwN5PF","uuid":"9e993f36-c7e2-400b-a0e6-db74bf678976","timestamp":"2026-02-10T23:23:10.811Z"}
{"parentUuid":"9e993f36-c7e2-400b-a0e6-db74bf678976","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"progress","data":{"type":"bash_progress","output":"","fullOutput":"","elapsedTimeSeconds":19,"totalLines":0,"timeoutMs":120000},"toolUseID":"bash-progress-17","parentToolUseID":"toolu_01R9tQqnVuTm3VCDwhMwN5PF","uuid":"15b4d72f-33b6-4ca9-a519-d0d8ce5df5db","timestamp":"2026-02-10T23:23:11.816Z"}
{"parentUuid":"15b4d72f-33b6-4ca9-a519-d0d8ce5df5db","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"progress","data":{"type":"bash_progress","output":"","fullOutput":"","elapsedTimeSeconds":20,"totalLines":0,"timeoutMs":120000},"toolUseID":"bash-progress-18","parentToolUseID":"toolu_01R9tQqnVuTm3VCDwhMwN5PF","uuid":"8cd5bf95-5830-45bb-abd7-daae47999641","timestamp":"2026-02-10T23:23:12.817Z"}
{"parentUuid":"8cd5bf95-5830-45bb-abd7-daae47999641","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"progress","data":{"type":"bash_progress","output":"","fullOutput":"","elapsedTimeSeconds":21,"totalLines":0,"timeoutMs":120000},"toolUseID":"bash-progress-19","parentToolUseID":"toolu_01R9tQqnVuTm3VCDwhMwN5PF","uuid":"631ff922-4800-4cff-8e69-ae6dba735e90","timestamp":"2026-02-10T23:23:13.817Z"}
{"parentUuid":"631ff922-4800-4cff-8e69-ae6dba735e90","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"progress","data":{"type":"bash_progress","output":"","fullOutput":"","elapsedTimeSeconds":22,"totalLines":0,"timeoutMs":120000},"toolUseID":"bash-progress-20","parentToolUseID":"toolu_01R9tQqnVuTm3VCDwhMwN5PF","uuid":"c0f78263-28b5-43e3-99fb-0baa9f8a8a3b","timestamp":"2026-02-10T23:23:14.817Z"}
{"parentUuid":"c0f78263-28b5-43e3-99fb-0baa9f8a8a3b","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"progress","data":{"type":"bash_progress","output":"","fullOutput":"","elapsedTimeSeconds":23,"totalLines":0,"timeoutMs":120000},"toolUseID":"bash-progress-21","parentToolUseID":"toolu_01R9tQqnVuTm3VCDwhMwN5PF","uuid":"479e708e-17f9-4e39-a6a6-4a1a66c02581","timestamp":"2026-02-10T23:23:15.819Z"}
{"parentUuid":"479e708e-17f9-4e39-a6a6-4a1a66c02581","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"progress","data":{"type":"bash_progress","output":"","fullOutput":"","elapsedTimeSeconds":24,"totalLines":0,"timeoutMs":120000},"toolUseID":"bash-progress-22","parentToolUseID":"toolu_01R9tQqnVuTm3VCDwhMwN5PF","uuid":"c09ed6b7-cc18-4571-8a5e-63084a9cb749","timestamp":"2026-02-10T23:23:16.820Z"}
{"parentUuid":"c09ed6b7-cc18-4571-8a5e-63084a9cb749","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"progress","data":{"type":"bash_progress","output":"","fullOutput":"","elapsedTimeSeconds":25,"totalLines":0,"timeoutMs":120000},"toolUseID":"bash-progress-23","parentToolUseID":"toolu_01R9tQqnVuTm3VCDwhMwN5PF","uuid":"a6735ed5-20d9-4f45-bf82-30e837926eda","timestamp":"2026-02-10T23:23:17.821Z"}
{"parentUuid":"a6735ed5-20d9-4f45-bf82-30e837926eda","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"progress","data":{"type":"bash_progress","output":"","fullOutput":"","elapsedTimeSeconds":26,"totalLines":0,"timeoutMs":120000},"toolUseID":"bash-progress-24","parentToolUseID":"toolu_01R9tQqnVuTm3VCDwhMwN5PF","uuid":"e76512ab-1522-4198-9ff6-0270e3305ab3","timestamp":"2026-02-10T23:23:18.822Z"}
{"parentUuid":"e76512ab-1522-4198-9ff6-0270e3305ab3","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"progress","data":{"type":"bash_progress","output":"","fullOutput":"","elapsedTimeSeconds":27,"totalLines":0,"timeoutMs":120000},"toolUseID":"bash-progress-25","parentToolUseID":"toolu_01R9tQqnVuTm3VCDwhMwN5PF","uuid":"aac90744-f1e6-470a-93ba-74dad26d7d10","timestamp":"2026-02-10T23:23:19.822Z"}
{"parentUuid":"aac90744-f1e6-470a-93ba-74dad26d7d10","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"progress","data":{"type":"bash_progress","output":"","fullOutput":"","elapsedTimeSeconds":28,"totalLines":0,"timeoutMs":120000},"toolUseID":"bash-progress-26","parentToolUseID":"toolu_01R9tQqnVuTm3VCDwhMwN5PF","uuid":"6dce755e-21cf-4f05-997b-69b1dac5438c","timestamp":"2026-02-10T23:23:20.822Z"}
{"parentUuid":"6dce755e-21cf-4f05-997b-69b1dac5438c","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"progress","data":{"type":"bash_progress","output":"","fullOutput":"","elapsedTimeSeconds":29,"totalLines":0,"timeoutMs":120000},"toolUseID":"bash-progress-27","parentToolUseID":"toolu_01R9tQqnVuTm3VCDwhMwN5PF","uuid":"257164fe-2feb-4001-ac44-d8d140ad4774","timestamp":"2026-02-10T23:23:21.823Z"}
{"parentUuid":"257164fe-2feb-4001-ac44-d8d140ad4774","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"progress","data":{"type":"bash_progress","output":"","fullOutput":"","elapsedTimeSeconds":30,"totalLines":0,"timeoutMs":120000},"toolUseID":"bash-progress-28","parentToolUseID":"toolu_01R9tQqnVuTm3VCDwhMwN5PF","uuid":"8fe7d877-604f-41c7-bc06-942c35f5b343","timestamp":"2026-02-10T23:23:22.823Z"}
{"parentUuid":"8fe7d877-604f-41c7-bc06-942c35f5b343","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"progress","data":{"type":"bash_progress","output":"","fullOutput":"","elapsedTimeSeconds":31,"totalLines":0,"timeoutMs":120000},"toolUseID":"bash-progress-29","parentToolUseID":"toolu_01R9tQqnVuTm3VCDwhMwN5PF","uuid":"dd45a0b2-cabe-4512-b71e-80e0599ec392","timestamp":"2026-02-10T23:23:23.824Z"}
{"parentUuid":"dd45a0b2-cabe-4512-b71e-80e0599ec392","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"progress","data":{"type":"bash_progress","output":"","fullOutput":"","elapsedTimeSeconds":32,"totalLines":0,"timeoutMs":120000},"toolUseID":"bash-progress-30","parentToolUseID":"toolu_01R9tQqnVuTm3VCDwhMwN5PF","uuid":"9596e004-77a8-446e-b86a-0e4e796698ea","timestamp":"2026-02-10T23:23:24.824Z"}
{"parentUuid":"9596e004-77a8-446e-b86a-0e4e796698ea","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"progress","data":{"type":"bash_progress","output":"","fullOutput":"","elapsedTimeSeconds":33,"totalLines":0,"timeoutMs":120000},"toolUseID":"bash-progress-31","parentToolUseID":"toolu_01R9tQqnVuTm3VCDwhMwN5PF","uuid":"030b6ce6-052d-4a10-a9da-13eb86900fe2","timestamp":"2026-02-10T23:23:25.825Z"}
{"parentUuid":"030b6ce6-052d-4a10-a9da-13eb86900fe2","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"progress","data":{"type":"bash_progress","output":"","fullOutput":"","elapsedTimeSeconds":34,"totalLines":0,"timeoutMs":120000},"toolUseID":"bash-progress-32","parentToolUseID":"toolu_01R9tQqnVuTm3VCDwhMwN5PF","uuid":"44ee04cc-598f-45dc-aaf1-e02928ee6a5f","timestamp":"2026-02-10T23:23:26.833Z"}
{"parentUuid":"44ee04cc-598f-45dc-aaf1-e02928ee6a5f","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"progress","data":{"type":"bash_progress","output":"","fullOutput":"","elapsedTimeSeconds":35,"totalLines":0,"timeoutMs":120000},"toolUseID":"bash-progress-33","parentToolUseID":"toolu_01R9tQqnVuTm3VCDwhMwN5PF","uuid":"177c0c31-c739-429f-a7d6-17c2fab24db5","timestamp":"2026-02-10T23:23:27.834Z"}
{"parentUuid":"90097458-133a-440f-b514-c2c7f01f5c57","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01R9tQqnVuTm3VCDwhMwN5PF","type":"tool_result","content":"........................................................................ [ 56%]\n........................................................................ [ 60%]\n........................................................................ [ 65%]\n........................................................................ [ 69%]\n........................................................................ [ 73%]\n........................................................................ [ 78%]\n........................................................................ [ 82%]\n........................................................................ [ 86%]\n........................................................................ [ 91%]\n........................................................................ [ 95%]\n........................................................................ [ 99%]\n.                                                                        [100%]\n=============================== warnings summary ===============================\ntests/integration/test_lws_status.py::TestLwsStatusIntegration::test_status_returns_provider_info\n  /Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services/.venv/lib/python3.11/site-packages/websockets/legacy/__init__.py:6: DeprecationWarning: websockets.legacy is deprecated; see https://websockets.readthedocs.io/en/stable/howto/upgrade.html for upgrade instructions\n    warnings.warn(  # deprecated in 14.0 - 2024-11-09\n\ntests/integration/test_lws_status.py::TestLwsStatusIntegration::test_status_returns_provider_info\n  /Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services/.venv/lib/python3.11/site-packages/uvicorn/protocols/websockets/websockets_impl.py:17: DeprecationWarning: websockets.server.WebSocketServerProtocol is deprecated\n    from websockets.server import WebSocketServerProtocol\n\ntests/unit/providers/test_python_compute_python_compute_invoke.py::TestPythonComputeInvoke::test_invoke_timeout_kills_process\ntests/unit/providers/test_python_compute_python_compute_invoke.py::TestPythonComputeInvoke::test_invoke_timeout_message_format\n  /Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services/src/lws/providers/lambda_runtime/python.py:141: RuntimeWarning: coroutine 'AsyncMockMixin._execute_mock_call' was never awaited\n    process.send_signal(signal.SIGTERM)\n  Enable tracemalloc to get traceback where the object was allocated.\n  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.\n\n-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html\n1657 passed, 4 warnings in 34.51s","is_error":false}]},"uuid":"83d02215-303f-4f97-b28b-765d0c1ef093","timestamp":"2026-02-10T23:23:28.179Z","toolUseResult":{"stdout":"........................................................................ [ 56%]\n........................................................................ [ 60%]\n........................................................................ [ 65%]\n........................................................................ [ 69%]\n........................................................................ [ 73%]\n........................................................................ [ 78%]\n........................................................................ [ 82%]\n........................................................................ [ 86%]\n........................................................................ [ 91%]\n........................................................................ [ 95%]\n........................................................................ [ 99%]\n.                                                                        [100%]\n=============================== warnings summary ===============================\ntests/integration/test_lws_status.py::TestLwsStatusIntegration::test_status_returns_provider_info\n  /Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services/.venv/lib/python3.11/site-packages/websockets/legacy/__init__.py:6: DeprecationWarning: websockets.legacy is deprecated; see https://websockets.readthedocs.io/en/stable/howto/upgrade.html for upgrade instructions\n    warnings.warn(  # deprecated in 14.0 - 2024-11-09\n\ntests/integration/test_lws_status.py::TestLwsStatusIntegration::test_status_returns_provider_info\n  /Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services/.venv/lib/python3.11/site-packages/uvicorn/protocols/websockets/websockets_impl.py:17: DeprecationWarning: websockets.server.WebSocketServerProtocol is deprecated\n    from websockets.server import WebSocketServerProtocol\n\ntests/unit/providers/test_python_compute_python_compute_invoke.py::TestPythonComputeInvoke::test_invoke_timeout_kills_process\ntests/unit/providers/test_python_compute_python_compute_invoke.py::TestPythonComputeInvoke::test_invoke_timeout_message_format\n  /Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services/src/lws/providers/lambda_runtime/python.py:141: RuntimeWarning: coroutine 'AsyncMockMixin._execute_mock_call' was never awaited\n    process.send_signal(signal.SIGTERM)\n  Enable tracemalloc to get traceback where the object was allocated.\n  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.\n\n-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html\n1657 passed, 4 warnings in 34.51s","stderr":"","interrupted":false,"isImage":false,"noOutputExpected":false},"sourceToolAssistantUUID":"90097458-133a-440f-b514-c2c7f01f5c57"}
{"parentUuid":"cceede64-eb77-4b97-82db-6fd3626243c6","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"user","message":{"role":"user","content":[{"type":"tool_result","content":"Exit code 1\nC901 `_add_service_metadata` is too complex (11 > 10)\n    --> src/lws/cli/ldk.py:1366:5\n     |\n1366 | def _add_service_metadata(\n     |     ^^^^^^^^^^^^^^^^^^^^^\n1367 |     services: dict[str, Any], app_model: AppModel, ports: dict[str, int]\n1368 | ) -> None:\n     |\n\nC901 `_build_resource_map` is too complex (14 > 10)\n   --> src/lws/parser/assembly.py:285:5\n    |\n285 | def _build_resource_map(resources: list[CfnResource]) -> dict[str, str]:\n    |     ^^^^^^^^^^^^^^^^^^^\n286 |     \"\"\"Build a Ref resource_map so intrinsic ``Ref`` calls resolve to useful local values.\n    |\n\nI001 [*] Import block is un-sorted or un-formatted\n --> src/lws/runtime/sdk_env.py:7:1\n  |\n5 | \"\"\"\n6 |\n7 | from __future__ import annotations\n  | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\nhelp: Organize imports\n\nFound 3 errors.\n[*] 1 fixable with the `--fix` option.","is_error":true,"tool_use_id":"toolu_018WW3rhgubHZREgiLPXYsqq"}]},"uuid":"987283d0-d4d8-4a1e-aeb1-ef77fd5c444f","timestamp":"2026-02-10T23:23:28.973Z","toolUseResult":"Error: Exit code 1\nC901 `_add_service_metadata` is too complex (11 > 10)\n    --> src/lws/cli/ldk.py:1366:5\n     |\n1366 | def _add_service_metadata(\n     |     ^^^^^^^^^^^^^^^^^^^^^\n1367 |     services: dict[str, Any], app_model: AppModel, ports: dict[str, int]\n1368 | ) -> None:\n     |\n\nC901 `_build_resource_map` is too complex (14 > 10)\n   --> src/lws/parser/assembly.py:285:5\n    |\n285 | def _build_resource_map(resources: list[CfnResource]) -> dict[str, str]:\n    |     ^^^^^^^^^^^^^^^^^^^\n286 |     \"\"\"Build a Ref resource_map so intrinsic ``Ref`` calls resolve to useful local values.\n    |\n\nI001 [*] Import block is un-sorted or un-formatted\n --> src/lws/runtime/sdk_env.py:7:1\n  |\n5 | \"\"\"\n6 |\n7 | from __future__ import annotations\n  | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\nhelp: Organize imports\n\nFound 3 errors.\n[*] 1 fixable with the `--fix` option.","sourceToolAssistantUUID":"cceede64-eb77-4b97-82db-6fd3626243c6"}
{"parentUuid":"987283d0-d4d8-4a1e-aeb1-ef77fd5c444f","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","message":{"model":"claude-opus-4-6","id":"msg_014mYxXwEn3PEnnmPKeJ2spZ","type":"message","role":"assistant","content":[{"type":"text","text":"All 1657 tests pass. There are two complexity warnings from our additions. Let me fix those by extracting helper functions. The `sdk_env.py` import issue is pre-existing."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1232,"cache_read_input_tokens":73487,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1232},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CY1FSC3RhHZJqxPaHHr8Q","type":"assistant","uuid":"1a232e63-63ef-4a4b-8fff-01184c663294","timestamp":"2026-02-10T23:23:32.242Z"}
{"parentUuid":"1a232e63-63ef-4a4b-8fff-01184c663294","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","message":{"model":"claude-opus-4-6","id":"msg_014mYxXwEn3PEnnmPKeJ2spZ","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01RzKFxt9356M7Tzqhuw7t99","name":"Read","input":{"file_path":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services/src/lws/parser/assembly.py","offset":280,"limit":40}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1232,"cache_read_input_tokens":73487,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1232},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CY1FSC3RhHZJqxPaHHr8Q","type":"assistant","uuid":"bec84c86-71c4-4fdb-86f4-a1dcc1a69460","timestamp":"2026-02-10T23:23:33.297Z"}
{"parentUuid":"bec84c86-71c4-4fdb-86f4-a1dcc1a69460","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"callback"},"parentToolUseID":"toolu_01RzKFxt9356M7Tzqhuw7t99","toolUseID":"toolu_01RzKFxt9356M7Tzqhuw7t99","timestamp":"2026-02-10T23:23:33.304Z","uuid":"b77b3e4f-d82f-419e-a91f-a7ee0f10d370"}
{"parentUuid":"bec84c86-71c4-4fdb-86f4-a1dcc1a69460","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01RzKFxt9356M7Tzqhuw7t99","type":"tool_result","content":"   280→        raw_template = json.load(fh)\n   281→    ecs_services = _collect_ecs_services(raw_template)\n   282→    model.ecs_services.extend(ecs_services)\n   283→\n   284→\n   285→def _build_resource_map(resources: list[CfnResource]) -> dict[str, str]:\n   286→    \"\"\"Build a Ref resource_map so intrinsic ``Ref`` calls resolve to useful local values.\n   287→\n   288→    In real CloudFormation:\n   289→    - ``Ref`` on an ``AWS::SQS::Queue`` returns the queue URL.\n   290→    - ``Ref`` on an ``AWS::DynamoDB::Table`` returns the table name.\n   291→\n   292→    We reproduce this behaviour with deterministic local placeholders so that\n   293→    Lambda environment variables like ``QUEUE_URL`` and ``TABLE_NAME`` resolve\n   294→    to values the local providers can understand.\n   295→    \"\"\"\n   296→    resource_map: dict[str, str] = {}\n   297→    for r in resources:\n   298→        if r.resource_type == \"AWS::SQS::Queue\":\n   299→            queue_name = r.properties.get(\"QueueName\", r.logical_id)\n   300→            if isinstance(queue_name, str):\n   301→                # Use ARN format so the SDK connects via AWS_ENDPOINT_URL_SQS\n   302→                # rather than trying to resolve the QueueUrl as a hostname.\n   303→                resource_map[r.logical_id] = f\"arn:ldk:sqs:local:000000000000:queue/{queue_name}\"\n   304→        elif r.resource_type == \"AWS::DynamoDB::Table\":\n   305→            # Ref returns the table name.\n   306→            table_name = r.properties.get(\"TableName\", r.logical_id)\n   307→            if isinstance(table_name, str):\n   308→                resource_map[r.logical_id] = table_name\n   309→        elif r.resource_type == \"AWS::S3::Bucket\":\n   310→            # Ref returns the bucket name.\n   311→            bucket_name = r.properties.get(\"BucketName\", r.logical_id)\n   312→            if isinstance(bucket_name, str):\n   313→                resource_map[r.logical_id] = bucket_name\n   314→            else:\n   315→                resource_map[r.logical_id] = r.logical_id\n   316→        elif r.resource_type == \"AWS::SNS::Topic\":\n   317→            # Ref returns the topic ARN.\n   318→            topic_name = r.properties.get(\"TopicName\", r.logical_id)\n   319→            if isinstance(topic_name, str):\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"668ac6e5-c24b-4715-8335-086885750672","timestamp":"2026-02-10T23:23:33.303Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services/src/lws/parser/assembly.py","content":"        raw_template = json.load(fh)\n    ecs_services = _collect_ecs_services(raw_template)\n    model.ecs_services.extend(ecs_services)\n\n\ndef _build_resource_map(resources: list[CfnResource]) -> dict[str, str]:\n    \"\"\"Build a Ref resource_map so intrinsic ``Ref`` calls resolve to useful local values.\n\n    In real CloudFormation:\n    - ``Ref`` on an ``AWS::SQS::Queue`` returns the queue URL.\n    - ``Ref`` on an ``AWS::DynamoDB::Table`` returns the table name.\n\n    We reproduce this behaviour with deterministic local placeholders so that\n    Lambda environment variables like ``QUEUE_URL`` and ``TABLE_NAME`` resolve\n    to values the local providers can understand.\n    \"\"\"\n    resource_map: dict[str, str] = {}\n    for r in resources:\n        if r.resource_type == \"AWS::SQS::Queue\":\n            queue_name = r.properties.get(\"QueueName\", r.logical_id)\n            if isinstance(queue_name, str):\n                # Use ARN format so the SDK connects via AWS_ENDPOINT_URL_SQS\n                # rather than trying to resolve the QueueUrl as a hostname.\n                resource_map[r.logical_id] = f\"arn:ldk:sqs:local:000000000000:queue/{queue_name}\"\n        elif r.resource_type == \"AWS::DynamoDB::Table\":\n            # Ref returns the table name.\n            table_name = r.properties.get(\"TableName\", r.logical_id)\n            if isinstance(table_name, str):\n                resource_map[r.logical_id] = table_name\n        elif r.resource_type == \"AWS::S3::Bucket\":\n            # Ref returns the bucket name.\n            bucket_name = r.properties.get(\"BucketName\", r.logical_id)\n            if isinstance(bucket_name, str):\n                resource_map[r.logical_id] = bucket_name\n            else:\n                resource_map[r.logical_id] = r.logical_id\n        elif r.resource_type == \"AWS::SNS::Topic\":\n            # Ref returns the topic ARN.\n            topic_name = r.properties.get(\"TopicName\", r.logical_id)\n            if isinstance(topic_name, str):","numLines":40,"startLine":280,"totalLines":765}},"sourceToolAssistantUUID":"bec84c86-71c4-4fdb-86f4-a1dcc1a69460"}
{"parentUuid":"668ac6e5-c24b-4715-8335-086885750672","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","message":{"model":"claude-opus-4-6","id":"msg_013iNgeybBRE9vHHzWuLGSTc","type":"message","role":"assistant","content":[{"type":"text","text":"I'll refactor `_build_resource_map` to use a dispatch approach to reduce complexity:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":963,"cache_read_input_tokens":74719,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":963},"output_tokens":2,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CY1FSWYAWVYgMM3cNV45Y","type":"assistant","uuid":"4604aa92-68f7-4c3f-978d-14b219aa7445","timestamp":"2026-02-10T23:23:35.679Z"}
{"parentUuid":"4604aa92-68f7-4c3f-978d-14b219aa7445","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","message":{"model":"claude-opus-4-6","id":"msg_013iNgeybBRE9vHHzWuLGSTc","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01YB1waTKYbc2gQxWne5NctT","name":"Edit","input":{"replace_all":false,"file_path":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services/src/lws/parser/assembly.py","old_string":"def _build_resource_map(resources: list[CfnResource]) -> dict[str, str]:\n    \"\"\"Build a Ref resource_map so intrinsic ``Ref`` calls resolve to useful local values.\n\n    In real CloudFormation:\n    - ``Ref`` on an ``AWS::SQS::Queue`` returns the queue URL.\n    - ``Ref`` on an ``AWS::DynamoDB::Table`` returns the table name.\n\n    We reproduce this behaviour with deterministic local placeholders so that\n    Lambda environment variables like ``QUEUE_URL`` and ``TABLE_NAME`` resolve\n    to values the local providers can understand.\n    \"\"\"\n    resource_map: dict[str, str] = {}\n    for r in resources:\n        if r.resource_type == \"AWS::SQS::Queue\":\n            queue_name = r.properties.get(\"QueueName\", r.logical_id)\n            if isinstance(queue_name, str):\n                # Use ARN format so the SDK connects via AWS_ENDPOINT_URL_SQS\n                # rather than trying to resolve the QueueUrl as a hostname.\n                resource_map[r.logical_id] = f\"arn:ldk:sqs:local:000000000000:queue/{queue_name}\"\n        elif r.resource_type == \"AWS::DynamoDB::Table\":\n            # Ref returns the table name.\n            table_name = r.properties.get(\"TableName\", r.logical_id)\n            if isinstance(table_name, str):\n                resource_map[r.logical_id] = table_name\n        elif r.resource_type == \"AWS::S3::Bucket\":\n            # Ref returns the bucket name.\n            bucket_name = r.properties.get(\"BucketName\", r.logical_id)\n            if isinstance(bucket_name, str):\n                resource_map[r.logical_id] = bucket_name\n            else:\n                resource_map[r.logical_id] = r.logical_id\n        elif r.resource_type == \"AWS::SNS::Topic\":\n            # Ref returns the topic ARN.\n            topic_name = r.properties.get(\"TopicName\", r.logical_id)\n            if isinstance(topic_name, str):\n                resource_map[r.logical_id] = f\"arn:ldk:sns:local:000000000000:{topic_name}\"\n        elif r.resource_type == \"AWS::SSM::Parameter\":\n            name = r.properties.get(\"Name\", r.logical_id)\n            if isinstance(name, str):\n                resource_map[r.logical_id] = name\n        elif r.resource_type == \"AWS::SecretsManager::Secret\":\n            name = r.properties.get(\"Name\", r.logical_id)\n            if isinstance(name, str):\n                resource_map[r.logical_id] = (\n                    f\"arn:aws:secretsmanager:us-east-1:000000000000:secret:{name}\"\n                )\n    return resource_map","new_string":"def _build_resource_map(resources: list[CfnResource]) -> dict[str, str]:\n    \"\"\"Build a Ref resource_map so intrinsic ``Ref`` calls resolve to useful local values.\n\n    In real CloudFormation:\n    - ``Ref`` on an ``AWS::SQS::Queue`` returns the queue URL.\n    - ``Ref`` on an ``AWS::DynamoDB::Table`` returns the table name.\n\n    We reproduce this behaviour with deterministic local placeholders so that\n    Lambda environment variables like ``QUEUE_URL`` and ``TABLE_NAME`` resolve\n    to values the local providers can understand.\n    \"\"\"\n    resource_map: dict[str, str] = {}\n    for r in resources:\n        ref = _resolve_ref_value(r)\n        if ref is not None:\n            resource_map[r.logical_id] = ref\n    return resource_map\n\n\ndef _resolve_ref_value(r: CfnResource) -> str | None:\n    \"\"\"Return the local Ref value for a single CloudFormation resource, or None.\"\"\"\n    if r.resource_type == \"AWS::SQS::Queue\":\n        queue_name = r.properties.get(\"QueueName\", r.logical_id)\n        if isinstance(queue_name, str):\n            return f\"arn:ldk:sqs:local:000000000000:queue/{queue_name}\"\n    elif r.resource_type == \"AWS::DynamoDB::Table\":\n        table_name = r.properties.get(\"TableName\", r.logical_id)\n        if isinstance(table_name, str):\n            return table_name\n    elif r.resource_type == \"AWS::S3::Bucket\":\n        bucket_name = r.properties.get(\"BucketName\", r.logical_id)\n        return bucket_name if isinstance(bucket_name, str) else r.logical_id\n    elif r.resource_type == \"AWS::SNS::Topic\":\n        topic_name = r.properties.get(\"TopicName\", r.logical_id)\n        if isinstance(topic_name, str):\n            return f\"arn:ldk:sns:local:000000000000:{topic_name}\"\n    elif r.resource_type == \"AWS::SSM::Parameter\":\n        name = r.properties.get(\"Name\", r.logical_id)\n        if isinstance(name, str):\n            return name\n    elif r.resource_type == \"AWS::SecretsManager::Secret\":\n        name = r.properties.get(\"Name\", r.logical_id)\n        if isinstance(name, str):\n            return f\"arn:aws:secretsmanager:us-east-1:000000000000:secret:{name}\"\n    return None"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":963,"cache_read_input_tokens":74719,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":963},"output_tokens":2,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CY1FSWYAWVYgMM3cNV45Y","type":"assistant","uuid":"90bd84bc-bcee-4c7c-ad2d-ef8b956fd2c8","timestamp":"2026-02-10T23:23:47.501Z"}
{"parentUuid":"90bd84bc-bcee-4c7c-ad2d-ef8b956fd2c8","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"callback"},"parentToolUseID":"toolu_01YB1waTKYbc2gQxWne5NctT","toolUseID":"toolu_01YB1waTKYbc2gQxWne5NctT","timestamp":"2026-02-10T23:23:47.505Z","uuid":"c2810cdc-a3fc-4686-ab2b-932d27c31b9d"}
{"parentUuid":"90bd84bc-bcee-4c7c-ad2d-ef8b956fd2c8","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01YB1waTKYbc2gQxWne5NctT","type":"tool_result","content":"The file /Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services/src/lws/parser/assembly.py has been updated successfully."}]},"uuid":"321574c2-49f5-42eb-8e7a-70a9287eeee5","timestamp":"2026-02-10T23:23:47.505Z","toolUseResult":{"filePath":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services/src/lws/parser/assembly.py","oldString":"def _build_resource_map(resources: list[CfnResource]) -> dict[str, str]:\n    \"\"\"Build a Ref resource_map so intrinsic ``Ref`` calls resolve to useful local values.\n\n    In real CloudFormation:\n    - ``Ref`` on an ``AWS::SQS::Queue`` returns the queue URL.\n    - ``Ref`` on an ``AWS::DynamoDB::Table`` returns the table name.\n\n    We reproduce this behaviour with deterministic local placeholders so that\n    Lambda environment variables like ``QUEUE_URL`` and ``TABLE_NAME`` resolve\n    to values the local providers can understand.\n    \"\"\"\n    resource_map: dict[str, str] = {}\n    for r in resources:\n        if r.resource_type == \"AWS::SQS::Queue\":\n            queue_name = r.properties.get(\"QueueName\", r.logical_id)\n            if isinstance(queue_name, str):\n                # Use ARN format so the SDK connects via AWS_ENDPOINT_URL_SQS\n                # rather than trying to resolve the QueueUrl as a hostname.\n                resource_map[r.logical_id] = f\"arn:ldk:sqs:local:000000000000:queue/{queue_name}\"\n        elif r.resource_type == \"AWS::DynamoDB::Table\":\n            # Ref returns the table name.\n            table_name = r.properties.get(\"TableName\", r.logical_id)\n            if isinstance(table_name, str):\n                resource_map[r.logical_id] = table_name\n        elif r.resource_type == \"AWS::S3::Bucket\":\n            # Ref returns the bucket name.\n            bucket_name = r.properties.get(\"BucketName\", r.logical_id)\n            if isinstance(bucket_name, str):\n                resource_map[r.logical_id] = bucket_name\n            else:\n                resource_map[r.logical_id] = r.logical_id\n        elif r.resource_type == \"AWS::SNS::Topic\":\n            # Ref returns the topic ARN.\n            topic_name = r.properties.get(\"TopicName\", r.logical_id)\n            if isinstance(topic_name, str):\n                resource_map[r.logical_id] = f\"arn:ldk:sns:local:000000000000:{topic_name}\"\n        elif r.resource_type == \"AWS::SSM::Parameter\":\n            name = r.properties.get(\"Name\", r.logical_id)\n            if isinstance(name, str):\n                resource_map[r.logical_id] = name\n        elif r.resource_type == \"AWS::SecretsManager::Secret\":\n            name = r.properties.get(\"Name\", r.logical_id)\n            if isinstance(name, str):\n                resource_map[r.logical_id] = (\n                    f\"arn:aws:secretsmanager:us-east-1:000000000000:secret:{name}\"\n                )\n    return resource_map","newString":"def _build_resource_map(resources: list[CfnResource]) -> dict[str, str]:\n    \"\"\"Build a Ref resource_map so intrinsic ``Ref`` calls resolve to useful local values.\n\n    In real CloudFormation:\n    - ``Ref`` on an ``AWS::SQS::Queue`` returns the queue URL.\n    - ``Ref`` on an ``AWS::DynamoDB::Table`` returns the table name.\n\n    We reproduce this behaviour with deterministic local placeholders so that\n    Lambda environment variables like ``QUEUE_URL`` and ``TABLE_NAME`` resolve\n    to values the local providers can understand.\n    \"\"\"\n    resource_map: dict[str, str] = {}\n    for r in resources:\n        ref = _resolve_ref_value(r)\n        if ref is not None:\n            resource_map[r.logical_id] = ref\n    return resource_map\n\n\ndef _resolve_ref_value(r: CfnResource) -> str | None:\n    \"\"\"Return the local Ref value for a single CloudFormation resource, or None.\"\"\"\n    if r.resource_type == \"AWS::SQS::Queue\":\n        queue_name = r.properties.get(\"QueueName\", r.logical_id)\n        if isinstance(queue_name, str):\n            return f\"arn:ldk:sqs:local:000000000000:queue/{queue_name}\"\n    elif r.resource_type == \"AWS::DynamoDB::Table\":\n        table_name = r.properties.get(\"TableName\", r.logical_id)\n        if isinstance(table_name, str):\n            return table_name\n    elif r.resource_type == \"AWS::S3::Bucket\":\n        bucket_name = r.properties.get(\"BucketName\", r.logical_id)\n        return bucket_name if isinstance(bucket_name, str) else r.logical_id\n    elif r.resource_type == \"AWS::SNS::Topic\":\n        topic_name = r.properties.get(\"TopicName\", r.logical_id)\n        if isinstance(topic_name, str):\n            return f\"arn:ldk:sns:local:000000000000:{topic_name}\"\n    elif r.resource_type == \"AWS::SSM::Parameter\":\n        name = r.properties.get(\"Name\", r.logical_id)\n        if isinstance(name, str):\n            return name\n    elif r.resource_type == \"AWS::SecretsManager::Secret\":\n        name = r.properties.get(\"Name\", r.logical_id)\n        if isinstance(name, str):\n            return f\"arn:aws:secretsmanager:us-east-1:000000000000:secret:{name}\"\n    return None","originalFile":"\"\"\"Assembly orchestrator -- top-level entry point for CDK output parsing.\n\nTies together tree parsing, template parsing, reference resolution and\nasset location to produce a single ``AppModel`` that the rest of the\nsystem can consume.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport json\nimport logging\nfrom dataclasses import dataclass, field\nfrom pathlib import Path\nfrom typing import Any\n\nfrom lws.parser.asset_parser import parse_assets\nfrom lws.parser.ref_resolver import RefResolver\nfrom lws.parser.template_parser import (\n    CfnResource,\n    extract_api_routes,\n    extract_dynamo_tables,\n    extract_lambda_functions,\n    parse_template,\n)\nfrom lws.parser.tree_parser import parse_tree\n\nlogger = logging.getLogger(__name__)\n\n# ---------------------------------------------------------------------------\n# Domain model dataclasses\n# ---------------------------------------------------------------------------\n\n\n@dataclass\nclass LambdaFunction:\n    \"\"\"Parsed Lambda function ready for local execution.\"\"\"\n\n    name: str\n    handler: str\n    runtime: str\n    code_path: Path | None = None\n    timeout: int = 30\n    memory: int = 128\n    environment: dict[str, str] = field(default_factory=dict)\n\n    @property\n    def logical_id(self) -> str:\n        return self.name\n\n\n@dataclass\nclass DynamoTable:\n    \"\"\"Parsed DynamoDB table definition.\"\"\"\n\n    name: str\n    key_schema: list[dict[str, str]] = field(default_factory=list)\n    gsi_definitions: list[dict[str, Any]] = field(default_factory=list)\n\n    @property\n    def logical_id(self) -> str:\n        return self.name\n\n    @property\n    def table_name(self) -> str:\n        return self.name\n\n\n@dataclass\nclass ApiRoute:\n    \"\"\"A single API Gateway route.\"\"\"\n\n    method: str\n    path: str\n    handler_name: str | None = None\n\n\n@dataclass\nclass ApiDefinition:\n    \"\"\"A collection of routes making up an API.\"\"\"\n\n    name: str = \"default\"\n    routes: list[ApiRoute] = field(default_factory=list)\n\n    @property\n    def logical_id(self) -> str:\n        return self.name\n\n\n@dataclass\nclass SqsQueue:\n    \"\"\"Parsed SQS queue definition.\"\"\"\n\n    name: str\n    is_fifo: bool = False\n    visibility_timeout: int = 30\n    content_based_dedup: bool = False\n    redrive_target: str | None = None\n    max_receive_count: int = 5\n\n\n@dataclass\nclass S3Bucket:\n    \"\"\"Parsed S3 bucket definition.\"\"\"\n\n    name: str\n\n\n@dataclass\nclass SnsTopic:\n    \"\"\"Parsed SNS topic definition.\"\"\"\n\n    name: str\n    topic_arn: str = \"\"\n\n\n@dataclass\nclass EventBus:\n    \"\"\"Parsed EventBridge event bus definition.\"\"\"\n\n    name: str\n    bus_arn: str = \"\"\n\n\n@dataclass\nclass EventRule:\n    \"\"\"Parsed EventBridge rule definition.\"\"\"\n\n    rule_name: str\n    event_bus_name: str = \"default\"\n    event_pattern: dict[str, Any] | None = None\n    schedule_expression: str | None = None\n    targets: list[dict[str, Any]] = field(default_factory=list)\n\n\n@dataclass\nclass StateMachine:\n    \"\"\"Parsed Step Functions state machine definition.\"\"\"\n\n    name: str\n    definition: str | dict[str, Any] = \"\"\n    workflow_type: str = \"STANDARD\"\n    role_arn: str = \"\"\n    definition_substitutions: dict[str, str] = field(default_factory=dict)\n\n\n@dataclass\nclass CognitoUserPool:\n    \"\"\"Parsed Cognito user pool definition.\"\"\"\n\n    logical_id: str\n    user_pool_name: str = \"default\"\n    auto_confirm: bool = True\n    password_policy: dict[str, Any] = field(default_factory=dict)\n    pre_auth_trigger: str | None = None\n    post_confirm_trigger: str | None = None\n    client_id: str = \"\"\n\n\n@dataclass\nclass SsmParameter:\n    \"\"\"Parsed SSM Parameter Store parameter.\"\"\"\n\n    name: str\n    type: str  # \"String\", \"StringList\", \"SecureString\"\n    value: str\n    description: str = \"\"\n\n\n@dataclass\nclass SmSecret:\n    \"\"\"Parsed Secrets Manager secret.\"\"\"\n\n    name: str\n    description: str = \"\"\n    secret_string: str | None = None\n\n\n@dataclass\nclass AppModel:\n    \"\"\"Complete parsed representation of a CDK application.\"\"\"\n\n    functions: list[LambdaFunction] = field(default_factory=list)\n    tables: list[DynamoTable] = field(default_factory=list)\n    apis: list[ApiDefinition] = field(default_factory=list)\n    queues: list[SqsQueue] = field(default_factory=list)\n    buckets: list[S3Bucket] = field(default_factory=list)\n    topics: list[SnsTopic] = field(default_factory=list)\n    event_buses: list[EventBus] = field(default_factory=list)\n    event_rules: list[EventRule] = field(default_factory=list)\n    state_machines: list[StateMachine] = field(default_factory=list)\n    user_pools: list[CognitoUserPool] = field(default_factory=list)\n    ecs_services: list[Any] = field(default_factory=list)\n    ssm_parameters: list[SsmParameter] = field(default_factory=list)\n    secrets: list[SmSecret] = field(default_factory=list)\n\n\n# ---------------------------------------------------------------------------\n# Orchestrator\n# ---------------------------------------------------------------------------\n\n\ndef parse_assembly(cdk_out_path: Path) -> AppModel:\n    \"\"\"Parse an entire CDK ``cdk.out`` directory into an :class:`AppModel`.\n\n    Parameters\n    ----------\n    cdk_out_path:\n        Path to the ``cdk.out`` directory produced by ``cdk synth``.\n\n    Returns\n    -------\n    AppModel\n    \"\"\"\n    manifest_path = cdk_out_path / \"manifest.json\"\n    if not manifest_path.exists():\n        logger.warning(\"No manifest.json found in %s\", cdk_out_path)\n        return AppModel()\n\n    with open(manifest_path, encoding=\"utf-8\") as fh:\n        manifest = json.load(fh)\n\n    # Parse assets (hash -> filesystem path)\n    asset_map = parse_assets(cdk_out_path)\n\n    # Parse tree.json if present\n    tree_path = cdk_out_path / \"tree.json\"\n    if tree_path.exists():\n        parse_tree(tree_path)  # Currently used for validation; future enrichment\n\n    # Collect all stack artifacts\n    model = AppModel()\n    for artifact_id, artifact in (manifest.get(\"artifacts\") or {}).items():\n        if artifact.get(\"type\") != \"aws:cloudformation:stack\":\n            continue\n        _process_stack(cdk_out_path, artifact_id, artifact, asset_map, model)\n\n    return model\n\n\ndef _process_stack(\n    cdk_out_path: Path,\n    artifact_id: str,\n    artifact: dict,\n    asset_map: dict[str, Path],\n    model: AppModel,\n) -> None:\n    \"\"\"Process a single CloudFormation stack artifact.\"\"\"\n    template_file = artifact.get(\"properties\", {}).get(\"templateFile\")\n    if not template_file:\n        logger.warning(\"Stack %s has no templateFile\", artifact_id)\n        return\n\n    template_path = cdk_out_path / template_file\n    if not template_path.exists():\n        logger.warning(\"Template not found: %s\", template_path)\n        return\n\n    resources = parse_template(template_path)\n    resource_type_map = {r.logical_id: r.resource_type for r in resources}\n    resource_map = _build_resource_map(resources)\n    resolver = RefResolver(resource_map=resource_map, resource_types=resource_type_map)\n\n    model.functions.extend(_collect_lambdas(resources, asset_map, cdk_out_path, resolver))\n    model.tables.extend(_collect_tables(resources, resolver))\n    api_def = _collect_api_routes(resources, resolver, artifact_id)\n    if api_def:\n        model.apis.append(api_def)\n    model.queues.extend(_collect_queues(resources, resolver))\n    model.buckets.extend(_collect_buckets(resources))\n    model.topics.extend(_collect_topics(resources, resolver))\n    model.event_buses.extend(_collect_event_buses(resources, resolver))\n    model.event_rules.extend(_collect_event_rules(resources, resolver))\n    model.state_machines.extend(_collect_state_machines(resources, resolver))\n    model.user_pools.extend(_collect_user_pools(resources, resolver))\n    model.ssm_parameters.extend(_collect_ssm_parameters(resources, resolver))\n    model.secrets.extend(_collect_secrets(resources, resolver))\n\n    # ECS needs the raw template dict\n    with open(template_path, encoding=\"utf-8\") as fh:\n        raw_template = json.load(fh)\n    ecs_services = _collect_ecs_services(raw_template)\n    model.ecs_services.extend(ecs_services)\n\n\ndef _build_resource_map(resources: list[CfnResource]) -> dict[str, str]:\n    \"\"\"Build a Ref resource_map so intrinsic ``Ref`` calls resolve to useful local values.\n\n    In real CloudFormation:\n    - ``Ref`` on an ``AWS::SQS::Queue`` returns the queue URL.\n    - ``Ref`` on an ``AWS::DynamoDB::Table`` returns the table name.\n\n    We reproduce this behaviour with deterministic local placeholders so that\n    Lambda environment variables like ``QUEUE_URL`` and ``TABLE_NAME`` resolve\n    to values the local providers can understand.\n    \"\"\"\n    resource_map: dict[str, str] = {}\n    for r in resources:\n        if r.resource_type == \"AWS::SQS::Queue\":\n            queue_name = r.properties.get(\"QueueName\", r.logical_id)\n            if isinstance(queue_name, str):\n                # Use ARN format so the SDK connects via AWS_ENDPOINT_URL_SQS\n                # rather than trying to resolve the QueueUrl as a hostname.\n                resource_map[r.logical_id] = f\"arn:ldk:sqs:local:000000000000:queue/{queue_name}\"\n        elif r.resource_type == \"AWS::DynamoDB::Table\":\n            # Ref returns the table name.\n            table_name = r.properties.get(\"TableName\", r.logical_id)\n            if isinstance(table_name, str):\n                resource_map[r.logical_id] = table_name\n        elif r.resource_type == \"AWS::S3::Bucket\":\n            # Ref returns the bucket name.\n            bucket_name = r.properties.get(\"BucketName\", r.logical_id)\n            if isinstance(bucket_name, str):\n                resource_map[r.logical_id] = bucket_name\n            else:\n                resource_map[r.logical_id] = r.logical_id\n        elif r.resource_type == \"AWS::SNS::Topic\":\n            # Ref returns the topic ARN.\n            topic_name = r.properties.get(\"TopicName\", r.logical_id)\n            if isinstance(topic_name, str):\n                resource_map[r.logical_id] = f\"arn:ldk:sns:local:000000000000:{topic_name}\"\n        elif r.resource_type == \"AWS::SSM::Parameter\":\n            name = r.properties.get(\"Name\", r.logical_id)\n            if isinstance(name, str):\n                resource_map[r.logical_id] = name\n        elif r.resource_type == \"AWS::SecretsManager::Secret\":\n            name = r.properties.get(\"Name\", r.logical_id)\n            if isinstance(name, str):\n                resource_map[r.logical_id] = (\n                    f\"arn:aws:secretsmanager:us-east-1:000000000000:secret:{name}\"\n                )\n    return resource_map\n\n\ndef _collect_lambdas(\n    resources: list[CfnResource],\n    asset_map: dict[str, Path],\n    cdk_out_path: Path,\n    resolver: RefResolver,\n) -> list[LambdaFunction]:\n    \"\"\"Extract Lambda functions from parsed CloudFormation resources.\"\"\"\n    functions: list[LambdaFunction] = []\n    lambda_props_list = extract_lambda_functions(resources)\n    lambda_resources = [r for r in resources if r.resource_type == \"AWS::Lambda::Function\"]\n    for r, props in zip(lambda_resources, lambda_props_list):\n        code_path = _resolve_code_path(props.code_uri, asset_map, cdk_out_path, resolver)\n        env = {k: str(resolver.resolve(v)) for k, v in props.environment.items()}\n        functions.append(\n            LambdaFunction(\n                name=r.logical_id,\n                handler=props.handler or \"index.handler\",\n                runtime=props.runtime or \"python3.11\",\n                code_path=code_path,\n                timeout=props.timeout or 30,\n                memory=props.memory_size or 128,\n                environment=env,\n            )\n        )\n    return functions\n\n\ndef _collect_tables(\n    resources: list[CfnResource],\n    resolver: RefResolver,\n) -> list[DynamoTable]:\n    \"\"\"Extract DynamoDB tables from parsed CloudFormation resources.\"\"\"\n    tables: list[DynamoTable] = []\n    dynamo_props_list = extract_dynamo_tables(resources)\n    dynamo_resources = [r for r in resources if r.resource_type == \"AWS::DynamoDB::Table\"]\n    for r, props in zip(dynamo_resources, dynamo_props_list):\n        name = props.table_name or r.logical_id\n        if isinstance(name, dict):\n            name = str(resolver.resolve(name))\n        tables.append(\n            DynamoTable(\n                name=name,\n                key_schema=props.key_schema,\n                gsi_definitions=props.gsi_definitions,\n            )\n        )\n    return tables\n\n\ndef _collect_api_routes(\n    resources: list[CfnResource],\n    resolver: RefResolver,\n    artifact_id: str,\n) -> ApiDefinition | None:\n    \"\"\"Extract API Gateway routes from parsed CloudFormation resources.\"\"\"\n    api_routes = extract_api_routes(resources)\n    if not api_routes:\n        return None\n    routes: list[ApiRoute] = []\n    for route_props in api_routes:\n        handler_name = _find_handler_for_integration(\n            route_props.integration_uri, resources, resolver\n        )\n        routes.append(\n            ApiRoute(\n                method=route_props.http_method or \"ANY\",\n                path=route_props.resource_path or \"/\",\n                handler_name=handler_name,\n            )\n        )\n    return ApiDefinition(name=artifact_id, routes=routes)\n\n\ndef _resolve_code_from_s3_key(s3_key: str, asset_map: dict[str, Path]) -> Path | None:\n    \"\"\"Try to match an S3Key to an asset by hash.\"\"\"\n    asset_hash = s3_key.replace(\".zip\", \"\")\n    if asset_hash in asset_map:\n        return asset_map[asset_hash]\n    for hash_key, path in asset_map.items():\n        if hash_key in s3_key:\n            return path\n    return None\n\n\ndef _resolve_code_from_s3_bucket(\n    s3_bucket: dict, resolver: RefResolver, asset_map: dict[str, Path]\n) -> Path | None:\n    \"\"\"Try to match an S3Bucket ref to an asset.\"\"\"\n    resolved = str(resolver.resolve(s3_bucket))\n    for h, p in asset_map.items():\n        if h in resolved:\n            return p\n    return None\n\n\ndef _resolve_code_path(\n    code_uri: Any,\n    asset_map: dict[str, Path],\n    cdk_out_path: Path,\n    resolver: RefResolver,\n) -> Path | None:\n    \"\"\"Resolve a Lambda Code property to a local filesystem path.\"\"\"\n    if code_uri is None:\n        return None\n\n    if isinstance(code_uri, dict):\n        s3_key = code_uri.get(\"S3Key\")\n        if isinstance(s3_key, str):\n            result = _resolve_code_from_s3_key(s3_key, asset_map)\n            if result:\n                return result\n\n        s3_bucket = code_uri.get(\"S3Bucket\")\n        if isinstance(s3_bucket, dict):\n            result = _resolve_code_from_s3_bucket(s3_bucket, resolver, asset_map)\n            if result:\n                return result\n\n    if isinstance(code_uri, str):\n        candidate = cdk_out_path / code_uri\n        if candidate.exists():\n            return candidate\n\n    return None\n\n\ndef _find_handler_for_integration(\n    integration_uri: Any,\n    resources: list[CfnResource],\n    resolver: RefResolver,\n) -> str | None:\n    \"\"\"Try to match an API integration URI back to a Lambda logical ID.\"\"\"\n    if integration_uri is None:\n        return None\n\n    resolved = str(resolver.resolve(integration_uri))\n\n    # Look for a Lambda function logical ID in the resolved string\n    for r in resources:\n        if r.resource_type == \"AWS::Lambda::Function\":\n            if r.logical_id in resolved:\n                return r.logical_id\n\n    return None\n\n\n# ---------------------------------------------------------------------------\n# Collectors for new resource types\n# ---------------------------------------------------------------------------\n\n\ndef _collect_queues(\n    resources: list[CfnResource],\n    resolver: RefResolver,\n) -> list[SqsQueue]:\n    \"\"\"Extract SQS queues from parsed CloudFormation resources.\"\"\"\n    queues: list[SqsQueue] = []\n    for r in resources:\n        if r.resource_type != \"AWS::SQS::Queue\":\n            continue\n        props = r.properties\n        name = props.get(\"QueueName\", r.logical_id)\n        if isinstance(name, dict):\n            name = str(resolver.resolve(name))\n        is_fifo = bool(props.get(\"FifoQueue\", False))\n        vis = int(props.get(\"VisibilityTimeout\", 30))\n        dedup = bool(props.get(\"ContentBasedDeduplication\", False))\n        redrive = props.get(\"RedrivePolicy\")\n        redrive_target = None\n        max_receive = 5\n        if isinstance(redrive, dict):\n            dlq = redrive.get(\"deadLetterTargetArn\", \"\")\n            if isinstance(dlq, dict):\n                dlq = str(resolver.resolve(dlq))\n            redrive_target = str(dlq) if dlq else None\n            max_receive = int(redrive.get(\"maxReceiveCount\", 5))\n        queues.append(\n            SqsQueue(\n                name=name,\n                is_fifo=is_fifo,\n                visibility_timeout=vis,\n                content_based_dedup=dedup,\n                redrive_target=redrive_target,\n                max_receive_count=max_receive,\n            )\n        )\n    return queues\n\n\ndef _collect_buckets(resources: list[CfnResource]) -> list[S3Bucket]:\n    \"\"\"Extract S3 buckets from parsed CloudFormation resources.\"\"\"\n    buckets: list[S3Bucket] = []\n    for r in resources:\n        if r.resource_type != \"AWS::S3::Bucket\":\n            continue\n        name = r.properties.get(\"BucketName\", r.logical_id)\n        if isinstance(name, dict):\n            name = r.logical_id  # Can't resolve intrinsics for bucket names easily\n        buckets.append(S3Bucket(name=name))\n    return buckets\n\n\ndef _collect_topics(\n    resources: list[CfnResource],\n    resolver: RefResolver,\n) -> list[SnsTopic]:\n    \"\"\"Extract SNS topics from parsed CloudFormation resources.\"\"\"\n    topics: list[SnsTopic] = []\n    for r in resources:\n        if r.resource_type != \"AWS::SNS::Topic\":\n            continue\n        props = r.properties\n        name = props.get(\"TopicName\", r.logical_id)\n        if isinstance(name, dict):\n            name = str(resolver.resolve(name))\n        arn = f\"arn:aws:sns:us-east-1:000000000000:{name}\"\n        topics.append(SnsTopic(name=name, topic_arn=arn))\n    return topics\n\n\ndef _collect_event_buses(\n    resources: list[CfnResource],\n    resolver: RefResolver,\n) -> list[EventBus]:\n    \"\"\"Extract EventBridge event buses from parsed CloudFormation resources.\"\"\"\n    buses: list[EventBus] = []\n    for r in resources:\n        if r.resource_type != \"AWS::Events::EventBus\":\n            continue\n        props = r.properties\n        name = props.get(\"Name\", r.logical_id)\n        if isinstance(name, dict):\n            name = str(resolver.resolve(name))\n        arn = f\"arn:aws:events:us-east-1:000000000000:event-bus/{name}\"\n        buses.append(EventBus(name=name, bus_arn=arn))\n    return buses\n\n\ndef _collect_event_rules(\n    resources: list[CfnResource],\n    resolver: RefResolver,\n) -> list[EventRule]:\n    \"\"\"Extract EventBridge rules from parsed CloudFormation resources.\"\"\"\n    rules: list[EventRule] = []\n    for r in resources:\n        if r.resource_type != \"AWS::Events::Rule\":\n            continue\n        props = r.properties\n        rule_name = props.get(\"Name\", r.logical_id)\n        if isinstance(rule_name, dict):\n            rule_name = str(resolver.resolve(rule_name))\n        bus_name = props.get(\"EventBusName\", \"default\")\n        if isinstance(bus_name, dict):\n            bus_name = str(resolver.resolve(bus_name))\n        pattern = props.get(\"EventPattern\")\n        schedule = props.get(\"ScheduleExpression\")\n        raw_targets = props.get(\"Targets\", [])\n        targets: list[dict[str, Any]] = []\n        for t in raw_targets:\n            target_arn = t.get(\"Arn\", \"\")\n            if isinstance(target_arn, dict):\n                target_arn = str(resolver.resolve(target_arn))\n            targets.append(\n                {\n                    \"target_id\": t.get(\"Id\", \"\"),\n                    \"arn\": target_arn,\n                    \"input_path\": t.get(\"InputPath\"),\n                    \"input_template\": t.get(\"InputTransformer\", {}).get(\"InputTemplate\"),\n                }\n            )\n        rules.append(\n            EventRule(\n                rule_name=rule_name,\n                event_bus_name=bus_name,\n                event_pattern=pattern,\n                schedule_expression=schedule,\n                targets=targets,\n            )\n        )\n    return rules\n\n\ndef _resolve_sm_definition(definition: Any, resolver: RefResolver) -> Any:\n    \"\"\"Resolve a Step Functions DefinitionString that may use intrinsic functions.\"\"\"\n    if isinstance(definition, dict):\n        return resolver.resolve(definition)\n    return definition\n\n\ndef _resolve_substitutions(subs: dict[str, Any], resolver: RefResolver) -> dict[str, str]:\n    \"\"\"Resolve CloudFormation DefinitionSubstitutions to plain strings.\"\"\"\n    return {k: str(resolver.resolve(v)) if isinstance(v, dict) else str(v) for k, v in subs.items()}\n\n\ndef _collect_state_machines(\n    resources: list[CfnResource],\n    resolver: RefResolver,\n) -> list[StateMachine]:\n    \"\"\"Extract Step Functions state machines from parsed CloudFormation resources.\"\"\"\n    machines: list[StateMachine] = []\n    for r in resources:\n        if r.resource_type != \"AWS::StepFunctions::StateMachine\":\n            continue\n        props = r.properties\n        name = props.get(\"StateMachineName\", r.logical_id)\n        if isinstance(name, dict):\n            name = str(resolver.resolve(name))\n        definition = props.get(\"DefinitionString\", props.get(\"Definition\", \"\"))\n        definition = _resolve_sm_definition(definition, resolver)\n        role_arn = props.get(\"RoleArn\", \"\")\n        if isinstance(role_arn, dict):\n            role_arn = str(resolver.resolve(role_arn))\n        resolved_subs = _resolve_substitutions(props.get(\"DefinitionSubstitutions\", {}), resolver)\n        machines.append(\n            StateMachine(\n                name=name,\n                definition=definition,\n                workflow_type=props.get(\"StateMachineType\", \"STANDARD\"),\n                role_arn=role_arn,\n                definition_substitutions=resolved_subs,\n            )\n        )\n    return machines\n\n\ndef _collect_user_pools(\n    resources: list[CfnResource],\n    resolver: RefResolver,\n) -> list[CognitoUserPool]:\n    \"\"\"Extract Cognito user pools from parsed CloudFormation resources.\"\"\"\n    pools: list[CognitoUserPool] = []\n    # First pass: collect user pool clients to map pool -> client_id\n    client_map: dict[str, str] = {}\n    for r in resources:\n        if r.resource_type != \"AWS::Cognito::UserPoolClient\":\n            continue\n        pool_ref = r.properties.get(\"UserPoolId\", \"\")\n        if isinstance(pool_ref, dict):\n            pool_ref = str(resolver.resolve(pool_ref))\n        client_map[pool_ref] = r.logical_id\n\n    for r in resources:\n        if r.resource_type != \"AWS::Cognito::UserPool\":\n            continue\n        props = r.properties\n        name = props.get(\"UserPoolName\", r.logical_id)\n        if isinstance(name, dict):\n            name = str(resolver.resolve(name))\n        auto_confirm = True\n        lambda_config = props.get(\"LambdaConfig\", {})\n        pre_auth = lambda_config.get(\"PreAuthentication\")\n        if isinstance(pre_auth, dict):\n            pre_auth = str(resolver.resolve(pre_auth))\n        post_confirm = lambda_config.get(\"PostConfirmation\")\n        if isinstance(post_confirm, dict):\n            post_confirm = str(resolver.resolve(post_confirm))\n        pw_policy = props.get(\"Policies\", {}).get(\"PasswordPolicy\", {})\n        client_id = client_map.get(r.logical_id, \"\")\n        pools.append(\n            CognitoUserPool(\n                logical_id=r.logical_id,\n                user_pool_name=name,\n                auto_confirm=auto_confirm,\n                password_policy=pw_policy,\n                pre_auth_trigger=pre_auth,\n                post_confirm_trigger=post_confirm,\n                client_id=client_id,\n            )\n        )\n    return pools\n\n\ndef _collect_ssm_parameters(\n    resources: list[CfnResource],\n    resolver: RefResolver,\n) -> list[SsmParameter]:\n    \"\"\"Extract SSM parameters from parsed CloudFormation resources.\"\"\"\n    parameters: list[SsmParameter] = []\n    for r in resources:\n        if r.resource_type != \"AWS::SSM::Parameter\":\n            continue\n        props = r.properties\n        name = props.get(\"Name\", r.logical_id)\n        if isinstance(name, dict):\n            name = str(resolver.resolve(name))\n        param_type = props.get(\"Type\", \"String\")\n        value = props.get(\"Value\", \"\")\n        if isinstance(value, dict):\n            value = str(resolver.resolve(value))\n        description = props.get(\"Description\", \"\")\n        parameters.append(\n            SsmParameter(name=name, type=param_type, value=value, description=description)\n        )\n    return parameters\n\n\ndef _collect_secrets(\n    resources: list[CfnResource],\n    resolver: RefResolver,\n) -> list[SmSecret]:\n    \"\"\"Extract Secrets Manager secrets from parsed CloudFormation resources.\"\"\"\n    secrets: list[SmSecret] = []\n    for r in resources:\n        if r.resource_type != \"AWS::SecretsManager::Secret\":\n            continue\n        props = r.properties\n        name = props.get(\"Name\", r.logical_id)\n        if isinstance(name, dict):\n            name = str(resolver.resolve(name))\n        description = props.get(\"Description\", \"\")\n        secret_string = props.get(\"SecretString\")\n        if secret_string is None:\n            # Try GenerateSecretString.SecretStringTemplate\n            gen = props.get(\"GenerateSecretString\", {})\n            if isinstance(gen, dict):\n                secret_string = gen.get(\"SecretStringTemplate\")\n        if isinstance(secret_string, dict):\n            secret_string = str(resolver.resolve(secret_string))\n        secrets.append(SmSecret(name=name, description=description, secret_string=secret_string))\n    return secrets\n\n\ndef _collect_ecs_services(template: dict) -> list:\n    \"\"\"Extract ECS services from the raw CloudFormation template.\"\"\"\n    try:\n        from lws.providers.ecs.provider import parse_ecs_resources\n\n        return parse_ecs_resources(template)\n    except Exception:\n        logger.debug(\"Could not parse ECS resources\", exc_info=True)\n        return []\n","structuredPatch":[{"oldStart":295,"oldLines":42,"newStart":295,"newLines":40,"lines":["     \"\"\"","     resource_map: dict[str, str] = {}","     for r in resources:","-        if r.resource_type == \"AWS::SQS::Queue\":","-            queue_name = r.properties.get(\"QueueName\", r.logical_id)","-            if isinstance(queue_name, str):","-                # Use ARN format so the SDK connects via AWS_ENDPOINT_URL_SQS","-                # rather than trying to resolve the QueueUrl as a hostname.","-                resource_map[r.logical_id] = f\"arn:ldk:sqs:local:000000000000:queue/{queue_name}\"","-        elif r.resource_type == \"AWS::DynamoDB::Table\":","-            # Ref returns the table name.","-            table_name = r.properties.get(\"TableName\", r.logical_id)","-            if isinstance(table_name, str):","-                resource_map[r.logical_id] = table_name","-        elif r.resource_type == \"AWS::S3::Bucket\":","-            # Ref returns the bucket name.","-            bucket_name = r.properties.get(\"BucketName\", r.logical_id)","-            if isinstance(bucket_name, str):","-                resource_map[r.logical_id] = bucket_name","-            else:","-                resource_map[r.logical_id] = r.logical_id","-        elif r.resource_type == \"AWS::SNS::Topic\":","-            # Ref returns the topic ARN.","-            topic_name = r.properties.get(\"TopicName\", r.logical_id)","-            if isinstance(topic_name, str):","-                resource_map[r.logical_id] = f\"arn:ldk:sns:local:000000000000:{topic_name}\"","-        elif r.resource_type == \"AWS::SSM::Parameter\":","-            name = r.properties.get(\"Name\", r.logical_id)","-            if isinstance(name, str):","-                resource_map[r.logical_id] = name","-        elif r.resource_type == \"AWS::SecretsManager::Secret\":","-            name = r.properties.get(\"Name\", r.logical_id)","-            if isinstance(name, str):","-                resource_map[r.logical_id] = (","-                    f\"arn:aws:secretsmanager:us-east-1:000000000000:secret:{name}\"","-                )","+        ref = _resolve_ref_value(r)","+        if ref is not None:","+            resource_map[r.logical_id] = ref","     return resource_map"," "," ","+def _resolve_ref_value(r: CfnResource) -> str | None:","+    \"\"\"Return the local Ref value for a single CloudFormation resource, or None.\"\"\"","+    if r.resource_type == \"AWS::SQS::Queue\":","+        queue_name = r.properties.get(\"QueueName\", r.logical_id)","+        if isinstance(queue_name, str):","+            return f\"arn:ldk:sqs:local:000000000000:queue/{queue_name}\"","+    elif r.resource_type == \"AWS::DynamoDB::Table\":","+        table_name = r.properties.get(\"TableName\", r.logical_id)","+        if isinstance(table_name, str):","+            return table_name","+    elif r.resource_type == \"AWS::S3::Bucket\":","+        bucket_name = r.properties.get(\"BucketName\", r.logical_id)","+        return bucket_name if isinstance(bucket_name, str) else r.logical_id","+    elif r.resource_type == \"AWS::SNS::Topic\":","+        topic_name = r.properties.get(\"TopicName\", r.logical_id)","+        if isinstance(topic_name, str):","+            return f\"arn:ldk:sns:local:000000000000:{topic_name}\"","+    elif r.resource_type == \"AWS::SSM::Parameter\":","+        name = r.properties.get(\"Name\", r.logical_id)","+        if isinstance(name, str):","+            return name","+    elif r.resource_type == \"AWS::SecretsManager::Secret\":","+        name = r.properties.get(\"Name\", r.logical_id)","+        if isinstance(name, str):","+            return f\"arn:aws:secretsmanager:us-east-1:000000000000:secret:{name}\"","+    return None","+","+"," def _collect_lambdas(","     resources: list[CfnResource],","     asset_map: dict[str, Path],"]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"90bd84bc-bcee-4c7c-ad2d-ef8b956fd2c8"}
{"parentUuid":"321574c2-49f5-42eb-8e7a-70a9287eeee5","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","message":{"model":"claude-opus-4-6","id":"msg_01VpsUuLBW6vamkimxRq1i7c","type":"message","role":"assistant","content":[{"type":"text","text":"Now fix the `_add_service_metadata` complexity in ldk.py by extracting the SSM/SecretsManager part into a helper:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1595,"cache_read_input_tokens":75682,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1595},"output_tokens":2,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CY1FTZnep4kJx3AnwFZm7","type":"assistant","uuid":"05978292-38d3-476c-9f57-82ef6ae18521","timestamp":"2026-02-10T23:23:51.942Z"}
{"parentUuid":"05978292-38d3-476c-9f57-82ef6ae18521","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","message":{"model":"claude-opus-4-6","id":"msg_01VpsUuLBW6vamkimxRq1i7c","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01FzbaA9jGhWTGTALTrDonxE","name":"Read","input":{"file_path":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services/src/lws/cli/ldk.py","offset":1365,"limit":100}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1595,"cache_read_input_tokens":75682,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1595},"output_tokens":2,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CY1FTZnep4kJx3AnwFZm7","type":"assistant","uuid":"120c3ce0-cb0a-4644-b09f-c54f8c113557","timestamp":"2026-02-10T23:23:52.998Z"}
{"parentUuid":"120c3ce0-cb0a-4644-b09f-c54f8c113557","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"callback"},"parentToolUseID":"toolu_01FzbaA9jGhWTGTALTrDonxE","toolUseID":"toolu_01FzbaA9jGhWTGTALTrDonxE","timestamp":"2026-02-10T23:23:53.007Z","uuid":"90ac4540-5043-46c4-a25b-1cf3c11709cc"}
{"parentUuid":"120c3ce0-cb0a-4644-b09f-c54f8c113557","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01FzbaA9jGhWTGTALTrDonxE","type":"tool_result","content":"  1365→\n  1366→def _add_service_metadata(\n  1367→    services: dict[str, Any], app_model: AppModel, ports: dict[str, int]\n  1368→) -> None:\n  1369→    \"\"\"Add non-API service metadata to services.\"\"\"\n  1370→    if app_model.functions:\n  1371→        services[\"lambda\"] = {\n  1372→            \"resources\": [\n  1373→                {\n  1374→                    \"name\": f.name,\n  1375→                    \"runtime\": f.runtime,\n  1376→                    \"arn\": f\"arn:aws:lambda:us-east-1:000000000000:function:{f.name}\",\n  1377→                }\n  1378→                for f in app_model.functions\n  1379→            ],\n  1380→        }\n  1381→    if app_model.tables:\n  1382→        services[\"dynamodb\"] = {\n  1383→            \"port\": ports[\"dynamodb\"],\n  1384→            \"resources\": [{\"name\": t.name} for t in app_model.tables],\n  1385→        }\n  1386→    if app_model.queues:\n  1387→        sqs_port = ports[\"sqs\"]\n  1388→        services[\"sqs\"] = {\n  1389→            \"port\": sqs_port,\n  1390→            \"resources\": [\n  1391→                {\n  1392→                    \"name\": q.name,\n  1393→                    \"queue_url\": f\"http://localhost:{sqs_port}/000000000000/{q.name}\",\n  1394→                }\n  1395→                for q in app_model.queues\n  1396→            ],\n  1397→        }\n  1398→    if app_model.buckets:\n  1399→        services[\"s3\"] = {\n  1400→            \"port\": ports[\"s3\"],\n  1401→            \"resources\": [{\"name\": b.name} for b in app_model.buckets],\n  1402→        }\n  1403→    if app_model.topics:\n  1404→        services[\"sns\"] = {\n  1405→            \"port\": ports[\"sns\"],\n  1406→            \"resources\": [\n  1407→                {\n  1408→                    \"name\": t.name,\n  1409→                    \"arn\": t.topic_arn or f\"arn:aws:sns:us-east-1:000000000000:{t.name}\",\n  1410→                }\n  1411→                for t in app_model.topics\n  1412→            ],\n  1413→        }\n  1414→    if app_model.event_buses:\n  1415→        services[\"events\"] = {\n  1416→            \"port\": ports[\"events\"],\n  1417→            \"resources\": [\n  1418→                {\n  1419→                    \"name\": b.name,\n  1420→                    \"arn\": b.bus_arn or f\"arn:aws:events:us-east-1:000000000000:event-bus/{b.name}\",\n  1421→                }\n  1422→                for b in app_model.event_buses\n  1423→            ],\n  1424→        }\n  1425→    if app_model.state_machines:\n  1426→        services[\"stepfunctions\"] = {\n  1427→            \"port\": ports[\"stepfunctions\"],\n  1428→            \"resources\": [\n  1429→                {\n  1430→                    \"name\": sm.name,\n  1431→                    \"arn\": f\"arn:aws:states:us-east-1:000000000000:stateMachine:{sm.name}\",\n  1432→                }\n  1433→                for sm in app_model.state_machines\n  1434→            ],\n  1435→        }\n  1436→    if app_model.user_pools:\n  1437→        services[\"cognito-idp\"] = {\n  1438→            \"port\": ports[\"cognito-idp\"],\n  1439→            \"resources\": [\n  1440→                {\"name\": p.user_pool_name, \"user_pool_id\": f\"us-east-1_{p.logical_id}\"}\n  1441→                for p in app_model.user_pools\n  1442→            ],\n  1443→        }\n  1444→    if app_model.ssm_parameters:\n  1445→        services[\"ssm\"] = {\n  1446→            \"port\": ports[\"ssm\"],\n  1447→            \"resources\": [{\"name\": p.name} for p in app_model.ssm_parameters],\n  1448→        }\n  1449→    if app_model.secrets:\n  1450→        services[\"secretsmanager\"] = {\n  1451→            \"port\": ports[\"secretsmanager\"],\n  1452→            \"resources\": [\n  1453→                {\n  1454→                    \"name\": s.name,\n  1455→                    \"arn\": f\"arn:aws:secretsmanager:us-east-1:000000000000:secret:{s.name}\",\n  1456→                }\n  1457→                for s in app_model.secrets\n  1458→            ],\n  1459→        }\n  1460→\n  1461→\n  1462→def _mount_management_api(\n  1463→    providers: dict[str, Provider],\n  1464→    orchestrator: Orchestrator,\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"2768775b-b9af-4c15-b009-42dc69888405","timestamp":"2026-02-10T23:23:53.006Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services/src/lws/cli/ldk.py","content":"\ndef _add_service_metadata(\n    services: dict[str, Any], app_model: AppModel, ports: dict[str, int]\n) -> None:\n    \"\"\"Add non-API service metadata to services.\"\"\"\n    if app_model.functions:\n        services[\"lambda\"] = {\n            \"resources\": [\n                {\n                    \"name\": f.name,\n                    \"runtime\": f.runtime,\n                    \"arn\": f\"arn:aws:lambda:us-east-1:000000000000:function:{f.name}\",\n                }\n                for f in app_model.functions\n            ],\n        }\n    if app_model.tables:\n        services[\"dynamodb\"] = {\n            \"port\": ports[\"dynamodb\"],\n            \"resources\": [{\"name\": t.name} for t in app_model.tables],\n        }\n    if app_model.queues:\n        sqs_port = ports[\"sqs\"]\n        services[\"sqs\"] = {\n            \"port\": sqs_port,\n            \"resources\": [\n                {\n                    \"name\": q.name,\n                    \"queue_url\": f\"http://localhost:{sqs_port}/000000000000/{q.name}\",\n                }\n                for q in app_model.queues\n            ],\n        }\n    if app_model.buckets:\n        services[\"s3\"] = {\n            \"port\": ports[\"s3\"],\n            \"resources\": [{\"name\": b.name} for b in app_model.buckets],\n        }\n    if app_model.topics:\n        services[\"sns\"] = {\n            \"port\": ports[\"sns\"],\n            \"resources\": [\n                {\n                    \"name\": t.name,\n                    \"arn\": t.topic_arn or f\"arn:aws:sns:us-east-1:000000000000:{t.name}\",\n                }\n                for t in app_model.topics\n            ],\n        }\n    if app_model.event_buses:\n        services[\"events\"] = {\n            \"port\": ports[\"events\"],\n            \"resources\": [\n                {\n                    \"name\": b.name,\n                    \"arn\": b.bus_arn or f\"arn:aws:events:us-east-1:000000000000:event-bus/{b.name}\",\n                }\n                for b in app_model.event_buses\n            ],\n        }\n    if app_model.state_machines:\n        services[\"stepfunctions\"] = {\n            \"port\": ports[\"stepfunctions\"],\n            \"resources\": [\n                {\n                    \"name\": sm.name,\n                    \"arn\": f\"arn:aws:states:us-east-1:000000000000:stateMachine:{sm.name}\",\n                }\n                for sm in app_model.state_machines\n            ],\n        }\n    if app_model.user_pools:\n        services[\"cognito-idp\"] = {\n            \"port\": ports[\"cognito-idp\"],\n            \"resources\": [\n                {\"name\": p.user_pool_name, \"user_pool_id\": f\"us-east-1_{p.logical_id}\"}\n                for p in app_model.user_pools\n            ],\n        }\n    if app_model.ssm_parameters:\n        services[\"ssm\"] = {\n            \"port\": ports[\"ssm\"],\n            \"resources\": [{\"name\": p.name} for p in app_model.ssm_parameters],\n        }\n    if app_model.secrets:\n        services[\"secretsmanager\"] = {\n            \"port\": ports[\"secretsmanager\"],\n            \"resources\": [\n                {\n                    \"name\": s.name,\n                    \"arn\": f\"arn:aws:secretsmanager:us-east-1:000000000000:secret:{s.name}\",\n                }\n                for s in app_model.secrets\n            ],\n        }\n\n\ndef _mount_management_api(\n    providers: dict[str, Provider],\n    orchestrator: Orchestrator,","numLines":100,"startLine":1365,"totalLines":1527}},"sourceToolAssistantUUID":"120c3ce0-cb0a-4644-b09f-c54f8c113557"}
{"parentUuid":"2768775b-b9af-4c15-b009-42dc69888405","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","message":{"model":"claude-opus-4-6","id":"msg_01QeawihQ6iLfzpzeoQ9w7iM","type":"message","role":"assistant","content":[{"type":"text","text":"I'll split the function to reduce complexity:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1631,"cache_read_input_tokens":77277,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1631},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CY1FTyL1H6FoFQCKxaPhX","type":"assistant","uuid":"6e02465a-c744-42d2-8d3b-2ed97250036c","timestamp":"2026-02-10T23:23:55.726Z"}
{"parentUuid":"6e02465a-c744-42d2-8d3b-2ed97250036c","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","message":{"model":"claude-opus-4-6","id":"msg_01QeawihQ6iLfzpzeoQ9w7iM","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01388VWtzxPtL8L6K5mBEQA3","name":"Edit","input":{"replace_all":false,"file_path":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services/src/lws/cli/ldk.py","old_string":"def _add_service_metadata(\n    services: dict[str, Any], app_model: AppModel, ports: dict[str, int]\n) -> None:\n    \"\"\"Add non-API service metadata to services.\"\"\"\n    if app_model.functions:\n        services[\"lambda\"] = {\n            \"resources\": [\n                {\n                    \"name\": f.name,\n                    \"runtime\": f.runtime,\n                    \"arn\": f\"arn:aws:lambda:us-east-1:000000000000:function:{f.name}\",\n                }\n                for f in app_model.functions\n            ],\n        }\n    if app_model.tables:\n        services[\"dynamodb\"] = {\n            \"port\": ports[\"dynamodb\"],\n            \"resources\": [{\"name\": t.name} for t in app_model.tables],\n        }\n    if app_model.queues:\n        sqs_port = ports[\"sqs\"]\n        services[\"sqs\"] = {\n            \"port\": sqs_port,\n            \"resources\": [\n                {\n                    \"name\": q.name,\n                    \"queue_url\": f\"http://localhost:{sqs_port}/000000000000/{q.name}\",\n                }\n                for q in app_model.queues\n            ],\n        }\n    if app_model.buckets:\n        services[\"s3\"] = {\n            \"port\": ports[\"s3\"],\n            \"resources\": [{\"name\": b.name} for b in app_model.buckets],\n        }\n    if app_model.topics:\n        services[\"sns\"] = {\n            \"port\": ports[\"sns\"],\n            \"resources\": [\n                {\n                    \"name\": t.name,\n                    \"arn\": t.topic_arn or f\"arn:aws:sns:us-east-1:000000000000:{t.name}\",\n                }\n                for t in app_model.topics\n            ],\n        }\n    if app_model.event_buses:\n        services[\"events\"] = {\n            \"port\": ports[\"events\"],\n            \"resources\": [\n                {\n                    \"name\": b.name,\n                    \"arn\": b.bus_arn or f\"arn:aws:events:us-east-1:000000000000:event-bus/{b.name}\",\n                }\n                for b in app_model.event_buses\n            ],\n        }\n    if app_model.state_machines:\n        services[\"stepfunctions\"] = {\n            \"port\": ports[\"stepfunctions\"],\n            \"resources\": [\n                {\n                    \"name\": sm.name,\n                    \"arn\": f\"arn:aws:states:us-east-1:000000000000:stateMachine:{sm.name}\",\n                }\n                for sm in app_model.state_machines\n            ],\n        }\n    if app_model.user_pools:\n        services[\"cognito-idp\"] = {\n            \"port\": ports[\"cognito-idp\"],\n            \"resources\": [\n                {\"name\": p.user_pool_name, \"user_pool_id\": f\"us-east-1_{p.logical_id}\"}\n                for p in app_model.user_pools\n            ],\n        }\n    if app_model.ssm_parameters:\n        services[\"ssm\"] = {\n            \"port\": ports[\"ssm\"],\n            \"resources\": [{\"name\": p.name} for p in app_model.ssm_parameters],\n        }\n    if app_model.secrets:\n        services[\"secretsmanager\"] = {\n            \"port\": ports[\"secretsmanager\"],\n            \"resources\": [\n                {\n                    \"name\": s.name,\n                    \"arn\": f\"arn:aws:secretsmanager:us-east-1:000000000000:secret:{s.name}\",\n                }\n                for s in app_model.secrets\n            ],\n        }","new_string":"def _add_service_metadata(\n    services: dict[str, Any], app_model: AppModel, ports: dict[str, int]\n) -> None:\n    \"\"\"Add non-API service metadata to services.\"\"\"\n    if app_model.functions:\n        services[\"lambda\"] = {\n            \"resources\": [\n                {\n                    \"name\": f.name,\n                    \"runtime\": f.runtime,\n                    \"arn\": f\"arn:aws:lambda:us-east-1:000000000000:function:{f.name}\",\n                }\n                for f in app_model.functions\n            ],\n        }\n    if app_model.tables:\n        services[\"dynamodb\"] = {\n            \"port\": ports[\"dynamodb\"],\n            \"resources\": [{\"name\": t.name} for t in app_model.tables],\n        }\n    if app_model.queues:\n        sqs_port = ports[\"sqs\"]\n        services[\"sqs\"] = {\n            \"port\": sqs_port,\n            \"resources\": [\n                {\n                    \"name\": q.name,\n                    \"queue_url\": f\"http://localhost:{sqs_port}/000000000000/{q.name}\",\n                }\n                for q in app_model.queues\n            ],\n        }\n    if app_model.buckets:\n        services[\"s3\"] = {\n            \"port\": ports[\"s3\"],\n            \"resources\": [{\"name\": b.name} for b in app_model.buckets],\n        }\n    if app_model.topics:\n        services[\"sns\"] = {\n            \"port\": ports[\"sns\"],\n            \"resources\": [\n                {\n                    \"name\": t.name,\n                    \"arn\": t.topic_arn or f\"arn:aws:sns:us-east-1:000000000000:{t.name}\",\n                }\n                for t in app_model.topics\n            ],\n        }\n    _add_extended_service_metadata(services, app_model, ports)\n\n\ndef _add_extended_service_metadata(\n    services: dict[str, Any], app_model: AppModel, ports: dict[str, int]\n) -> None:\n    \"\"\"Add EventBridge, Step Functions, Cognito, SSM and Secrets Manager metadata.\"\"\"\n    if app_model.event_buses:\n        services[\"events\"] = {\n            \"port\": ports[\"events\"],\n            \"resources\": [\n                {\n                    \"name\": b.name,\n                    \"arn\": b.bus_arn or f\"arn:aws:events:us-east-1:000000000000:event-bus/{b.name}\",\n                }\n                for b in app_model.event_buses\n            ],\n        }\n    if app_model.state_machines:\n        services[\"stepfunctions\"] = {\n            \"port\": ports[\"stepfunctions\"],\n            \"resources\": [\n                {\n                    \"name\": sm.name,\n                    \"arn\": f\"arn:aws:states:us-east-1:000000000000:stateMachine:{sm.name}\",\n                }\n                for sm in app_model.state_machines\n            ],\n        }\n    if app_model.user_pools:\n        services[\"cognito-idp\"] = {\n            \"port\": ports[\"cognito-idp\"],\n            \"resources\": [\n                {\"name\": p.user_pool_name, \"user_pool_id\": f\"us-east-1_{p.logical_id}\"}\n                for p in app_model.user_pools\n            ],\n        }\n    if app_model.ssm_parameters:\n        services[\"ssm\"] = {\n            \"port\": ports[\"ssm\"],\n            \"resources\": [{\"name\": p.name} for p in app_model.ssm_parameters],\n        }\n    if app_model.secrets:\n        services[\"secretsmanager\"] = {\n            \"port\": ports[\"secretsmanager\"],\n            \"resources\": [\n                {\n                    \"name\": s.name,\n                    \"arn\": f\"arn:aws:secretsmanager:us-east-1:000000000000:secret:{s.name}\",\n                }\n                for s in app_model.secrets\n            ],\n        }"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1631,"cache_read_input_tokens":77277,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1631},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CY1FTyL1H6FoFQCKxaPhX","type":"assistant","uuid":"b2c9483c-be83-49e7-806f-53cf3c93ad1f","timestamp":"2026-02-10T23:24:13.100Z"}
{"parentUuid":"b2c9483c-be83-49e7-806f-53cf3c93ad1f","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"callback"},"parentToolUseID":"toolu_01388VWtzxPtL8L6K5mBEQA3","toolUseID":"toolu_01388VWtzxPtL8L6K5mBEQA3","timestamp":"2026-02-10T23:24:13.106Z","uuid":"a27315b3-c8dd-4dfe-9c2d-ce49b046fa81"}
{"parentUuid":"b2c9483c-be83-49e7-806f-53cf3c93ad1f","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01388VWtzxPtL8L6K5mBEQA3","type":"tool_result","content":"The file /Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services/src/lws/cli/ldk.py has been updated successfully."}]},"uuid":"4cbdc002-bd2d-4e9c-a813-bbe83caa8cbd","timestamp":"2026-02-10T23:24:13.105Z","toolUseResult":{"filePath":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services/src/lws/cli/ldk.py","oldString":"def _add_service_metadata(\n    services: dict[str, Any], app_model: AppModel, ports: dict[str, int]\n) -> None:\n    \"\"\"Add non-API service metadata to services.\"\"\"\n    if app_model.functions:\n        services[\"lambda\"] = {\n            \"resources\": [\n                {\n                    \"name\": f.name,\n                    \"runtime\": f.runtime,\n                    \"arn\": f\"arn:aws:lambda:us-east-1:000000000000:function:{f.name}\",\n                }\n                for f in app_model.functions\n            ],\n        }\n    if app_model.tables:\n        services[\"dynamodb\"] = {\n            \"port\": ports[\"dynamodb\"],\n            \"resources\": [{\"name\": t.name} for t in app_model.tables],\n        }\n    if app_model.queues:\n        sqs_port = ports[\"sqs\"]\n        services[\"sqs\"] = {\n            \"port\": sqs_port,\n            \"resources\": [\n                {\n                    \"name\": q.name,\n                    \"queue_url\": f\"http://localhost:{sqs_port}/000000000000/{q.name}\",\n                }\n                for q in app_model.queues\n            ],\n        }\n    if app_model.buckets:\n        services[\"s3\"] = {\n            \"port\": ports[\"s3\"],\n            \"resources\": [{\"name\": b.name} for b in app_model.buckets],\n        }\n    if app_model.topics:\n        services[\"sns\"] = {\n            \"port\": ports[\"sns\"],\n            \"resources\": [\n                {\n                    \"name\": t.name,\n                    \"arn\": t.topic_arn or f\"arn:aws:sns:us-east-1:000000000000:{t.name}\",\n                }\n                for t in app_model.topics\n            ],\n        }\n    if app_model.event_buses:\n        services[\"events\"] = {\n            \"port\": ports[\"events\"],\n            \"resources\": [\n                {\n                    \"name\": b.name,\n                    \"arn\": b.bus_arn or f\"arn:aws:events:us-east-1:000000000000:event-bus/{b.name}\",\n                }\n                for b in app_model.event_buses\n            ],\n        }\n    if app_model.state_machines:\n        services[\"stepfunctions\"] = {\n            \"port\": ports[\"stepfunctions\"],\n            \"resources\": [\n                {\n                    \"name\": sm.name,\n                    \"arn\": f\"arn:aws:states:us-east-1:000000000000:stateMachine:{sm.name}\",\n                }\n                for sm in app_model.state_machines\n            ],\n        }\n    if app_model.user_pools:\n        services[\"cognito-idp\"] = {\n            \"port\": ports[\"cognito-idp\"],\n            \"resources\": [\n                {\"name\": p.user_pool_name, \"user_pool_id\": f\"us-east-1_{p.logical_id}\"}\n                for p in app_model.user_pools\n            ],\n        }\n    if app_model.ssm_parameters:\n        services[\"ssm\"] = {\n            \"port\": ports[\"ssm\"],\n            \"resources\": [{\"name\": p.name} for p in app_model.ssm_parameters],\n        }\n    if app_model.secrets:\n        services[\"secretsmanager\"] = {\n            \"port\": ports[\"secretsmanager\"],\n            \"resources\": [\n                {\n                    \"name\": s.name,\n                    \"arn\": f\"arn:aws:secretsmanager:us-east-1:000000000000:secret:{s.name}\",\n                }\n                for s in app_model.secrets\n            ],\n        }","newString":"def _add_service_metadata(\n    services: dict[str, Any], app_model: AppModel, ports: dict[str, int]\n) -> None:\n    \"\"\"Add non-API service metadata to services.\"\"\"\n    if app_model.functions:\n        services[\"lambda\"] = {\n            \"resources\": [\n                {\n                    \"name\": f.name,\n                    \"runtime\": f.runtime,\n                    \"arn\": f\"arn:aws:lambda:us-east-1:000000000000:function:{f.name}\",\n                }\n                for f in app_model.functions\n            ],\n        }\n    if app_model.tables:\n        services[\"dynamodb\"] = {\n            \"port\": ports[\"dynamodb\"],\n            \"resources\": [{\"name\": t.name} for t in app_model.tables],\n        }\n    if app_model.queues:\n        sqs_port = ports[\"sqs\"]\n        services[\"sqs\"] = {\n            \"port\": sqs_port,\n            \"resources\": [\n                {\n                    \"name\": q.name,\n                    \"queue_url\": f\"http://localhost:{sqs_port}/000000000000/{q.name}\",\n                }\n                for q in app_model.queues\n            ],\n        }\n    if app_model.buckets:\n        services[\"s3\"] = {\n            \"port\": ports[\"s3\"],\n            \"resources\": [{\"name\": b.name} for b in app_model.buckets],\n        }\n    if app_model.topics:\n        services[\"sns\"] = {\n            \"port\": ports[\"sns\"],\n            \"resources\": [\n                {\n                    \"name\": t.name,\n                    \"arn\": t.topic_arn or f\"arn:aws:sns:us-east-1:000000000000:{t.name}\",\n                }\n                for t in app_model.topics\n            ],\n        }\n    _add_extended_service_metadata(services, app_model, ports)\n\n\ndef _add_extended_service_metadata(\n    services: dict[str, Any], app_model: AppModel, ports: dict[str, int]\n) -> None:\n    \"\"\"Add EventBridge, Step Functions, Cognito, SSM and Secrets Manager metadata.\"\"\"\n    if app_model.event_buses:\n        services[\"events\"] = {\n            \"port\": ports[\"events\"],\n            \"resources\": [\n                {\n                    \"name\": b.name,\n                    \"arn\": b.bus_arn or f\"arn:aws:events:us-east-1:000000000000:event-bus/{b.name}\",\n                }\n                for b in app_model.event_buses\n            ],\n        }\n    if app_model.state_machines:\n        services[\"stepfunctions\"] = {\n            \"port\": ports[\"stepfunctions\"],\n            \"resources\": [\n                {\n                    \"name\": sm.name,\n                    \"arn\": f\"arn:aws:states:us-east-1:000000000000:stateMachine:{sm.name}\",\n                }\n                for sm in app_model.state_machines\n            ],\n        }\n    if app_model.user_pools:\n        services[\"cognito-idp\"] = {\n            \"port\": ports[\"cognito-idp\"],\n            \"resources\": [\n                {\"name\": p.user_pool_name, \"user_pool_id\": f\"us-east-1_{p.logical_id}\"}\n                for p in app_model.user_pools\n            ],\n        }\n    if app_model.ssm_parameters:\n        services[\"ssm\"] = {\n            \"port\": ports[\"ssm\"],\n            \"resources\": [{\"name\": p.name} for p in app_model.ssm_parameters],\n        }\n    if app_model.secrets:\n        services[\"secretsmanager\"] = {\n            \"port\": ports[\"secretsmanager\"],\n            \"resources\": [\n                {\n                    \"name\": s.name,\n                    \"arn\": f\"arn:aws:secretsmanager:us-east-1:000000000000:secret:{s.name}\",\n                }\n                for s in app_model.secrets\n            ],\n        }","originalFile":"\"\"\"LDK CLI entry point.\n\nProvides the ``ldk dev``, ``ldk invoke``, and ``ldk reset`` commands.\n``ldk dev`` parses a CDK cloud assembly, builds the application graph,\nstarts local providers, and watches for file changes.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport asyncio\nimport json\nimport logging\nimport shutil\nfrom collections.abc import Callable\nfrom pathlib import Path\nfrom typing import Any\n\nimport typer\nimport uvicorn\nfrom rich.console import Console\nfrom rich.syntax import Syntax\n\nfrom lws.cli.display import (\n    print_banner,\n    print_error,\n    print_resource_summary,\n    print_startup_complete,\n)\nfrom lws.config.loader import ConfigError, LdkConfig, load_config\nfrom lws.graph.builder import AppGraph, NodeType, build_graph\nfrom lws.interfaces import (\n    ComputeConfig,\n    GsiDefinition,\n    ICompute,\n    KeyAttribute,\n    KeySchema,\n    Provider,\n    TableConfig,\n)\nfrom lws.parser.assembly import AppModel, parse_assembly\nfrom lws.providers.apigateway.provider import ApiGatewayProvider, RouteConfig\nfrom lws.providers.cognito.provider import CognitoProvider\nfrom lws.providers.cognito.user_store import PasswordPolicy, UserPoolConfig\nfrom lws.providers.dynamodb.provider import SqliteDynamoProvider\nfrom lws.providers.dynamodb.routes import create_dynamodb_app\nfrom lws.providers.ecs.provider import EcsProvider\nfrom lws.providers.eventbridge.provider import (\n    EventBridgeProvider,\n    EventBusConfig,\n    RuleConfig,\n    RuleTarget,\n)\nfrom lws.providers.lambda_runtime.nodejs import NodeJsCompute\nfrom lws.providers.lambda_runtime.python import PythonCompute\nfrom lws.providers.s3.provider import S3Provider\nfrom lws.providers.s3.routes import create_s3_app\nfrom lws.providers.sns.provider import SnsProvider, TopicConfig\nfrom lws.providers.sns.routes import create_sns_app\nfrom lws.providers.sqs.provider import QueueConfig, RedrivePolicy, SqsProvider\nfrom lws.providers.sqs.routes import create_sqs_app\nfrom lws.providers.stepfunctions.provider import (\n    StateMachineConfig,\n    StepFunctionsProvider,\n    WorkflowType,\n)\nfrom lws.runtime.env_builder import build_lambda_env\nfrom lws.runtime.orchestrator import Orchestrator\nfrom lws.runtime.sdk_env import build_sdk_env\nfrom lws.runtime.synth import SynthError, ensure_synth\nfrom lws.runtime.watcher import FileWatcher\n\n_console = Console()\n\napp = typer.Typer(name=\"ldk\", help=\"Local Development Kit - Run AWS CDK applications locally\")\n\n__version__ = \"0.4.0\"\n\n\n@app.callback()\ndef main() -> None:\n    \"\"\"LDK - Local Development Kit.\"\"\"\n\n\n@app.command()\ndef dev(\n    port: int = typer.Option(None, \"--port\", \"-p\", help=\"API Gateway listen port\"),\n    no_persist: bool = typer.Option(False, \"--no-persist\", help=\"Disable data persistence\"),\n    force_synth: bool = typer.Option(False, \"--force-synth\", help=\"Force CDK synth\"),\n    log_level: str = typer.Option(\n        None, \"--log-level\", \"-l\", help=\"Log level (debug/info/warning/error)\"\n    ),\n    project_dir: Path = typer.Option(\".\", \"--project-dir\", \"-d\", help=\"Project root directory\"),\n    mode: str = typer.Option(None, \"--mode\", \"-m\", help=\"Project mode (cdk or terraform)\"),\n) -> None:\n    \"\"\"Start the local development environment.\"\"\"\n    try:\n        asyncio.run(_run_dev(project_dir, port, no_persist, force_synth, log_level, mode))\n    except KeyboardInterrupt:\n        pass\n\n\n@app.command()\ndef invoke(\n    function_name: str = typer.Option(..., \"--function-name\", \"-f\", help=\"Lambda function name\"),\n    event: str = typer.Option(None, \"--event\", \"-e\", help=\"Inline JSON event payload\"),\n    event_file: Path = typer.Option(None, \"--event-file\", help=\"Path to JSON event file\"),\n    project_dir: Path = typer.Option(\".\", \"--project-dir\", \"-d\", help=\"Project root directory\"),\n    port: int = typer.Option(None, \"--port\", \"-p\", help=\"Management API port\"),\n) -> None:\n    \"\"\"Invoke a Lambda function directly.\"\"\"\n    asyncio.run(_run_invoke(function_name, event, event_file, project_dir, port))\n\n\nasync def _run_invoke(\n    function_name: str,\n    event_json: str | None,\n    event_file: Path | None,\n    project_dir: Path,\n    port_override: int | None,\n) -> None:\n    \"\"\"Async implementation of the ``ldk invoke`` command.\"\"\"\n    # Resolve event payload\n    event_payload = _resolve_event_payload(event_json, event_file)\n\n    # Try connecting to running ldk dev via management API\n    project_dir = project_dir.resolve()\n    config = _load_config_quiet(project_dir)\n    mgmt_port = port_override or config.port\n\n    if await _try_management_invoke(mgmt_port, function_name, event_payload):\n        return\n\n    # Fallback: one-shot invocation\n    _console.print(\"[dim]No running ldk dev found, performing one-shot invocation...[/dim]\")\n    await _oneshot_invoke(project_dir, config, function_name, event_payload)\n\n\ndef _resolve_event_payload(event_json: str | None, event_file: Path | None) -> dict:\n    \"\"\"Parse event payload from CLI args.\"\"\"\n    if event_json is not None:\n        try:\n            return json.loads(event_json)\n        except json.JSONDecodeError as exc:\n            print_error(\"Invalid JSON in --event\", str(exc))\n            raise typer.Exit(1)\n\n    if event_file is not None:\n        if not event_file.exists():\n            print_error(\"Event file not found\", str(event_file))\n            raise typer.Exit(1)\n        try:\n            return json.loads(event_file.read_text())\n        except json.JSONDecodeError as exc:\n            print_error(\"Invalid JSON in event file\", str(exc))\n            raise typer.Exit(1)\n\n    return {}\n\n\nasync def _try_management_invoke(port: int, function_name: str, event: dict) -> bool:\n    \"\"\"Try to invoke via the management API. Return True if successful.\"\"\"\n    try:\n        import httpx\n\n        async with httpx.AsyncClient() as client:\n            resp = await client.post(\n                f\"http://localhost:{port}/_ldk/invoke\",\n                json={\"function_name\": function_name, \"event\": event},\n                timeout=30.0,\n            )\n            result = resp.json()\n            formatted = json.dumps(result, indent=2)\n            syntax = Syntax(formatted, \"json\", theme=\"monokai\")\n            _console.print(syntax)\n            return True\n    except Exception:\n        return False\n\n\nasync def _oneshot_invoke(\n    project_dir: Path, config: LdkConfig, function_name: str, event: dict\n) -> None:\n    \"\"\"Perform a one-shot Lambda invocation without a running server.\"\"\"\n    try:\n        import uuid as _uuid\n\n        from lws.interfaces import InvocationResult, LambdaContext\n\n        cdk_out = project_dir / config.cdk_out_dir\n        if not cdk_out.exists():\n            print_error(\"CDK output not found\", f\"Run 'cdk synth' first in {project_dir}\")\n            raise typer.Exit(1)\n\n        app_model = parse_assembly(cdk_out)\n        func_def = next((f for f in app_model.functions if f.name == function_name), None)\n        if func_def is None:\n            print_error(\"Function not found\", f\"No function named '{function_name}'\")\n            raise typer.Exit(1)\n\n        sdk_env = build_sdk_env({})\n        func_env = build_lambda_env(\n            function_name=func_def.name,\n            function_env=func_def.environment,\n            local_endpoints={},\n            resolved_refs={},\n        )\n        compute_config = ComputeConfig(\n            function_name=func_def.name,\n            handler=func_def.handler,\n            runtime=func_def.runtime,\n            code_path=func_def.code_path or Path(\".\"),\n            timeout=func_def.timeout,\n            memory_size=func_def.memory,\n            environment=func_env,\n        )\n        compute = NodeJsCompute(config=compute_config, sdk_env=sdk_env)\n        await compute.start()\n\n        request_id = str(_uuid.uuid4())\n        context = LambdaContext(\n            function_name=function_name,\n            memory_limit_in_mb=compute_config.memory_size,\n            timeout_seconds=compute_config.timeout,\n            aws_request_id=request_id,\n            invoked_function_arn=(\n                f\"arn:aws:lambda:us-east-1:000000000000:function:{function_name}\"\n            ),\n        )\n\n        result: InvocationResult = await compute.invoke(event, context)\n        await compute.stop()\n\n        output = result.payload if result.error is None else {\"error\": result.error}\n        formatted = json.dumps(output, indent=2, default=str)\n        syntax = Syntax(formatted, \"json\", theme=\"monokai\")\n        _console.print(syntax)\n\n    except typer.Exit:\n        raise\n    except Exception as exc:\n        print_error(\"Invocation failed\", str(exc))\n        raise typer.Exit(1)\n\n\n@app.command()\ndef reset(\n    yes: bool = typer.Option(False, \"--yes\", \"-y\", help=\"Skip confirmation prompt\"),\n    project_dir: Path = typer.Option(\".\", \"--project-dir\", \"-d\", help=\"Project root directory\"),\n    port: int = typer.Option(None, \"--port\", \"-p\", help=\"Management API port\"),\n) -> None:\n    \"\"\"Reset all LDK local state (databases, queues, etc.).\"\"\"\n    project_dir = project_dir.resolve()\n    config = _load_config_quiet(project_dir)\n    data_dir = project_dir / config.data_dir\n\n    if not data_dir.exists():\n        _console.print(\"[dim]No data directory found. Nothing to reset.[/dim]\")\n        return\n\n    # List contents to be deleted\n    items = list(data_dir.iterdir())\n    if not items:\n        _console.print(\"[dim]Data directory is empty. Nothing to reset.[/dim]\")\n        return\n\n    _console.print(f\"[bold]Will delete all files under:[/bold] {data_dir}\")\n    for item in items:\n        kind = \"dir\" if item.is_dir() else \"file\"\n        _console.print(f\"  [dim]{kind}:[/dim] {item.name}\")\n\n    if not yes:\n        confirm = typer.confirm(\"Are you sure you want to delete all local state?\")\n        if not confirm:\n            _console.print(\"[dim]Aborted.[/dim]\")\n            return\n\n    # Delete contents\n    deleted_count = 0\n    for item in items:\n        if item.is_dir():\n            shutil.rmtree(item)\n        else:\n            item.unlink()\n        deleted_count += 1\n\n    _console.print(f\"[green]Deleted {deleted_count} item(s) from {data_dir}[/green]\")\n\n    # Notify running ldk dev if possible\n    mgmt_port = port or config.port\n    asyncio.run(_try_management_reset(mgmt_port))\n\n\nasync def _try_management_reset(port: int) -> None:\n    \"\"\"Try to notify running ldk dev of the reset via management API.\"\"\"\n    try:\n        import httpx\n\n        async with httpx.AsyncClient() as client:\n            resp = await client.post(\n                f\"http://localhost:{port}/_ldk/reset\",\n                timeout=5.0,\n            )\n            if resp.status_code == 200:\n                _console.print(\"[dim]Notified running ldk dev of reset.[/dim]\")\n    except Exception:\n        pass  # Server not running, that's fine\n\n\ndef _load_config_quiet(project_dir: Path) -> LdkConfig:\n    \"\"\"Load config without printing errors. Falls back to defaults.\"\"\"\n    try:\n        return load_config(project_dir)\n    except ConfigError:\n        return LdkConfig()\n\n\ndef _load_and_apply_config(\n    project_dir: Path,\n    port_override: int | None,\n    no_persist: bool,\n    log_level_override: str | None,\n) -> LdkConfig:\n    \"\"\"Load config and apply CLI overrides.\"\"\"\n    try:\n        config = load_config(project_dir)\n    except ConfigError as exc:\n        print_error(\"Configuration error\", str(exc))\n        raise typer.Exit(1)\n\n    if port_override is not None:\n        config.port = port_override\n    if log_level_override is not None:\n        config.log_level = log_level_override\n    if no_persist:\n        config.persist = False\n\n    logging.basicConfig(\n        level=getattr(logging, config.log_level.upper(), logging.INFO),\n        format=\"%(levelname)s %(name)s: %(message)s\",\n    )\n    return config\n\n\ndef _collect_extra_resources(app_model: AppModel) -> dict[str, list[str]]:\n    \"\"\"Collect extra resource name lists from the app model for display.\"\"\"\n    extras: dict[str, list[str]] = {}\n    _RESOURCE_ATTRS = {\n        \"queues\": (\"name\", \"queues\"),\n        \"buckets\": (\"name\", \"buckets\"),\n        \"topics\": (\"name\", \"topics\"),\n        \"state_machines\": (\"name\", \"state_machines\"),\n        \"ecs_services\": (\"service_name\", \"ecs_services\"),\n        \"user_pools\": (\"user_pool_name\", \"user_pools\"),\n        \"ssm_parameters\": (\"name\", \"ssm_parameters\"),\n        \"secrets\": (\"name\", \"secrets\"),\n    }\n    for key, (attr, model_attr) in _RESOURCE_ATTRS.items():\n        items = getattr(app_model, model_attr, [])\n        if items:\n            extras[key] = [getattr(item, attr, str(item)) for item in items]\n    return extras\n\n\ndef _build_local_details(app_model: AppModel, port: int) -> dict[str, str]:\n    \"\"\"Build a mapping of ``\"Type:Name\"`` to local detail strings.\"\"\"\n    details: dict[str, str] = {}\n\n    _add_api_details(details, app_model)\n    _add_resource_details(details, app_model)\n    return details\n\n\ndef _add_api_details(details: dict[str, str], app_model: AppModel) -> None:\n    \"\"\"Add API route and Lambda function details.\"\"\"\n    for api_def in app_model.apis:\n        for r in api_def.routes:\n            details[f\"API Route:{r.path}\"] = (\n                f\"lws apigateway test-invoke-method --resource {r.path} --http-method {r.method}\"\n            )\n    for f in app_model.functions:\n        details[f\"Function:{f.name}\"] = f\"ldk invoke {f.name}\"\n\n\ndef _add_resource_details(details: dict[str, str], app_model: AppModel) -> None:\n    \"\"\"Add service resource details (DynamoDB, SQS, S3, etc.).\"\"\"\n    for t in app_model.tables:\n        details[f\"Table:{t.name}\"] = f\"lws dynamodb scan --table-name {t.name}\"\n    for q in app_model.queues:\n        details[f\"Queue:{q.name}\"] = f\"lws sqs receive-message --queue-name {q.name}\"\n    for b in app_model.buckets:\n        details[f\"Bucket:{b.name}\"] = f\"lws s3api list-objects-v2 --bucket {b.name}\"\n    for t in app_model.topics:\n        details[f\"Topic:{t.name}\"] = f\"lws sns publish --topic-name {t.name} --message '...'\"\n    for b in app_model.event_buses:\n        details[f\"Event Bus:{b.name}\"] = f\"lws events list-rules --event-bus-name {b.name}\"\n    for sm in app_model.state_machines:\n        details[f\"State Machine:{sm.name}\"] = f\"lws stepfunctions start-execution --name {sm.name}\"\n    for p in app_model.user_pools:\n        details[f\"User Pool:{p.user_pool_name}\"] = (\n            f\"lws cognito-idp sign-up --user-pool-name {p.user_pool_name}\"\n        )\n    for p in app_model.ssm_parameters:\n        details[f\"Parameter:{p.name}\"] = f\"lws ssm get-parameter --name {p.name}\"\n    for s in app_model.secrets:\n        details[f\"Secret:{s.name}\"] = f\"lws secretsmanager get-secret-value --secret-id {s.name}\"\n\n\ndef _display_summary(app_model: AppModel, port: int) -> None:\n    \"\"\"Print resource summary and startup-complete banner.\"\"\"\n    routes_info = [\n        {\"method\": r.method, \"path\": r.path, \"handler\": r.handler_name or \"\"}\n        for api_def in app_model.apis\n        for r in api_def.routes\n    ]\n    tables_info = [t.name for t in app_model.tables]\n    functions_info = [f\"{f.name} ({f.runtime})\" for f in app_model.functions]\n\n    extra_resources = _collect_extra_resources(app_model)\n    local_details = _build_local_details(app_model, port)\n    print_resource_summary(\n        routes_info, tables_info, functions_info, local_details=local_details, **extra_resources\n    )\n\n    extra_counts = {f\"num_{k}\": len(v) for k, v in extra_resources.items()}\n    print_startup_complete(\n        port,\n        num_routes=len(routes_info),\n        num_tables=len(tables_info),\n        num_functions=len(functions_info),\n        **extra_counts,\n    )\n\n\ndef _resolve_mode(project_dir: Path, config: LdkConfig, mode_override: str | None) -> str:\n    \"\"\"Resolve the project mode from CLI flag, config, or auto-detection.\n\n    Returns ``\"cdk\"`` or ``\"terraform\"``.\n    Raises ``typer.Exit(1)`` on error.\n    \"\"\"\n    from lws.terraform.detect import detect_project_type\n\n    mode = mode_override or config.mode\n    if mode:\n        if mode not in (\"cdk\", \"terraform\"):\n            print_error(\"Invalid mode\", f\"Must be 'cdk' or 'terraform', got '{mode}'\")\n            raise typer.Exit(1)\n        return mode\n\n    detected = detect_project_type(project_dir)\n    if detected == \"ambiguous\":\n        print_error(\n            \"Ambiguous project\",\n            \"Both .tf files and cdk.out found. Use --mode cdk or --mode terraform.\",\n        )\n        raise typer.Exit(1)\n    if detected == \"none\":\n        print_error(\n            \"No project found\",\n            \"No .tf files or cdk.out directory found. \"\n            \"Run from a CDK or Terraform project directory.\",\n        )\n        raise typer.Exit(1)\n    return detected\n\n\nasync def _run_dev_terraform(project_dir: Path, config: LdkConfig) -> None:\n    \"\"\"Run the dev server in Terraform mode.\n\n    Starts all service providers in always-on mode, generates the\n    Terraform provider override file, and waits for shutdown.\n    \"\"\"\n    from lws.terraform.gitignore import ensure_gitignore\n    from lws.terraform.override import cleanup_override, generate_override\n\n    port = config.port\n    data_dir = project_dir / config.data_dir\n    data_dir.mkdir(parents=True, exist_ok=True)\n\n    # Generate override file\n    try:\n        override_path = generate_override(port, project_dir)\n    except FileExistsError as exc:\n        print_error(\"Override file conflict\", str(exc))\n        raise typer.Exit(1)\n\n    ensure_gitignore(project_dir)\n\n    # Create all providers in always-on mode (no app model)\n    providers, ports = _create_terraform_providers(config, data_dir, project_dir)\n\n    orchestrator = Orchestrator()\n\n    # Enable WebSocket log streaming\n    from lws.logging.logger import WebSocketLogHandler, set_ws_handler\n\n    ws_log_handler = WebSocketLogHandler()\n    set_ws_handler(ws_log_handler)\n\n    # Build resource metadata so the CLI client can discover services\n    resource_metadata: dict[str, Any] = {\n        \"port\": port,\n        \"services\": {\n            svc_name: {\"port\": svc_port, \"resources\": []} for svc_name, svc_port in ports.items()\n        },\n    }\n\n    # Mount management API (no compute providers in terraform mode)\n    _mount_management_api(providers, orchestrator, {}, port, resource_metadata)\n\n    for key in providers:\n        pass  # All keys are already in the dict\n\n    startup_order = list(providers.keys())\n\n    try:\n        await orchestrator.start(providers, startup_order)\n    except Exception as exc:\n        cleanup_override(project_dir)\n        print_error(\"Failed to start providers\", str(exc))\n        raise typer.Exit(1)\n\n    # Display summary\n    _console.print()\n    _console.print(\"[bold green]Terraform mode active[/bold green]\")\n    _console.print(f\"  Override file: {override_path}\")\n    _console.print()\n    _console.print(\"[bold]Service endpoints:[/bold]\")\n    for svc_name, svc_port in sorted(ports.items()):\n        _console.print(f\"  {svc_name:20s} http://localhost:{svc_port}\")\n    _console.print()\n    _console.print(\"[dim]Run 'terraform init && terraform apply' to create resources.[/dim]\")\n    _console.print(f\"  Dashboard: http://localhost:{config.port}/_ldk/gui\")\n    _console.print()\n\n    try:\n        await orchestrator.wait_for_shutdown()\n    finally:\n        cleanup_override(project_dir)\n        set_ws_handler(None)\n        await orchestrator.stop()\n        typer.echo(\"Goodbye\")\n\n\ndef _create_terraform_providers(\n    config: LdkConfig,\n    data_dir: Path,\n    project_dir: Path | None = None,\n) -> tuple[dict[str, Provider], dict[str, int]]:\n    \"\"\"Create all service providers for Terraform mode (no app model).\"\"\"\n    providers: dict[str, Provider] = {}\n\n    port = config.port\n    ports = {\n        \"dynamodb\": port + 1,\n        \"sqs\": port + 2,\n        \"s3\": port + 3,\n        \"sns\": port + 4,\n        \"eventbridge\": port + 5,\n        \"stepfunctions\": port + 6,\n        \"cognito\": port + 7,\n        \"apigateway\": port + 8,\n        \"lambda\": port + 9,\n        \"iam\": port + 10,\n        \"sts\": port + 11,\n        \"ssm\": port + 12,\n        \"secretsmanager\": port + 13,\n    }\n\n    dynamo_provider = SqliteDynamoProvider(data_dir=data_dir, tables=[])\n    sqs_provider = SqsProvider()\n    s3_provider = S3Provider(data_dir=data_dir)\n    sns_provider = SnsProvider()\n    eb_provider = EventBridgeProvider()\n    sf_provider = StepFunctionsProvider()\n\n    pool_config = UserPoolConfig(\n        user_pool_id=\"us-east-1_default\",\n        user_pool_name=\"default\",\n    )\n    cognito_provider = CognitoProvider(data_dir=data_dir, config=pool_config)\n\n    _register_http_providers(\n        providers,\n        dynamo_provider=dynamo_provider,\n        sqs_provider=sqs_provider,\n        s3_provider=s3_provider,\n        sns_provider=sns_provider,\n        eb_provider=eb_provider,\n        sf_provider=sf_provider,\n        cognito_provider=cognito_provider,\n        ports=ports,\n    )\n\n    # Shared Lambda registry for Lambda management and API Gateway V2 proxy\n    from lws.providers.lambda_runtime.routes import LambdaRegistry, create_lambda_management_app\n\n    lambda_registry = LambdaRegistry()\n\n    # Wire Lambda registry compute providers into Step Functions so SFN can\n    # invoke Lambda functions that Terraform creates dynamically.\n    sf_provider.set_compute_providers(lambda_registry._compute)\n\n    # Build SDK env so Lambda functions can reach local services\n    local_endpoints: dict[str, str] = {\n        \"dynamodb\": f\"http://127.0.0.1:{ports['dynamodb']}\",\n        \"sqs\": f\"http://127.0.0.1:{ports['sqs']}\",\n        \"s3\": f\"http://127.0.0.1:{ports['s3']}\",\n        \"sns\": f\"http://127.0.0.1:{ports['sns']}\",\n        \"events\": f\"http://127.0.0.1:{ports['eventbridge']}\",\n        \"stepfunctions\": f\"http://127.0.0.1:{ports['stepfunctions']}\",\n        \"cognito-idp\": f\"http://127.0.0.1:{ports['cognito']}\",\n        \"ssm\": f\"http://127.0.0.1:{ports['ssm']}\",\n        \"secretsmanager\": f\"http://127.0.0.1:{ports['secretsmanager']}\",\n    }\n    sdk_env = build_sdk_env(local_endpoints)\n\n    # Lambda management API\n    providers[\"__lambda_http__\"] = _HttpServiceProvider(\n        \"lambda-http\",\n        lambda: create_lambda_management_app(lambda_registry, project_dir, sdk_env),\n        ports[\"lambda\"],\n    )\n\n    # API Gateway management API with V2 support and Lambda proxy\n    from lws.providers.apigateway.routes import create_apigateway_management_app\n\n    providers[\"__apigateway_http__\"] = _HttpServiceProvider(\n        \"apigateway-http\",\n        lambda: create_apigateway_management_app(lambda_registry),\n        ports[\"apigateway\"],\n    )\n\n    # IAM stub\n    from lws.providers.iam.routes import create_iam_app\n\n    providers[\"__iam_http__\"] = _HttpServiceProvider(\"iam-http\", create_iam_app, ports[\"iam\"])\n\n    # STS stub\n    from lws.providers.sts.routes import create_sts_app\n\n    providers[\"__sts_http__\"] = _HttpServiceProvider(\"sts-http\", create_sts_app, ports[\"sts\"])\n\n    # SSM Parameter Store\n    from lws.providers.ssm.routes import create_ssm_app\n\n    providers[\"__ssm_http__\"] = _HttpServiceProvider(\"ssm-http\", create_ssm_app, ports[\"ssm\"])\n\n    # Secrets Manager\n    from lws.providers.secretsmanager.routes import create_secretsmanager_app\n\n    providers[\"__secretsmanager_http__\"] = _HttpServiceProvider(\n        \"secretsmanager-http\", create_secretsmanager_app, ports[\"secretsmanager\"]\n    )\n\n    return providers, ports\n\n\ndef _has_any_resources(app_model: AppModel) -> bool:\n    \"\"\"Return True if the app model contains at least one resource.\"\"\"\n    return bool(\n        app_model.functions\n        or app_model.tables\n        or app_model.apis\n        or app_model.queues\n        or app_model.buckets\n        or app_model.topics\n        or app_model.event_buses\n        or app_model.state_machines\n        or app_model.ecs_services\n        or app_model.user_pools\n        or app_model.ssm_parameters\n        or app_model.secrets\n    )\n\n\nasync def _run_dev(\n    project_dir: Path,\n    port_override: int | None,\n    no_persist: bool,\n    force_synth: bool,\n    log_level_override: str | None,\n    mode_override: str | None = None,\n) -> None:\n    \"\"\"Async implementation of the ``ldk dev`` command.\"\"\"\n    project_dir = project_dir.resolve()\n    config = _load_and_apply_config(project_dir, port_override, no_persist, log_level_override)\n    print_banner(__version__, project_dir.name)\n\n    # Resolve project mode\n    resolved_mode = _resolve_mode(project_dir, config, mode_override)\n    if resolved_mode == \"terraform\":\n        await _run_dev_terraform(project_dir, config)\n        return\n\n    try:\n        cdk_out = await ensure_synth(project_dir, force=force_synth)\n    except SynthError as exc:\n        print_error(\"CDK synth failed\", str(exc))\n        raise typer.Exit(1)\n\n    app_model = parse_assembly(cdk_out)\n    if not _has_any_resources(app_model):\n        print_error(\"No resources found in cloud assembly\", str(cdk_out))\n        raise typer.Exit(1)\n\n    graph = build_graph(app_model)\n    startup_order = graph.topological_sort()\n\n    data_dir = project_dir / config.data_dir\n    data_dir.mkdir(parents=True, exist_ok=True)\n    providers, compute_providers = _create_providers(app_model, graph, config, data_dir)\n\n    orchestrator = Orchestrator()\n\n    # Enable WebSocket log streaming\n    from lws.logging.logger import WebSocketLogHandler, set_ws_handler\n\n    ws_log_handler = WebSocketLogHandler()\n    set_ws_handler(ws_log_handler)\n\n    # Mount management API\n    resource_metadata = _build_resource_metadata(app_model, config.port)\n    _mount_management_api(\n        providers, orchestrator, compute_providers, config.port, resource_metadata\n    )\n\n    # Append non-graph provider keys (HTTP servers, management) to startup order.\n    # This must happen after _mount_management_api so the fallback management\n    # HTTP server (when no API Gateway exists) is included in the startup order.\n    for key in providers:\n        if key not in startup_order:\n            startup_order.append(key)\n\n    try:\n        await orchestrator.start(providers, startup_order)\n    except Exception as exc:\n        print_error(\"Failed to start providers\", str(exc))\n        raise typer.Exit(1)\n\n    _display_summary(app_model, config.port)\n    typer.echo(f\"  Dashboard: http://localhost:{config.port}/_ldk/gui\")\n\n    watcher = FileWatcher(\n        watch_dir=project_dir,\n        include_patterns=config.watch_include,\n        exclude_patterns=config.watch_exclude,\n    )\n    watcher.on_change(lambda path: logging.getLogger(\"ldk.watcher\").info(\"Changed: %s\", path))\n    watcher.start()\n\n    try:\n        await orchestrator.wait_for_shutdown()\n    finally:\n        watcher.stop()\n        set_ws_handler(None)\n        await orchestrator.stop()\n        typer.echo(\"Goodbye\")\n\n\ndef _create_dynamo_providers(\n    app_model: AppModel,\n    graph: AppGraph,\n    data_dir: Path,\n) -> tuple[SqliteDynamoProvider, dict[str, Provider]]:\n    \"\"\"Create DynamoDB table providers from the app model.\n\n    Always returns a provider (even with no CDK tables) so the DynamoDB\n    HTTP endpoint is available for Terraform/CLI table creation.\n    \"\"\"\n    providers: dict[str, Provider] = {}\n    table_configs: list[TableConfig] = []\n    for table in app_model.tables:\n        ks = _build_key_schema(table.key_schema)\n        gsi_defs = [_build_gsi(g) for g in table.gsi_definitions]\n        table_configs.append(\n            TableConfig(table_name=table.name, key_schema=ks, gsi_definitions=gsi_defs)\n        )\n\n    dynamo_provider = SqliteDynamoProvider(data_dir=data_dir, tables=table_configs)\n    for table in app_model.tables:\n        node_id = _find_node_id(graph, NodeType.DYNAMODB_TABLE, table.name)\n        if node_id:\n            providers[node_id] = dynamo_provider\n    return dynamo_provider, providers\n\n\ndef _create_compute_providers(\n    app_model: AppModel,\n    graph: AppGraph,\n    local_endpoints: dict[str, str],\n    sdk_env: dict[str, str],\n) -> tuple[dict[str, ICompute], dict[str, Provider]]:\n    \"\"\"Create Lambda compute providers from the app model (Node.js + Python).\"\"\"\n    providers: dict[str, Provider] = {}\n    compute_providers: dict[str, ICompute] = {}\n    for func in app_model.functions:\n        func_env = build_lambda_env(\n            function_name=func.name,\n            function_env=func.environment,\n            local_endpoints=local_endpoints,\n            resolved_refs={},\n        )\n        compute_config = ComputeConfig(\n            function_name=func.name,\n            handler=func.handler,\n            runtime=func.runtime,\n            code_path=func.code_path or Path(\".\"),\n            timeout=func.timeout,\n            memory_size=func.memory,\n            environment=func_env,\n        )\n        if func.runtime.startswith(\"python\"):\n            compute: ICompute = PythonCompute(config=compute_config, sdk_env=sdk_env)\n        elif func.runtime.startswith(\"nodejs\"):\n            compute = NodeJsCompute(config=compute_config, sdk_env=sdk_env)\n        else:\n            logging.getLogger(\"ldk.cli\").warning(\n                \"Unsupported runtime %s for %s, skipping\", func.runtime, func.name\n            )\n            continue\n        compute_providers[func.name] = compute\n        node_id = _find_node_id(graph, NodeType.LAMBDA_FUNCTION, func.name)\n        if node_id:\n            providers[node_id] = compute\n    return compute_providers, providers\n\n\ndef _create_api_providers(\n    app_model: AppModel,\n    graph: AppGraph,\n    compute_providers: dict[str, ICompute],\n    port: int,\n) -> tuple[ApiGatewayProvider | None, dict[str, Provider]]:\n    \"\"\"Create API Gateway providers from the app model.\"\"\"\n    providers: dict[str, Provider] = {}\n    api_provider: ApiGatewayProvider | None = None\n    for api_def in app_model.apis:\n        route_configs = [\n            RouteConfig(method=r.method, path=r.path, handler_name=r.handler_name)\n            for r in api_def.routes\n            if r.handler_name and r.handler_name in compute_providers\n        ]\n        if route_configs:\n            api_provider = ApiGatewayProvider(\n                routes=route_configs, compute_providers=compute_providers, port=port\n            )\n            node_id = _find_node_id(graph, NodeType.API_GATEWAY, api_def.name)\n            if node_id:\n                providers[node_id] = api_provider\n    return api_provider, providers\n\n\ndef _create_sqs_providers(\n    app_model: AppModel,\n    graph: AppGraph,\n) -> tuple[SqsProvider, dict[str, Provider]]:\n    \"\"\"Create SQS queue providers from the app model.\n\n    Always returns a provider (even with no CDK queues) so the SQS\n    HTTP endpoint is available for Terraform/CLI queue creation.\n    \"\"\"\n    providers: dict[str, Provider] = {}\n    queue_configs = []\n    for q in app_model.queues:\n        redrive = None\n        if q.redrive_target:\n            redrive = RedrivePolicy(\n                dead_letter_queue_name=q.redrive_target, max_receive_count=q.max_receive_count\n            )\n        queue_configs.append(\n            QueueConfig(\n                queue_name=q.name,\n                visibility_timeout=q.visibility_timeout,\n                is_fifo=q.is_fifo,\n                content_based_dedup=q.content_based_dedup,\n                redrive_policy=redrive,\n            )\n        )\n    sqs_provider = SqsProvider(queues=queue_configs if queue_configs else None)\n    for q in app_model.queues:\n        node_id = _find_node_id(graph, NodeType.SQS_QUEUE, q.name)\n        if node_id:\n            providers[node_id] = sqs_provider\n    return sqs_provider, providers\n\n\ndef _create_s3_providers(\n    app_model: AppModel,\n    graph: AppGraph,\n    data_dir: Path,\n) -> tuple[S3Provider, dict[str, Provider]]:\n    \"\"\"Create S3 bucket providers from the app model.\n\n    Always returns a provider (even with no CDK buckets) so the S3\n    HTTP endpoint is available for Terraform/CLI bucket creation.\n    \"\"\"\n    providers: dict[str, Provider] = {}\n    bucket_names = [b.name for b in app_model.buckets]\n    s3_provider = S3Provider(data_dir=data_dir, buckets=bucket_names if bucket_names else None)\n    for b in app_model.buckets:\n        node_id = _find_node_id(graph, NodeType.S3_BUCKET, b.name)\n        if node_id:\n            providers[node_id] = s3_provider\n    return s3_provider, providers\n\n\ndef _create_sns_providers(\n    app_model: AppModel,\n    graph: AppGraph,\n) -> tuple[SnsProvider, dict[str, Provider]]:\n    \"\"\"Create SNS topic providers from the app model.\n\n    Always returns a provider (even with no CDK topics) so the SNS\n    HTTP endpoint is available for Terraform/CLI topic creation.\n    \"\"\"\n    providers: dict[str, Provider] = {}\n    topic_configs = [\n        TopicConfig(topic_name=t.name, topic_arn=t.topic_arn) for t in app_model.topics\n    ]\n    sns_provider = SnsProvider(topics=topic_configs if topic_configs else None)\n    for t in app_model.topics:\n        node_id = _find_node_id(graph, NodeType.SNS_TOPIC, t.name)\n        if node_id:\n            providers[node_id] = sns_provider\n    return sns_provider, providers\n\n\ndef _create_eventbridge_providers(\n    app_model: AppModel,\n    graph: AppGraph,\n) -> tuple[EventBridgeProvider, dict[str, Provider]]:\n    \"\"\"Create EventBridge providers from the app model.\n\n    Always returns a provider (even with no CDK buses) so the EventBridge\n    HTTP endpoint is available for Terraform/CLI event bus creation.\n    \"\"\"\n    providers: dict[str, Provider] = {}\n    bus_configs = [\n        EventBusConfig(bus_name=b.name, bus_arn=b.bus_arn) for b in app_model.event_buses\n    ]\n    rule_configs = []\n    for r in app_model.event_rules:\n        targets = [\n            RuleTarget(target_id=t[\"target_id\"], arn=t[\"arn\"], input_path=t.get(\"input_path\"))\n            for t in r.targets\n        ]\n        rule_configs.append(\n            RuleConfig(\n                rule_name=r.rule_name,\n                event_bus_name=r.event_bus_name,\n                event_pattern=r.event_pattern,\n                schedule_expression=r.schedule_expression,\n                targets=targets,\n            )\n        )\n    eb_provider = EventBridgeProvider(\n        buses=bus_configs if bus_configs else None,\n        rules=rule_configs if rule_configs else None,\n    )\n    for b in app_model.event_buses:\n        node_id = _find_node_id(graph, NodeType.EVENT_BUS, b.name)\n        if node_id:\n            providers[node_id] = eb_provider\n    return eb_provider, providers\n\n\ndef _create_stepfunctions_providers(\n    app_model: AppModel,\n    graph: AppGraph,\n) -> tuple[StepFunctionsProvider, dict[str, Provider]]:\n    \"\"\"Create Step Functions providers from the app model.\n\n    Always returns a provider (even with no CDK state machines) so the\n    Step Functions HTTP endpoint is available for Terraform/CLI creation.\n    \"\"\"\n    providers: dict[str, Provider] = {}\n    sm_configs = []\n    for sm in app_model.state_machines:\n        wf_type = WorkflowType.EXPRESS if sm.workflow_type == \"EXPRESS\" else WorkflowType.STANDARD\n        sm_configs.append(\n            StateMachineConfig(\n                name=sm.name,\n                definition=sm.definition,\n                workflow_type=wf_type,\n                role_arn=sm.role_arn,\n                definition_substitutions=sm.definition_substitutions,\n            )\n        )\n    sf_provider = StepFunctionsProvider(\n        state_machines=sm_configs if sm_configs else None,\n    )\n    for sm in app_model.state_machines:\n        node_id = _find_node_id(graph, NodeType.STATE_MACHINE, sm.name)\n        if node_id:\n            providers[node_id] = sf_provider\n    return sf_provider, providers\n\n\ndef _create_ecs_providers(\n    app_model: AppModel,\n    graph: AppGraph,\n) -> tuple[EcsProvider, dict[str, Provider]]:\n    \"\"\"Create ECS service providers from the app model.\n\n    Always returns a provider (even with no CDK services).\n    \"\"\"\n    providers: dict[str, Provider] = {}\n    ecs_provider = EcsProvider(\n        services=app_model.ecs_services if app_model.ecs_services else None,\n    )\n    for svc in app_model.ecs_services:\n        svc_name = getattr(svc, \"service_name\", str(id(svc)))\n        node_id = _find_node_id(graph, NodeType.ECS_SERVICE, svc_name)\n        if node_id:\n            providers[node_id] = ecs_provider\n    return ecs_provider, providers\n\n\ndef _create_cognito_providers(\n    app_model: AppModel,\n    data_dir: Path,\n    compute_providers: dict[str, ICompute],\n) -> tuple[CognitoProvider, dict[str, Provider]]:\n    \"\"\"Create Cognito user pool providers from the app model.\n\n    Always returns a provider (even with no CDK user pools) so the\n    Cognito HTTP endpoint is available for Terraform/CLI user pool creation.\n    \"\"\"\n    providers: dict[str, Provider] = {}\n    if not app_model.user_pools:\n        pool_config = UserPoolConfig(\n            user_pool_id=\"us-east-1_default\",\n            user_pool_name=\"default\",\n        )\n        cognito_provider = CognitoProvider(data_dir=data_dir, config=pool_config)\n        return cognito_provider, providers\n    # Use the first user pool (multi-pool support can be added later)\n    pool = app_model.user_pools[0]\n    pw = pool.password_policy\n    password_policy = PasswordPolicy(\n        minimum_length=int(pw.get(\"MinimumLength\", 8)),\n        require_lowercase=bool(pw.get(\"RequireLowercase\", True)),\n        require_uppercase=bool(pw.get(\"RequireUppercase\", True)),\n        require_digits=bool(pw.get(\"RequireNumbers\", pw.get(\"RequireDigits\", True))),\n        require_symbols=bool(pw.get(\"RequireSymbols\", False)),\n    )\n    pool_config = UserPoolConfig(\n        user_pool_id=f\"us-east-1_{pool.logical_id}\",\n        user_pool_name=pool.user_pool_name,\n        password_policy=password_policy,\n        auto_confirm=pool.auto_confirm,\n        client_id=pool.client_id or \"local-client-id\",\n        pre_authentication_trigger=pool.pre_auth_trigger,\n        post_confirmation_trigger=pool.post_confirm_trigger,\n    )\n    trigger_funcs = {}\n    if pool.pre_auth_trigger and pool.pre_auth_trigger in compute_providers:\n        trigger_funcs[\"PreAuthentication\"] = compute_providers[pool.pre_auth_trigger]\n    if pool.post_confirm_trigger and pool.post_confirm_trigger in compute_providers:\n        trigger_funcs[\"PostConfirmation\"] = compute_providers[pool.post_confirm_trigger]\n    cognito_provider = CognitoProvider(\n        data_dir=data_dir, config=pool_config, trigger_functions=trigger_funcs or None\n    )\n    providers[f\"__cognito_{pool.logical_id}__\"] = cognito_provider\n    return cognito_provider, providers\n\n\ndef _wire_remaining_providers(\n    app_model: AppModel,\n    graph: AppGraph,\n    providers: dict[str, Provider],\n    compute_providers: dict[str, ICompute],\n    sqs_provider: SqsProvider,\n    local_endpoints: dict[str, str],\n    data_dir: Path,\n    api_port: int,\n    *,\n    sns_port: int,\n    eb_port: int,\n    sf_port: int,\n    cognito_port: int,\n) -> tuple[\n    SnsProvider,\n    EventBridgeProvider,\n    StepFunctionsProvider,\n    CognitoProvider,\n]:\n    \"\"\"Wire messaging, cognito, and API Gateway providers.\"\"\"\n    sns_provider, sns_providers = _create_sns_providers(app_model, graph)\n    providers.update(sns_providers)\n    sns_provider.set_compute_providers(compute_providers)\n    sns_provider.set_queue_provider(sqs_provider)\n    local_endpoints[\"sns\"] = f\"http://127.0.0.1:{sns_port}\"\n\n    eb_provider, eb_providers = _create_eventbridge_providers(app_model, graph)\n    providers.update(eb_providers)\n    eb_provider.set_compute_providers(compute_providers)\n    local_endpoints[\"events\"] = f\"http://127.0.0.1:{eb_port}\"\n\n    sf_provider, sf_providers = _create_stepfunctions_providers(app_model, graph)\n    providers.update(sf_providers)\n    sf_provider.set_compute_providers(compute_providers)\n    local_endpoints[\"stepfunctions\"] = f\"http://127.0.0.1:{sf_port}\"\n\n    cognito_provider, cognito_providers = _create_cognito_providers(\n        app_model, data_dir, compute_providers\n    )\n    providers.update(cognito_providers)\n    local_endpoints[\"cognito-idp\"] = f\"http://127.0.0.1:{cognito_port}\"\n\n    api_provider, api_providers = _create_api_providers(\n        app_model, graph, compute_providers, api_port\n    )\n    providers.update(api_providers)\n\n    return sns_provider, eb_provider, sf_provider, cognito_provider\n\n\ndef _create_providers(\n    app_model: AppModel,\n    graph: AppGraph,\n    config: LdkConfig,\n    data_dir: Path,\n) -> tuple[dict[str, Provider], dict[str, ICompute]]:\n    \"\"\"Instantiate providers from the parsed app model.\n\n    Returns a tuple of (provider map, compute_providers).\n    \"\"\"\n    providers: dict[str, Provider] = {}\n\n    # Port allocation: base+1 DynamoDB, +2 SQS, +3 S3, +4 SNS, +5 EventBridge,\n    # +6 Step Functions, +7 Cognito, +12 SSM, +13 Secrets Manager\n    dynamo_port = config.port + 1\n    sqs_port = config.port + 2\n    s3_port = config.port + 3\n    sns_port = config.port + 4\n    eb_port = config.port + 5\n    sf_port = config.port + 6\n    cognito_port = config.port + 7\n    ssm_port = config.port + 12\n    secretsmanager_port = config.port + 13\n\n    # 1. Storage providers (no deps)\n    dynamo_provider, dynamo_providers = _create_dynamo_providers(app_model, graph, data_dir)\n    providers.update(dynamo_providers)\n\n    sqs_provider, sqs_providers = _create_sqs_providers(app_model, graph)\n    providers.update(sqs_providers)\n\n    s3_provider, s3_providers = _create_s3_providers(app_model, graph, data_dir)\n    providers.update(s3_providers)\n\n    # 2. Build local_endpoints for SDK env redirection\n    local_endpoints: dict[str, str] = {}\n    local_endpoints[\"dynamodb\"] = f\"http://127.0.0.1:{dynamo_port}\"\n    local_endpoints[\"sqs\"] = f\"http://127.0.0.1:{sqs_port}\"\n    local_endpoints[\"s3\"] = f\"http://127.0.0.1:{s3_port}\"\n\n    # 3. Compute (Lambda — Node.js + Python)\n    sdk_env = build_sdk_env(local_endpoints)\n    compute_providers, compute_graph_providers = _create_compute_providers(\n        app_model, graph, local_endpoints, sdk_env\n    )\n    providers.update(compute_graph_providers)\n\n    # 4-6. Messaging, ECS, Cognito, API Gateway\n    sns_provider, eb_provider, sf_provider, cognito_provider = _wire_remaining_providers(\n        app_model,\n        graph,\n        providers,\n        compute_providers,\n        sqs_provider,\n        local_endpoints,\n        data_dir,\n        config.port,\n        sns_port=sns_port,\n        eb_port=eb_port,\n        sf_port=sf_port,\n        cognito_port=cognito_port,\n    )\n    ecs_provider, ecs_providers = _create_ecs_providers(app_model, graph)\n    providers.update(ecs_providers)\n\n    # 7. Add SSM and Secrets Manager endpoints, rebuild SDK env, update compute\n    local_endpoints[\"ssm\"] = f\"http://127.0.0.1:{ssm_port}\"\n    local_endpoints[\"secretsmanager\"] = f\"http://127.0.0.1:{secretsmanager_port}\"\n    sdk_env = build_sdk_env(local_endpoints)\n    for compute in compute_providers.values():\n        if hasattr(compute, \"_sdk_env\"):\n            compute._sdk_env = sdk_env\n\n    # 8. Create HTTP servers for each active service\n    _register_http_providers(\n        providers,\n        dynamo_provider=dynamo_provider,\n        sqs_provider=sqs_provider,\n        s3_provider=s3_provider,\n        sns_provider=sns_provider,\n        eb_provider=eb_provider,\n        sf_provider=sf_provider,\n        cognito_provider=cognito_provider,\n        ports={\n            \"dynamodb\": dynamo_port,\n            \"sqs\": sqs_port,\n            \"s3\": s3_port,\n            \"sns\": sns_port,\n            \"eventbridge\": eb_port,\n            \"stepfunctions\": sf_port,\n            \"cognito\": cognito_port,\n        },\n    )\n\n    # 9. SSM Parameter Store and Secrets Manager (pre-seeded from CloudFormation)\n    from lws.providers.secretsmanager.routes import create_secretsmanager_app\n    from lws.providers.ssm.routes import create_ssm_app\n\n    ssm_params = [\n        {\"name\": p.name, \"type\": p.type, \"value\": p.value, \"description\": p.description}\n        for p in app_model.ssm_parameters\n    ]\n    sm_secrets = [\n        {\"name\": s.name, \"description\": s.description, \"secret_string\": s.secret_string}\n        for s in app_model.secrets\n    ]\n\n    providers[\"__ssm_http__\"] = _HttpServiceProvider(\n        \"ssm-http\", lambda: create_ssm_app(ssm_params), ssm_port\n    )\n    providers[\"__secretsmanager_http__\"] = _HttpServiceProvider(\n        \"secretsmanager-http\", lambda: create_secretsmanager_app(sm_secrets), secretsmanager_port\n    )\n\n    return providers, compute_providers\n\n\ndef _register_http_providers(\n    providers: dict[str, Provider],\n    *,\n    dynamo_provider: SqliteDynamoProvider,\n    sqs_provider: SqsProvider,\n    s3_provider: S3Provider,\n    sns_provider: SnsProvider,\n    eb_provider: EventBridgeProvider,\n    sf_provider: StepFunctionsProvider,\n    cognito_provider: CognitoProvider,\n    ports: dict[str, int],\n) -> None:\n    \"\"\"Register HTTP service providers for each active backend.\"\"\"\n    from lws.providers.cognito.routes import create_cognito_app\n    from lws.providers.eventbridge.routes import create_eventbridge_app\n    from lws.providers.stepfunctions.routes import create_stepfunctions_app\n\n    http_services: list[tuple[str, Any, Callable[[], Any]]] = []\n    http_services.append(\n        (\"dynamodb\", ports[\"dynamodb\"], lambda p=dynamo_provider: create_dynamodb_app(p))\n    )\n    http_services.append(\n        (\"sqs\", ports[\"sqs\"], lambda p=sqs_provider, pt=ports[\"sqs\"]: create_sqs_app(p, pt))\n    )\n    http_services.append((\"s3\", ports[\"s3\"], lambda p=s3_provider: create_s3_app(p)))\n    http_services.append((\"sns\", ports[\"sns\"], lambda p=sns_provider: create_sns_app(p)))\n    http_services.append(\n        (\"eventbridge\", ports[\"eventbridge\"], lambda p=eb_provider: create_eventbridge_app(p))\n    )\n    http_services.append(\n        (\n            \"stepfunctions\",\n            ports[\"stepfunctions\"],\n            lambda p=sf_provider: create_stepfunctions_app(p),\n        )\n    )\n    http_services.append(\n        (\"cognito\", ports[\"cognito\"], lambda p=cognito_provider: create_cognito_app(p))\n    )\n\n    for svc_name, port, factory in http_services:\n        providers[f\"__{svc_name}_http__\"] = _HttpServiceProvider(f\"{svc_name}-http\", factory, port)\n\n\nclass _HttpServiceProvider(Provider):\n    \"\"\"Generic wrapper that runs any FastAPI app as a uvicorn-served Provider.\"\"\"\n\n    def __init__(self, service_name: str, app_factory: Callable[[], Any], port: int) -> None:\n        self._service_name = service_name\n        self._app_factory = app_factory\n        self._port = port\n        self._server: uvicorn.Server | None = None\n        self._task: asyncio.Task | None = None  # type: ignore[type-arg]\n\n    @property\n    def name(self) -> str:\n        return self._service_name\n\n    async def start(self) -> None:\n        http_app = self._app_factory()\n        uvi_config = uvicorn.Config(\n            app=http_app,\n            host=\"0.0.0.0\",\n            port=self._port,\n            log_level=\"warning\",\n        )\n        self._server = uvicorn.Server(uvi_config)\n        self._task = asyncio.create_task(self._server.serve())\n        # Wait for the server to actually bind before reporting as started\n        for _ in range(50):\n            if self._server.started:\n                break\n            await asyncio.sleep(0.1)\n\n    async def stop(self) -> None:\n        if self._server is not None:\n            self._server.should_exit = True\n        if self._task is not None:\n            await self._task\n            self._task = None\n        self._server = None\n\n    async def health_check(self) -> bool:\n        return self._server is not None\n\n\ndef _build_resource_metadata(app_model: AppModel, port: int) -> dict[str, Any]:\n    \"\"\"Build resource metadata for the ``/_ldk/resources`` endpoint.\"\"\"\n    metadata: dict[str, Any] = {\"port\": port, \"services\": {}}\n    services = metadata[\"services\"]\n    ports = _service_ports(port)\n\n    _add_api_metadata(services, app_model, port)\n    _add_service_metadata(services, app_model, ports)\n    return metadata\n\n\ndef _service_ports(port: int) -> dict[str, int]:\n    \"\"\"Return a mapping of service name to port number.\"\"\"\n    return {\n        \"dynamodb\": port + 1,\n        \"sqs\": port + 2,\n        \"s3\": port + 3,\n        \"sns\": port + 4,\n        \"events\": port + 5,\n        \"stepfunctions\": port + 6,\n        \"cognito-idp\": port + 7,\n        \"ssm\": port + 12,\n        \"secretsmanager\": port + 13,\n    }\n\n\ndef _add_api_metadata(services: dict[str, Any], app_model: AppModel, port: int) -> None:\n    \"\"\"Add API Gateway metadata to services.\"\"\"\n    if not app_model.apis:\n        return\n    routes = []\n    for api_def in app_model.apis:\n        for r in api_def.routes:\n            routes.append(\n                {\n                    \"name\": api_def.name,\n                    \"path\": r.path,\n                    \"method\": r.method,\n                    \"handler\": r.handler_name or \"\",\n                }\n            )\n    services[\"apigateway\"] = {\"port\": port, \"resources\": routes}\n\n\ndef _add_service_metadata(\n    services: dict[str, Any], app_model: AppModel, ports: dict[str, int]\n) -> None:\n    \"\"\"Add non-API service metadata to services.\"\"\"\n    if app_model.functions:\n        services[\"lambda\"] = {\n            \"resources\": [\n                {\n                    \"name\": f.name,\n                    \"runtime\": f.runtime,\n                    \"arn\": f\"arn:aws:lambda:us-east-1:000000000000:function:{f.name}\",\n                }\n                for f in app_model.functions\n            ],\n        }\n    if app_model.tables:\n        services[\"dynamodb\"] = {\n            \"port\": ports[\"dynamodb\"],\n            \"resources\": [{\"name\": t.name} for t in app_model.tables],\n        }\n    if app_model.queues:\n        sqs_port = ports[\"sqs\"]\n        services[\"sqs\"] = {\n            \"port\": sqs_port,\n            \"resources\": [\n                {\n                    \"name\": q.name,\n                    \"queue_url\": f\"http://localhost:{sqs_port}/000000000000/{q.name}\",\n                }\n                for q in app_model.queues\n            ],\n        }\n    if app_model.buckets:\n        services[\"s3\"] = {\n            \"port\": ports[\"s3\"],\n            \"resources\": [{\"name\": b.name} for b in app_model.buckets],\n        }\n    if app_model.topics:\n        services[\"sns\"] = {\n            \"port\": ports[\"sns\"],\n            \"resources\": [\n                {\n                    \"name\": t.name,\n                    \"arn\": t.topic_arn or f\"arn:aws:sns:us-east-1:000000000000:{t.name}\",\n                }\n                for t in app_model.topics\n            ],\n        }\n    if app_model.event_buses:\n        services[\"events\"] = {\n            \"port\": ports[\"events\"],\n            \"resources\": [\n                {\n                    \"name\": b.name,\n                    \"arn\": b.bus_arn or f\"arn:aws:events:us-east-1:000000000000:event-bus/{b.name}\",\n                }\n                for b in app_model.event_buses\n            ],\n        }\n    if app_model.state_machines:\n        services[\"stepfunctions\"] = {\n            \"port\": ports[\"stepfunctions\"],\n            \"resources\": [\n                {\n                    \"name\": sm.name,\n                    \"arn\": f\"arn:aws:states:us-east-1:000000000000:stateMachine:{sm.name}\",\n                }\n                for sm in app_model.state_machines\n            ],\n        }\n    if app_model.user_pools:\n        services[\"cognito-idp\"] = {\n            \"port\": ports[\"cognito-idp\"],\n            \"resources\": [\n                {\"name\": p.user_pool_name, \"user_pool_id\": f\"us-east-1_{p.logical_id}\"}\n                for p in app_model.user_pools\n            ],\n        }\n    if app_model.ssm_parameters:\n        services[\"ssm\"] = {\n            \"port\": ports[\"ssm\"],\n            \"resources\": [{\"name\": p.name} for p in app_model.ssm_parameters],\n        }\n    if app_model.secrets:\n        services[\"secretsmanager\"] = {\n            \"port\": ports[\"secretsmanager\"],\n            \"resources\": [\n                {\n                    \"name\": s.name,\n                    \"arn\": f\"arn:aws:secretsmanager:us-east-1:000000000000:secret:{s.name}\",\n                }\n                for s in app_model.secrets\n            ],\n        }\n\n\ndef _mount_management_api(\n    providers: dict[str, Provider],\n    orchestrator: Orchestrator,\n    compute_providers: dict[str, ICompute],\n    port: int,\n    resource_metadata: dict[str, Any] | None = None,\n) -> None:\n    \"\"\"Mount the management API router on the API Gateway app or create a standalone one.\"\"\"\n    from fastapi import FastAPI\n\n    from lws.api.management import create_management_router\n\n    mgmt_router = create_management_router(\n        orchestrator, compute_providers, providers, resource_metadata=resource_metadata\n    )\n\n    # Try to find an existing API Gateway provider to mount on\n    for key, prov in providers.items():\n        if isinstance(prov, ApiGatewayProvider):\n            prov.app.include_router(mgmt_router)\n            return\n\n    # No API Gateway — create a standalone FastAPI app for management\n    mgmt_app = FastAPI(title=\"LDK Management\")\n    mgmt_app.include_router(mgmt_router)\n    providers[\"__management_http__\"] = _HttpServiceProvider(\n        \"management-http\", lambda: mgmt_app, port\n    )\n\n\ndef _find_node_id(graph: AppGraph, node_type: NodeType, name: str) -> str | None:\n    \"\"\"Find a graph node ID by type and name.\"\"\"\n    for nid, node in graph.nodes.items():\n        if node.node_type == node_type and nid == name:\n            return nid\n    # Fallback: check config\n    for nid, node in graph.nodes.items():\n        if node.node_type == node_type:\n            if node.config.get(\"table_name\") == name or node.config.get(\"handler\") == name:\n                return nid\n    return name\n\n\ndef _build_key_schema(raw_schema: list[dict[str, str]]) -> KeySchema:\n    \"\"\"Convert raw key schema dicts to a KeySchema dataclass.\"\"\"\n    pk: KeyAttribute | None = None\n    sk: KeyAttribute | None = None\n    for ks in raw_schema:\n        attr = KeyAttribute(name=ks.get(\"attribute_name\", \"pk\"), type=ks.get(\"type\", \"S\"))\n        if ks.get(\"key_type\") == \"RANGE\":\n            sk = attr\n        else:\n            pk = attr\n    if pk is None:\n        pk = KeyAttribute(name=\"pk\", type=\"S\")\n    return KeySchema(partition_key=pk, sort_key=sk)\n\n\ndef _build_gsi(raw_gsi: dict) -> GsiDefinition:\n    \"\"\"Convert a raw GSI dict to a GsiDefinition dataclass.\"\"\"\n    index_name = raw_gsi.get(\"index_name\", raw_gsi.get(\"IndexName\", \"gsi\"))\n    ks_raw = raw_gsi.get(\"key_schema\", [])\n    ks = _build_key_schema(ks_raw)\n    projection = raw_gsi.get(\"projection_type\", \"ALL\")\n    return GsiDefinition(index_name=index_name, key_schema=ks, projection_type=projection)\n","structuredPatch":[{"oldStart":1411,"oldLines":6,"newStart":1411,"newLines":13,"lines":["                 for t in app_model.topics","             ],","         }","+    _add_extended_service_metadata(services, app_model, ports)","+","+","+def _add_extended_service_metadata(","+    services: dict[str, Any], app_model: AppModel, ports: dict[str, int]","+) -> None:","+    \"\"\"Add EventBridge, Step Functions, Cognito, SSM and Secrets Manager metadata.\"\"\"","     if app_model.event_buses:","         services[\"events\"] = {","             \"port\": ports[\"events\"],"]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"b2c9483c-be83-49e7-806f-53cf3c93ad1f"}
{"parentUuid":"4cbdc002-bd2d-4e9c-a813-bbe83caa8cbd","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","message":{"model":"claude-opus-4-6","id":"msg_017MXyWv1uJGX9apt1cWf5ot","type":"message","role":"assistant","content":[{"type":"text","text":"Now re-run tests and lint:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":2420,"cache_read_input_tokens":78908,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":2420},"output_tokens":2,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CY1FVTDKrRMuuxSbZVWTz","type":"assistant","uuid":"4a2c78bf-ba9c-4fc2-8cd3-ef0131997b66","timestamp":"2026-02-10T23:24:15.996Z"}
{"parentUuid":"4a2c78bf-ba9c-4fc2-8cd3-ef0131997b66","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","message":{"model":"claude-opus-4-6","id":"msg_017MXyWv1uJGX9apt1cWf5ot","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01M3Yct9jkgemaWkhCXEXPXV","name":"Bash","input":{"command":"uv run python -m pytest tests/ -x -q 2>&1 | tail -10","description":"Run unit tests","timeout":120000}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":2420,"cache_read_input_tokens":78908,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":2420},"output_tokens":2,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CY1FVTDKrRMuuxSbZVWTz","type":"assistant","uuid":"ba3004d4-95a9-4fd4-b98d-f3b9ebf313df","timestamp":"2026-02-10T23:24:17.212Z"}
{"parentUuid":"ba3004d4-95a9-4fd4-b98d-f3b9ebf313df","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","message":{"model":"claude-opus-4-6","id":"msg_017MXyWv1uJGX9apt1cWf5ot","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01CyGrb3kN45bX6gSUVBwyq3","name":"Bash","input":{"command":"uvx ruff check src/lws/parser/assembly.py src/lws/cli/ldk.py src/lws/providers/ssm/routes.py src/lws/providers/secretsmanager/routes.py src/lws/parser/tree_parser.py 2>&1","description":"Run ruff lint on changed files","timeout":60000}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":2420,"cache_read_input_tokens":78908,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":2420},"output_tokens":2,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CY1FVTDKrRMuuxSbZVWTz","type":"assistant","uuid":"c956c862-471a-49d6-8b27-ecda30c365f1","timestamp":"2026-02-10T23:24:18.819Z"}
{"parentUuid":"c956c862-471a-49d6-8b27-ecda30c365f1","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"progress","data":{"type":"bash_progress","output":"","fullOutput":"","elapsedTimeSeconds":2,"totalLines":0,"timeoutMs":120000},"toolUseID":"bash-progress-0","parentToolUseID":"toolu_01M3Yct9jkgemaWkhCXEXPXV","uuid":"a1100f6c-d05d-4eed-ac22-9b867051e062","timestamp":"2026-02-10T23:24:19.233Z"}
{"parentUuid":"a1100f6c-d05d-4eed-ac22-9b867051e062","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"progress","data":{"type":"bash_progress","output":"","fullOutput":"","elapsedTimeSeconds":3,"totalLines":0,"timeoutMs":120000},"toolUseID":"bash-progress-1","parentToolUseID":"toolu_01M3Yct9jkgemaWkhCXEXPXV","uuid":"d611c824-216a-48b4-8fed-5aaf0f5bc3fa","timestamp":"2026-02-10T23:24:20.234Z"}
{"parentUuid":"d611c824-216a-48b4-8fed-5aaf0f5bc3fa","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"progress","data":{"type":"bash_progress","output":"","fullOutput":"","elapsedTimeSeconds":4,"totalLines":0,"timeoutMs":120000},"toolUseID":"bash-progress-2","parentToolUseID":"toolu_01M3Yct9jkgemaWkhCXEXPXV","uuid":"2376a469-2d56-4929-b44a-f909057c666c","timestamp":"2026-02-10T23:24:21.237Z"}
{"parentUuid":"2376a469-2d56-4929-b44a-f909057c666c","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"progress","data":{"type":"bash_progress","output":"","fullOutput":"","elapsedTimeSeconds":5,"totalLines":0,"timeoutMs":120000},"toolUseID":"bash-progress-3","parentToolUseID":"toolu_01M3Yct9jkgemaWkhCXEXPXV","uuid":"da04ea45-ad6f-41bf-a80c-536cfafcc83b","timestamp":"2026-02-10T23:24:22.238Z"}
{"parentUuid":"da04ea45-ad6f-41bf-a80c-536cfafcc83b","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"progress","data":{"type":"bash_progress","output":"","fullOutput":"","elapsedTimeSeconds":6,"totalLines":0,"timeoutMs":120000},"toolUseID":"bash-progress-4","parentToolUseID":"toolu_01M3Yct9jkgemaWkhCXEXPXV","uuid":"ab2e19a4-9ce7-49b3-972c-5a5ce14bc9f6","timestamp":"2026-02-10T23:24:23.239Z"}
{"parentUuid":"ab2e19a4-9ce7-49b3-972c-5a5ce14bc9f6","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"progress","data":{"type":"bash_progress","output":"","fullOutput":"","elapsedTimeSeconds":7,"totalLines":0,"timeoutMs":120000},"toolUseID":"bash-progress-5","parentToolUseID":"toolu_01M3Yct9jkgemaWkhCXEXPXV","uuid":"46c0ac03-b865-44da-83d4-3df4507d626a","timestamp":"2026-02-10T23:24:24.240Z"}
{"parentUuid":"46c0ac03-b865-44da-83d4-3df4507d626a","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"progress","data":{"type":"bash_progress","output":"","fullOutput":"","elapsedTimeSeconds":8,"totalLines":0,"timeoutMs":120000},"toolUseID":"bash-progress-6","parentToolUseID":"toolu_01M3Yct9jkgemaWkhCXEXPXV","uuid":"f9e57504-5c1e-4df3-b7ae-054e1d8f77d7","timestamp":"2026-02-10T23:24:25.241Z"}
{"parentUuid":"f9e57504-5c1e-4df3-b7ae-054e1d8f77d7","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"progress","data":{"type":"bash_progress","output":"","fullOutput":"","elapsedTimeSeconds":9,"totalLines":0,"timeoutMs":120000},"toolUseID":"bash-progress-7","parentToolUseID":"toolu_01M3Yct9jkgemaWkhCXEXPXV","uuid":"df4dd9ae-987d-407b-b347-ecedcd7e8b77","timestamp":"2026-02-10T23:24:26.244Z"}
{"parentUuid":"df4dd9ae-987d-407b-b347-ecedcd7e8b77","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"progress","data":{"type":"bash_progress","output":"","fullOutput":"","elapsedTimeSeconds":10,"totalLines":0,"timeoutMs":120000},"toolUseID":"bash-progress-8","parentToolUseID":"toolu_01M3Yct9jkgemaWkhCXEXPXV","uuid":"493cf0e3-9016-4ea5-81ec-ed5114584ad7","timestamp":"2026-02-10T23:24:27.246Z"}
{"parentUuid":"493cf0e3-9016-4ea5-81ec-ed5114584ad7","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"progress","data":{"type":"bash_progress","output":"","fullOutput":"","elapsedTimeSeconds":11,"totalLines":0,"timeoutMs":120000},"toolUseID":"bash-progress-9","parentToolUseID":"toolu_01M3Yct9jkgemaWkhCXEXPXV","uuid":"f03c1740-a596-4714-87dc-d665a841d2d2","timestamp":"2026-02-10T23:24:28.248Z"}
{"parentUuid":"f03c1740-a596-4714-87dc-d665a841d2d2","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"progress","data":{"type":"bash_progress","output":"","fullOutput":"","elapsedTimeSeconds":12,"totalLines":0,"timeoutMs":120000},"toolUseID":"bash-progress-10","parentToolUseID":"toolu_01M3Yct9jkgemaWkhCXEXPXV","uuid":"233b29e6-0803-4624-afab-9dd083f2c7ba","timestamp":"2026-02-10T23:24:29.249Z"}
{"parentUuid":"233b29e6-0803-4624-afab-9dd083f2c7ba","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"progress","data":{"type":"bash_progress","output":"","fullOutput":"","elapsedTimeSeconds":13,"totalLines":0,"timeoutMs":120000},"toolUseID":"bash-progress-11","parentToolUseID":"toolu_01M3Yct9jkgemaWkhCXEXPXV","uuid":"0c28996c-c6c8-441b-ba8a-7bbc20584795","timestamp":"2026-02-10T23:24:30.252Z"}
{"parentUuid":"0c28996c-c6c8-441b-ba8a-7bbc20584795","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"progress","data":{"type":"bash_progress","output":"","fullOutput":"","elapsedTimeSeconds":14,"totalLines":0,"timeoutMs":120000},"toolUseID":"bash-progress-12","parentToolUseID":"toolu_01M3Yct9jkgemaWkhCXEXPXV","uuid":"ae223a5e-0cd8-414d-9a12-24441e05c474","timestamp":"2026-02-10T23:24:31.252Z"}
{"parentUuid":"ae223a5e-0cd8-414d-9a12-24441e05c474","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"progress","data":{"type":"bash_progress","output":"","fullOutput":"","elapsedTimeSeconds":15,"totalLines":0,"timeoutMs":120000},"toolUseID":"bash-progress-13","parentToolUseID":"toolu_01M3Yct9jkgemaWkhCXEXPXV","uuid":"01536bdb-864a-4373-86d0-41df891fa14c","timestamp":"2026-02-10T23:24:32.254Z"}
{"parentUuid":"01536bdb-864a-4373-86d0-41df891fa14c","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"progress","data":{"type":"bash_progress","output":"","fullOutput":"","elapsedTimeSeconds":16,"totalLines":0,"timeoutMs":120000},"toolUseID":"bash-progress-14","parentToolUseID":"toolu_01M3Yct9jkgemaWkhCXEXPXV","uuid":"9316b77f-99b4-4db3-bed5-513e2df8b728","timestamp":"2026-02-10T23:24:33.256Z"}
{"parentUuid":"9316b77f-99b4-4db3-bed5-513e2df8b728","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"progress","data":{"type":"bash_progress","output":"","fullOutput":"","elapsedTimeSeconds":17,"totalLines":0,"timeoutMs":120000},"toolUseID":"bash-progress-15","parentToolUseID":"toolu_01M3Yct9jkgemaWkhCXEXPXV","uuid":"ec47b023-3c69-429d-bf6e-31172a1266a0","timestamp":"2026-02-10T23:24:34.258Z"}
{"parentUuid":"ec47b023-3c69-429d-bf6e-31172a1266a0","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"progress","data":{"type":"bash_progress","output":"","fullOutput":"","elapsedTimeSeconds":18,"totalLines":0,"timeoutMs":120000},"toolUseID":"bash-progress-16","parentToolUseID":"toolu_01M3Yct9jkgemaWkhCXEXPXV","uuid":"5052546f-e92e-4f1f-a2e8-3eafe75bf07c","timestamp":"2026-02-10T23:24:35.260Z"}
{"parentUuid":"5052546f-e92e-4f1f-a2e8-3eafe75bf07c","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"progress","data":{"type":"bash_progress","output":"","fullOutput":"","elapsedTimeSeconds":19,"totalLines":0,"timeoutMs":120000},"toolUseID":"bash-progress-17","parentToolUseID":"toolu_01M3Yct9jkgemaWkhCXEXPXV","uuid":"918c104e-1715-4a90-a34b-a2c4ce026b6a","timestamp":"2026-02-10T23:24:36.261Z"}
{"parentUuid":"918c104e-1715-4a90-a34b-a2c4ce026b6a","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"progress","data":{"type":"bash_progress","output":"","fullOutput":"","elapsedTimeSeconds":20,"totalLines":0,"timeoutMs":120000},"toolUseID":"bash-progress-18","parentToolUseID":"toolu_01M3Yct9jkgemaWkhCXEXPXV","uuid":"48a67df3-9bc3-4810-b123-b1183381ca69","timestamp":"2026-02-10T23:24:37.261Z"}
{"parentUuid":"48a67df3-9bc3-4810-b123-b1183381ca69","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"progress","data":{"type":"bash_progress","output":"","fullOutput":"","elapsedTimeSeconds":21,"totalLines":0,"timeoutMs":120000},"toolUseID":"bash-progress-19","parentToolUseID":"toolu_01M3Yct9jkgemaWkhCXEXPXV","uuid":"3fbce890-2acf-4150-847b-6a605ea966c1","timestamp":"2026-02-10T23:24:38.261Z"}
{"parentUuid":"3fbce890-2acf-4150-847b-6a605ea966c1","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"progress","data":{"type":"bash_progress","output":"","fullOutput":"","elapsedTimeSeconds":22,"totalLines":0,"timeoutMs":120000},"toolUseID":"bash-progress-20","parentToolUseID":"toolu_01M3Yct9jkgemaWkhCXEXPXV","uuid":"51970808-9b37-449f-97aa-3fedbf9dea26","timestamp":"2026-02-10T23:24:39.262Z"}
{"parentUuid":"51970808-9b37-449f-97aa-3fedbf9dea26","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"progress","data":{"type":"bash_progress","output":"","fullOutput":"","elapsedTimeSeconds":23,"totalLines":0,"timeoutMs":120000},"toolUseID":"bash-progress-21","parentToolUseID":"toolu_01M3Yct9jkgemaWkhCXEXPXV","uuid":"1e3aa1ee-bde8-47ff-8460-f2fd1c4ee24c","timestamp":"2026-02-10T23:24:40.263Z"}
{"parentUuid":"1e3aa1ee-bde8-47ff-8460-f2fd1c4ee24c","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"progress","data":{"type":"bash_progress","output":"","fullOutput":"","elapsedTimeSeconds":24,"totalLines":0,"timeoutMs":120000},"toolUseID":"bash-progress-22","parentToolUseID":"toolu_01M3Yct9jkgemaWkhCXEXPXV","uuid":"3f9a9311-36c6-4141-8149-9218c23697b1","timestamp":"2026-02-10T23:24:41.265Z"}
{"parentUuid":"3f9a9311-36c6-4141-8149-9218c23697b1","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"progress","data":{"type":"bash_progress","output":"","fullOutput":"","elapsedTimeSeconds":25,"totalLines":0,"timeoutMs":120000},"toolUseID":"bash-progress-23","parentToolUseID":"toolu_01M3Yct9jkgemaWkhCXEXPXV","uuid":"1793a86b-9157-4a1e-af45-ccd41b8a326d","timestamp":"2026-02-10T23:24:42.267Z"}
{"parentUuid":"1793a86b-9157-4a1e-af45-ccd41b8a326d","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"progress","data":{"type":"bash_progress","output":"","fullOutput":"","elapsedTimeSeconds":26,"totalLines":0,"timeoutMs":120000},"toolUseID":"bash-progress-24","parentToolUseID":"toolu_01M3Yct9jkgemaWkhCXEXPXV","uuid":"b4f213b7-3047-4393-85e1-6e713f74cfef","timestamp":"2026-02-10T23:24:43.268Z"}
{"parentUuid":"b4f213b7-3047-4393-85e1-6e713f74cfef","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"progress","data":{"type":"bash_progress","output":"","fullOutput":"","elapsedTimeSeconds":27,"totalLines":0,"timeoutMs":120000},"toolUseID":"bash-progress-25","parentToolUseID":"toolu_01M3Yct9jkgemaWkhCXEXPXV","uuid":"38adce2b-921f-4195-8205-3f20193208cf","timestamp":"2026-02-10T23:24:44.268Z"}
{"parentUuid":"38adce2b-921f-4195-8205-3f20193208cf","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"progress","data":{"type":"bash_progress","output":"","fullOutput":"","elapsedTimeSeconds":28,"totalLines":0,"timeoutMs":120000},"toolUseID":"bash-progress-26","parentToolUseID":"toolu_01M3Yct9jkgemaWkhCXEXPXV","uuid":"1313bad5-077b-4687-9453-e7a1062495ee","timestamp":"2026-02-10T23:24:45.270Z"}
{"parentUuid":"1313bad5-077b-4687-9453-e7a1062495ee","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"progress","data":{"type":"bash_progress","output":"","fullOutput":"","elapsedTimeSeconds":29,"totalLines":0,"timeoutMs":120000},"toolUseID":"bash-progress-27","parentToolUseID":"toolu_01M3Yct9jkgemaWkhCXEXPXV","uuid":"ee7e2640-1b3d-4ca9-89df-e20003e76e6c","timestamp":"2026-02-10T23:24:46.272Z"}
{"parentUuid":"ee7e2640-1b3d-4ca9-89df-e20003e76e6c","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"progress","data":{"type":"bash_progress","output":"","fullOutput":"","elapsedTimeSeconds":30,"totalLines":0,"timeoutMs":120000},"toolUseID":"bash-progress-28","parentToolUseID":"toolu_01M3Yct9jkgemaWkhCXEXPXV","uuid":"058fa0e3-7251-47a4-9824-7c23bf3b53fe","timestamp":"2026-02-10T23:24:47.273Z"}
{"parentUuid":"058fa0e3-7251-47a4-9824-7c23bf3b53fe","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"progress","data":{"type":"bash_progress","output":"","fullOutput":"","elapsedTimeSeconds":31,"totalLines":0,"timeoutMs":120000},"toolUseID":"bash-progress-29","parentToolUseID":"toolu_01M3Yct9jkgemaWkhCXEXPXV","uuid":"6df65ed8-335b-4cd9-9951-945c942d9234","timestamp":"2026-02-10T23:24:48.274Z"}
{"parentUuid":"6df65ed8-335b-4cd9-9951-945c942d9234","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"progress","data":{"type":"bash_progress","output":"","fullOutput":"","elapsedTimeSeconds":32,"totalLines":0,"timeoutMs":120000},"toolUseID":"bash-progress-30","parentToolUseID":"toolu_01M3Yct9jkgemaWkhCXEXPXV","uuid":"33eeb743-5079-4d42-b210-e895b8d9bd17","timestamp":"2026-02-10T23:24:49.278Z"}
{"parentUuid":"33eeb743-5079-4d42-b210-e895b8d9bd17","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"progress","data":{"type":"bash_progress","output":"","fullOutput":"","elapsedTimeSeconds":33,"totalLines":0,"timeoutMs":120000},"toolUseID":"bash-progress-31","parentToolUseID":"toolu_01M3Yct9jkgemaWkhCXEXPXV","uuid":"bc48155f-1fcb-437e-a49a-bf6ede97197f","timestamp":"2026-02-10T23:24:50.278Z"}
{"parentUuid":"ba3004d4-95a9-4fd4-b98d-f3b9ebf313df","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01M3Yct9jkgemaWkhCXEXPXV","type":"tool_result","content":"tests/unit/providers/test_python_compute_python_compute_invoke.py::TestPythonComputeInvoke::test_invoke_timeout_kills_process\ntests/unit/providers/test_python_compute_python_compute_invoke.py::TestPythonComputeInvoke::test_invoke_timeout_message_format\n  /Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services/src/lws/providers/lambda_runtime/python.py:141: RuntimeWarning: coroutine 'AsyncMockMixin._execute_mock_call' was never awaited\n    process.send_signal(signal.SIGTERM)\n  Enable tracemalloc to get traceback where the object was allocated.\n  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.\n\n-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html\n1657 passed, 4 warnings in 32.01s","is_error":false}]},"uuid":"2981be4c-1266-4668-9d39-9b1b972d350f","timestamp":"2026-02-10T23:24:50.330Z","toolUseResult":{"stdout":"tests/unit/providers/test_python_compute_python_compute_invoke.py::TestPythonComputeInvoke::test_invoke_timeout_kills_process\ntests/unit/providers/test_python_compute_python_compute_invoke.py::TestPythonComputeInvoke::test_invoke_timeout_message_format\n  /Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services/src/lws/providers/lambda_runtime/python.py:141: RuntimeWarning: coroutine 'AsyncMockMixin._execute_mock_call' was never awaited\n    process.send_signal(signal.SIGTERM)\n  Enable tracemalloc to get traceback where the object was allocated.\n  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.\n\n-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html\n1657 passed, 4 warnings in 32.01s","stderr":"","interrupted":false,"isImage":false,"noOutputExpected":false},"sourceToolAssistantUUID":"ba3004d4-95a9-4fd4-b98d-f3b9ebf313df"}
{"parentUuid":"c956c862-471a-49d6-8b27-ecda30c365f1","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"user","message":{"role":"user","content":[{"type":"tool_result","content":"Exit code 1\nC901 `_resolve_ref_value` is too complex (12 > 10)\n   --> src/lws/parser/assembly.py:304:5\n    |\n304 | def _resolve_ref_value(r: CfnResource) -> str | None:\n    |     ^^^^^^^^^^^^^^^^^^\n305 |     \"\"\"Return the local Ref value for a single CloudFormation resource, or None.\"\"\"\n306 |     if r.resource_type == \"AWS::SQS::Queue\":\n    |\n\nFound 1 error.","is_error":true,"tool_use_id":"toolu_01CyGrb3kN45bX6gSUVBwyq3"}]},"uuid":"00db7fb0-5418-4f37-a2d7-d974bb93bdcf","timestamp":"2026-02-10T23:24:50.879Z","toolUseResult":"Error: Exit code 1\nC901 `_resolve_ref_value` is too complex (12 > 10)\n   --> src/lws/parser/assembly.py:304:5\n    |\n304 | def _resolve_ref_value(r: CfnResource) -> str | None:\n    |     ^^^^^^^^^^^^^^^^^^\n305 |     \"\"\"Return the local Ref value for a single CloudFormation resource, or None.\"\"\"\n306 |     if r.resource_type == \"AWS::SQS::Queue\":\n    |\n\nFound 1 error.","sourceToolAssistantUUID":"c956c862-471a-49d6-8b27-ecda30c365f1"}
{"parentUuid":"00db7fb0-5418-4f37-a2d7-d974bb93bdcf","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","message":{"model":"claude-opus-4-6","id":"msg_01QkeHLYpkfLWSHoCGVpkRcw","type":"message","role":"assistant","content":[{"type":"text","text":"The if/elif chain itself is counted as complex. Let me use a dispatch dictionary approach:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":713,"cache_read_input_tokens":81328,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":713},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CY1FYEDp2TaQs2yrCh8SG","type":"assistant","uuid":"14f8957b-67fc-4354-bc42-634cc5200cd5","timestamp":"2026-02-10T23:24:53.505Z"}
{"parentUuid":"14f8957b-67fc-4354-bc42-634cc5200cd5","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","message":{"model":"claude-opus-4-6","id":"msg_01QkeHLYpkfLWSHoCGVpkRcw","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_014EW7s7WKK5vfv5rcmRTxFb","name":"Edit","input":{"replace_all":false,"file_path":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services/src/lws/parser/assembly.py","old_string":"def _resolve_ref_value(r: CfnResource) -> str | None:\n    \"\"\"Return the local Ref value for a single CloudFormation resource, or None.\"\"\"\n    if r.resource_type == \"AWS::SQS::Queue\":\n        queue_name = r.properties.get(\"QueueName\", r.logical_id)\n        if isinstance(queue_name, str):\n            return f\"arn:ldk:sqs:local:000000000000:queue/{queue_name}\"\n    elif r.resource_type == \"AWS::DynamoDB::Table\":\n        table_name = r.properties.get(\"TableName\", r.logical_id)\n        if isinstance(table_name, str):\n            return table_name\n    elif r.resource_type == \"AWS::S3::Bucket\":\n        bucket_name = r.properties.get(\"BucketName\", r.logical_id)\n        return bucket_name if isinstance(bucket_name, str) else r.logical_id\n    elif r.resource_type == \"AWS::SNS::Topic\":\n        topic_name = r.properties.get(\"TopicName\", r.logical_id)\n        if isinstance(topic_name, str):\n            return f\"arn:ldk:sns:local:000000000000:{topic_name}\"\n    elif r.resource_type == \"AWS::SSM::Parameter\":\n        name = r.properties.get(\"Name\", r.logical_id)\n        if isinstance(name, str):\n            return name\n    elif r.resource_type == \"AWS::SecretsManager::Secret\":\n        name = r.properties.get(\"Name\", r.logical_id)\n        if isinstance(name, str):\n            return f\"arn:aws:secretsmanager:us-east-1:000000000000:secret:{name}\"\n    return None","new_string":"def _resolve_ref_value(r: CfnResource) -> str | None:\n    \"\"\"Return the local Ref value for a single CloudFormation resource, or None.\"\"\"\n    handler = _REF_RESOLVERS.get(r.resource_type)\n    if handler is not None:\n        return handler(r)\n    return None\n\n\ndef _ref_sqs(r: CfnResource) -> str | None:\n    queue_name = r.properties.get(\"QueueName\", r.logical_id)\n    if isinstance(queue_name, str):\n        return f\"arn:ldk:sqs:local:000000000000:queue/{queue_name}\"\n    return None\n\n\ndef _ref_dynamodb(r: CfnResource) -> str | None:\n    table_name = r.properties.get(\"TableName\", r.logical_id)\n    return table_name if isinstance(table_name, str) else None\n\n\ndef _ref_s3(r: CfnResource) -> str:\n    bucket_name = r.properties.get(\"BucketName\", r.logical_id)\n    return bucket_name if isinstance(bucket_name, str) else r.logical_id\n\n\ndef _ref_sns(r: CfnResource) -> str | None:\n    topic_name = r.properties.get(\"TopicName\", r.logical_id)\n    if isinstance(topic_name, str):\n        return f\"arn:ldk:sns:local:000000000000:{topic_name}\"\n    return None\n\n\ndef _ref_ssm(r: CfnResource) -> str | None:\n    name = r.properties.get(\"Name\", r.logical_id)\n    return name if isinstance(name, str) else None\n\n\ndef _ref_secretsmanager(r: CfnResource) -> str | None:\n    name = r.properties.get(\"Name\", r.logical_id)\n    if isinstance(name, str):\n        return f\"arn:aws:secretsmanager:us-east-1:000000000000:secret:{name}\"\n    return None\n\n\n_REF_RESOLVERS: dict[str, Callable[[CfnResource], str | None]] = {\n    \"AWS::SQS::Queue\": _ref_sqs,\n    \"AWS::DynamoDB::Table\": _ref_dynamodb,\n    \"AWS::S3::Bucket\": _ref_s3,\n    \"AWS::SNS::Topic\": _ref_sns,\n    \"AWS::SSM::Parameter\": _ref_ssm,\n    \"AWS::SecretsManager::Secret\": _ref_secretsmanager,\n}"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":713,"cache_read_input_tokens":81328,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":713},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CY1FYEDp2TaQs2yrCh8SG","type":"assistant","uuid":"aeb70c43-0fd6-4abe-af40-d6771a0f78a2","timestamp":"2026-02-10T23:25:04.308Z"}
{"parentUuid":"aeb70c43-0fd6-4abe-af40-d6771a0f78a2","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"callback"},"parentToolUseID":"toolu_014EW7s7WKK5vfv5rcmRTxFb","toolUseID":"toolu_014EW7s7WKK5vfv5rcmRTxFb","timestamp":"2026-02-10T23:25:04.316Z","uuid":"d7d9594e-3354-481d-91fd-a473b1560aa4"}
{"parentUuid":"aeb70c43-0fd6-4abe-af40-d6771a0f78a2","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_014EW7s7WKK5vfv5rcmRTxFb","type":"tool_result","content":"The file /Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services/src/lws/parser/assembly.py has been updated successfully."}]},"uuid":"d0eae0a4-7f53-4a62-b2e5-3163b0a8cda7","timestamp":"2026-02-10T23:25:04.315Z","toolUseResult":{"filePath":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services/src/lws/parser/assembly.py","oldString":"def _resolve_ref_value(r: CfnResource) -> str | None:\n    \"\"\"Return the local Ref value for a single CloudFormation resource, or None.\"\"\"\n    if r.resource_type == \"AWS::SQS::Queue\":\n        queue_name = r.properties.get(\"QueueName\", r.logical_id)\n        if isinstance(queue_name, str):\n            return f\"arn:ldk:sqs:local:000000000000:queue/{queue_name}\"\n    elif r.resource_type == \"AWS::DynamoDB::Table\":\n        table_name = r.properties.get(\"TableName\", r.logical_id)\n        if isinstance(table_name, str):\n            return table_name\n    elif r.resource_type == \"AWS::S3::Bucket\":\n        bucket_name = r.properties.get(\"BucketName\", r.logical_id)\n        return bucket_name if isinstance(bucket_name, str) else r.logical_id\n    elif r.resource_type == \"AWS::SNS::Topic\":\n        topic_name = r.properties.get(\"TopicName\", r.logical_id)\n        if isinstance(topic_name, str):\n            return f\"arn:ldk:sns:local:000000000000:{topic_name}\"\n    elif r.resource_type == \"AWS::SSM::Parameter\":\n        name = r.properties.get(\"Name\", r.logical_id)\n        if isinstance(name, str):\n            return name\n    elif r.resource_type == \"AWS::SecretsManager::Secret\":\n        name = r.properties.get(\"Name\", r.logical_id)\n        if isinstance(name, str):\n            return f\"arn:aws:secretsmanager:us-east-1:000000000000:secret:{name}\"\n    return None","newString":"def _resolve_ref_value(r: CfnResource) -> str | None:\n    \"\"\"Return the local Ref value for a single CloudFormation resource, or None.\"\"\"\n    handler = _REF_RESOLVERS.get(r.resource_type)\n    if handler is not None:\n        return handler(r)\n    return None\n\n\ndef _ref_sqs(r: CfnResource) -> str | None:\n    queue_name = r.properties.get(\"QueueName\", r.logical_id)\n    if isinstance(queue_name, str):\n        return f\"arn:ldk:sqs:local:000000000000:queue/{queue_name}\"\n    return None\n\n\ndef _ref_dynamodb(r: CfnResource) -> str | None:\n    table_name = r.properties.get(\"TableName\", r.logical_id)\n    return table_name if isinstance(table_name, str) else None\n\n\ndef _ref_s3(r: CfnResource) -> str:\n    bucket_name = r.properties.get(\"BucketName\", r.logical_id)\n    return bucket_name if isinstance(bucket_name, str) else r.logical_id\n\n\ndef _ref_sns(r: CfnResource) -> str | None:\n    topic_name = r.properties.get(\"TopicName\", r.logical_id)\n    if isinstance(topic_name, str):\n        return f\"arn:ldk:sns:local:000000000000:{topic_name}\"\n    return None\n\n\ndef _ref_ssm(r: CfnResource) -> str | None:\n    name = r.properties.get(\"Name\", r.logical_id)\n    return name if isinstance(name, str) else None\n\n\ndef _ref_secretsmanager(r: CfnResource) -> str | None:\n    name = r.properties.get(\"Name\", r.logical_id)\n    if isinstance(name, str):\n        return f\"arn:aws:secretsmanager:us-east-1:000000000000:secret:{name}\"\n    return None\n\n\n_REF_RESOLVERS: dict[str, Callable[[CfnResource], str | None]] = {\n    \"AWS::SQS::Queue\": _ref_sqs,\n    \"AWS::DynamoDB::Table\": _ref_dynamodb,\n    \"AWS::S3::Bucket\": _ref_s3,\n    \"AWS::SNS::Topic\": _ref_sns,\n    \"AWS::SSM::Parameter\": _ref_ssm,\n    \"AWS::SecretsManager::Secret\": _ref_secretsmanager,\n}","originalFile":"\"\"\"Assembly orchestrator -- top-level entry point for CDK output parsing.\n\nTies together tree parsing, template parsing, reference resolution and\nasset location to produce a single ``AppModel`` that the rest of the\nsystem can consume.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport json\nimport logging\nfrom dataclasses import dataclass, field\nfrom pathlib import Path\nfrom typing import Any\n\nfrom lws.parser.asset_parser import parse_assets\nfrom lws.parser.ref_resolver import RefResolver\nfrom lws.parser.template_parser import (\n    CfnResource,\n    extract_api_routes,\n    extract_dynamo_tables,\n    extract_lambda_functions,\n    parse_template,\n)\nfrom lws.parser.tree_parser import parse_tree\n\nlogger = logging.getLogger(__name__)\n\n# ---------------------------------------------------------------------------\n# Domain model dataclasses\n# ---------------------------------------------------------------------------\n\n\n@dataclass\nclass LambdaFunction:\n    \"\"\"Parsed Lambda function ready for local execution.\"\"\"\n\n    name: str\n    handler: str\n    runtime: str\n    code_path: Path | None = None\n    timeout: int = 30\n    memory: int = 128\n    environment: dict[str, str] = field(default_factory=dict)\n\n    @property\n    def logical_id(self) -> str:\n        return self.name\n\n\n@dataclass\nclass DynamoTable:\n    \"\"\"Parsed DynamoDB table definition.\"\"\"\n\n    name: str\n    key_schema: list[dict[str, str]] = field(default_factory=list)\n    gsi_definitions: list[dict[str, Any]] = field(default_factory=list)\n\n    @property\n    def logical_id(self) -> str:\n        return self.name\n\n    @property\n    def table_name(self) -> str:\n        return self.name\n\n\n@dataclass\nclass ApiRoute:\n    \"\"\"A single API Gateway route.\"\"\"\n\n    method: str\n    path: str\n    handler_name: str | None = None\n\n\n@dataclass\nclass ApiDefinition:\n    \"\"\"A collection of routes making up an API.\"\"\"\n\n    name: str = \"default\"\n    routes: list[ApiRoute] = field(default_factory=list)\n\n    @property\n    def logical_id(self) -> str:\n        return self.name\n\n\n@dataclass\nclass SqsQueue:\n    \"\"\"Parsed SQS queue definition.\"\"\"\n\n    name: str\n    is_fifo: bool = False\n    visibility_timeout: int = 30\n    content_based_dedup: bool = False\n    redrive_target: str | None = None\n    max_receive_count: int = 5\n\n\n@dataclass\nclass S3Bucket:\n    \"\"\"Parsed S3 bucket definition.\"\"\"\n\n    name: str\n\n\n@dataclass\nclass SnsTopic:\n    \"\"\"Parsed SNS topic definition.\"\"\"\n\n    name: str\n    topic_arn: str = \"\"\n\n\n@dataclass\nclass EventBus:\n    \"\"\"Parsed EventBridge event bus definition.\"\"\"\n\n    name: str\n    bus_arn: str = \"\"\n\n\n@dataclass\nclass EventRule:\n    \"\"\"Parsed EventBridge rule definition.\"\"\"\n\n    rule_name: str\n    event_bus_name: str = \"default\"\n    event_pattern: dict[str, Any] | None = None\n    schedule_expression: str | None = None\n    targets: list[dict[str, Any]] = field(default_factory=list)\n\n\n@dataclass\nclass StateMachine:\n    \"\"\"Parsed Step Functions state machine definition.\"\"\"\n\n    name: str\n    definition: str | dict[str, Any] = \"\"\n    workflow_type: str = \"STANDARD\"\n    role_arn: str = \"\"\n    definition_substitutions: dict[str, str] = field(default_factory=dict)\n\n\n@dataclass\nclass CognitoUserPool:\n    \"\"\"Parsed Cognito user pool definition.\"\"\"\n\n    logical_id: str\n    user_pool_name: str = \"default\"\n    auto_confirm: bool = True\n    password_policy: dict[str, Any] = field(default_factory=dict)\n    pre_auth_trigger: str | None = None\n    post_confirm_trigger: str | None = None\n    client_id: str = \"\"\n\n\n@dataclass\nclass SsmParameter:\n    \"\"\"Parsed SSM Parameter Store parameter.\"\"\"\n\n    name: str\n    type: str  # \"String\", \"StringList\", \"SecureString\"\n    value: str\n    description: str = \"\"\n\n\n@dataclass\nclass SmSecret:\n    \"\"\"Parsed Secrets Manager secret.\"\"\"\n\n    name: str\n    description: str = \"\"\n    secret_string: str | None = None\n\n\n@dataclass\nclass AppModel:\n    \"\"\"Complete parsed representation of a CDK application.\"\"\"\n\n    functions: list[LambdaFunction] = field(default_factory=list)\n    tables: list[DynamoTable] = field(default_factory=list)\n    apis: list[ApiDefinition] = field(default_factory=list)\n    queues: list[SqsQueue] = field(default_factory=list)\n    buckets: list[S3Bucket] = field(default_factory=list)\n    topics: list[SnsTopic] = field(default_factory=list)\n    event_buses: list[EventBus] = field(default_factory=list)\n    event_rules: list[EventRule] = field(default_factory=list)\n    state_machines: list[StateMachine] = field(default_factory=list)\n    user_pools: list[CognitoUserPool] = field(default_factory=list)\n    ecs_services: list[Any] = field(default_factory=list)\n    ssm_parameters: list[SsmParameter] = field(default_factory=list)\n    secrets: list[SmSecret] = field(default_factory=list)\n\n\n# ---------------------------------------------------------------------------\n# Orchestrator\n# ---------------------------------------------------------------------------\n\n\ndef parse_assembly(cdk_out_path: Path) -> AppModel:\n    \"\"\"Parse an entire CDK ``cdk.out`` directory into an :class:`AppModel`.\n\n    Parameters\n    ----------\n    cdk_out_path:\n        Path to the ``cdk.out`` directory produced by ``cdk synth``.\n\n    Returns\n    -------\n    AppModel\n    \"\"\"\n    manifest_path = cdk_out_path / \"manifest.json\"\n    if not manifest_path.exists():\n        logger.warning(\"No manifest.json found in %s\", cdk_out_path)\n        return AppModel()\n\n    with open(manifest_path, encoding=\"utf-8\") as fh:\n        manifest = json.load(fh)\n\n    # Parse assets (hash -> filesystem path)\n    asset_map = parse_assets(cdk_out_path)\n\n    # Parse tree.json if present\n    tree_path = cdk_out_path / \"tree.json\"\n    if tree_path.exists():\n        parse_tree(tree_path)  # Currently used for validation; future enrichment\n\n    # Collect all stack artifacts\n    model = AppModel()\n    for artifact_id, artifact in (manifest.get(\"artifacts\") or {}).items():\n        if artifact.get(\"type\") != \"aws:cloudformation:stack\":\n            continue\n        _process_stack(cdk_out_path, artifact_id, artifact, asset_map, model)\n\n    return model\n\n\ndef _process_stack(\n    cdk_out_path: Path,\n    artifact_id: str,\n    artifact: dict,\n    asset_map: dict[str, Path],\n    model: AppModel,\n) -> None:\n    \"\"\"Process a single CloudFormation stack artifact.\"\"\"\n    template_file = artifact.get(\"properties\", {}).get(\"templateFile\")\n    if not template_file:\n        logger.warning(\"Stack %s has no templateFile\", artifact_id)\n        return\n\n    template_path = cdk_out_path / template_file\n    if not template_path.exists():\n        logger.warning(\"Template not found: %s\", template_path)\n        return\n\n    resources = parse_template(template_path)\n    resource_type_map = {r.logical_id: r.resource_type for r in resources}\n    resource_map = _build_resource_map(resources)\n    resolver = RefResolver(resource_map=resource_map, resource_types=resource_type_map)\n\n    model.functions.extend(_collect_lambdas(resources, asset_map, cdk_out_path, resolver))\n    model.tables.extend(_collect_tables(resources, resolver))\n    api_def = _collect_api_routes(resources, resolver, artifact_id)\n    if api_def:\n        model.apis.append(api_def)\n    model.queues.extend(_collect_queues(resources, resolver))\n    model.buckets.extend(_collect_buckets(resources))\n    model.topics.extend(_collect_topics(resources, resolver))\n    model.event_buses.extend(_collect_event_buses(resources, resolver))\n    model.event_rules.extend(_collect_event_rules(resources, resolver))\n    model.state_machines.extend(_collect_state_machines(resources, resolver))\n    model.user_pools.extend(_collect_user_pools(resources, resolver))\n    model.ssm_parameters.extend(_collect_ssm_parameters(resources, resolver))\n    model.secrets.extend(_collect_secrets(resources, resolver))\n\n    # ECS needs the raw template dict\n    with open(template_path, encoding=\"utf-8\") as fh:\n        raw_template = json.load(fh)\n    ecs_services = _collect_ecs_services(raw_template)\n    model.ecs_services.extend(ecs_services)\n\n\ndef _build_resource_map(resources: list[CfnResource]) -> dict[str, str]:\n    \"\"\"Build a Ref resource_map so intrinsic ``Ref`` calls resolve to useful local values.\n\n    In real CloudFormation:\n    - ``Ref`` on an ``AWS::SQS::Queue`` returns the queue URL.\n    - ``Ref`` on an ``AWS::DynamoDB::Table`` returns the table name.\n\n    We reproduce this behaviour with deterministic local placeholders so that\n    Lambda environment variables like ``QUEUE_URL`` and ``TABLE_NAME`` resolve\n    to values the local providers can understand.\n    \"\"\"\n    resource_map: dict[str, str] = {}\n    for r in resources:\n        ref = _resolve_ref_value(r)\n        if ref is not None:\n            resource_map[r.logical_id] = ref\n    return resource_map\n\n\ndef _resolve_ref_value(r: CfnResource) -> str | None:\n    \"\"\"Return the local Ref value for a single CloudFormation resource, or None.\"\"\"\n    if r.resource_type == \"AWS::SQS::Queue\":\n        queue_name = r.properties.get(\"QueueName\", r.logical_id)\n        if isinstance(queue_name, str):\n            return f\"arn:ldk:sqs:local:000000000000:queue/{queue_name}\"\n    elif r.resource_type == \"AWS::DynamoDB::Table\":\n        table_name = r.properties.get(\"TableName\", r.logical_id)\n        if isinstance(table_name, str):\n            return table_name\n    elif r.resource_type == \"AWS::S3::Bucket\":\n        bucket_name = r.properties.get(\"BucketName\", r.logical_id)\n        return bucket_name if isinstance(bucket_name, str) else r.logical_id\n    elif r.resource_type == \"AWS::SNS::Topic\":\n        topic_name = r.properties.get(\"TopicName\", r.logical_id)\n        if isinstance(topic_name, str):\n            return f\"arn:ldk:sns:local:000000000000:{topic_name}\"\n    elif r.resource_type == \"AWS::SSM::Parameter\":\n        name = r.properties.get(\"Name\", r.logical_id)\n        if isinstance(name, str):\n            return name\n    elif r.resource_type == \"AWS::SecretsManager::Secret\":\n        name = r.properties.get(\"Name\", r.logical_id)\n        if isinstance(name, str):\n            return f\"arn:aws:secretsmanager:us-east-1:000000000000:secret:{name}\"\n    return None\n\n\ndef _collect_lambdas(\n    resources: list[CfnResource],\n    asset_map: dict[str, Path],\n    cdk_out_path: Path,\n    resolver: RefResolver,\n) -> list[LambdaFunction]:\n    \"\"\"Extract Lambda functions from parsed CloudFormation resources.\"\"\"\n    functions: list[LambdaFunction] = []\n    lambda_props_list = extract_lambda_functions(resources)\n    lambda_resources = [r for r in resources if r.resource_type == \"AWS::Lambda::Function\"]\n    for r, props in zip(lambda_resources, lambda_props_list):\n        code_path = _resolve_code_path(props.code_uri, asset_map, cdk_out_path, resolver)\n        env = {k: str(resolver.resolve(v)) for k, v in props.environment.items()}\n        functions.append(\n            LambdaFunction(\n                name=r.logical_id,\n                handler=props.handler or \"index.handler\",\n                runtime=props.runtime or \"python3.11\",\n                code_path=code_path,\n                timeout=props.timeout or 30,\n                memory=props.memory_size or 128,\n                environment=env,\n            )\n        )\n    return functions\n\n\ndef _collect_tables(\n    resources: list[CfnResource],\n    resolver: RefResolver,\n) -> list[DynamoTable]:\n    \"\"\"Extract DynamoDB tables from parsed CloudFormation resources.\"\"\"\n    tables: list[DynamoTable] = []\n    dynamo_props_list = extract_dynamo_tables(resources)\n    dynamo_resources = [r for r in resources if r.resource_type == \"AWS::DynamoDB::Table\"]\n    for r, props in zip(dynamo_resources, dynamo_props_list):\n        name = props.table_name or r.logical_id\n        if isinstance(name, dict):\n            name = str(resolver.resolve(name))\n        tables.append(\n            DynamoTable(\n                name=name,\n                key_schema=props.key_schema,\n                gsi_definitions=props.gsi_definitions,\n            )\n        )\n    return tables\n\n\ndef _collect_api_routes(\n    resources: list[CfnResource],\n    resolver: RefResolver,\n    artifact_id: str,\n) -> ApiDefinition | None:\n    \"\"\"Extract API Gateway routes from parsed CloudFormation resources.\"\"\"\n    api_routes = extract_api_routes(resources)\n    if not api_routes:\n        return None\n    routes: list[ApiRoute] = []\n    for route_props in api_routes:\n        handler_name = _find_handler_for_integration(\n            route_props.integration_uri, resources, resolver\n        )\n        routes.append(\n            ApiRoute(\n                method=route_props.http_method or \"ANY\",\n                path=route_props.resource_path or \"/\",\n                handler_name=handler_name,\n            )\n        )\n    return ApiDefinition(name=artifact_id, routes=routes)\n\n\ndef _resolve_code_from_s3_key(s3_key: str, asset_map: dict[str, Path]) -> Path | None:\n    \"\"\"Try to match an S3Key to an asset by hash.\"\"\"\n    asset_hash = s3_key.replace(\".zip\", \"\")\n    if asset_hash in asset_map:\n        return asset_map[asset_hash]\n    for hash_key, path in asset_map.items():\n        if hash_key in s3_key:\n            return path\n    return None\n\n\ndef _resolve_code_from_s3_bucket(\n    s3_bucket: dict, resolver: RefResolver, asset_map: dict[str, Path]\n) -> Path | None:\n    \"\"\"Try to match an S3Bucket ref to an asset.\"\"\"\n    resolved = str(resolver.resolve(s3_bucket))\n    for h, p in asset_map.items():\n        if h in resolved:\n            return p\n    return None\n\n\ndef _resolve_code_path(\n    code_uri: Any,\n    asset_map: dict[str, Path],\n    cdk_out_path: Path,\n    resolver: RefResolver,\n) -> Path | None:\n    \"\"\"Resolve a Lambda Code property to a local filesystem path.\"\"\"\n    if code_uri is None:\n        return None\n\n    if isinstance(code_uri, dict):\n        s3_key = code_uri.get(\"S3Key\")\n        if isinstance(s3_key, str):\n            result = _resolve_code_from_s3_key(s3_key, asset_map)\n            if result:\n                return result\n\n        s3_bucket = code_uri.get(\"S3Bucket\")\n        if isinstance(s3_bucket, dict):\n            result = _resolve_code_from_s3_bucket(s3_bucket, resolver, asset_map)\n            if result:\n                return result\n\n    if isinstance(code_uri, str):\n        candidate = cdk_out_path / code_uri\n        if candidate.exists():\n            return candidate\n\n    return None\n\n\ndef _find_handler_for_integration(\n    integration_uri: Any,\n    resources: list[CfnResource],\n    resolver: RefResolver,\n) -> str | None:\n    \"\"\"Try to match an API integration URI back to a Lambda logical ID.\"\"\"\n    if integration_uri is None:\n        return None\n\n    resolved = str(resolver.resolve(integration_uri))\n\n    # Look for a Lambda function logical ID in the resolved string\n    for r in resources:\n        if r.resource_type == \"AWS::Lambda::Function\":\n            if r.logical_id in resolved:\n                return r.logical_id\n\n    return None\n\n\n# ---------------------------------------------------------------------------\n# Collectors for new resource types\n# ---------------------------------------------------------------------------\n\n\ndef _collect_queues(\n    resources: list[CfnResource],\n    resolver: RefResolver,\n) -> list[SqsQueue]:\n    \"\"\"Extract SQS queues from parsed CloudFormation resources.\"\"\"\n    queues: list[SqsQueue] = []\n    for r in resources:\n        if r.resource_type != \"AWS::SQS::Queue\":\n            continue\n        props = r.properties\n        name = props.get(\"QueueName\", r.logical_id)\n        if isinstance(name, dict):\n            name = str(resolver.resolve(name))\n        is_fifo = bool(props.get(\"FifoQueue\", False))\n        vis = int(props.get(\"VisibilityTimeout\", 30))\n        dedup = bool(props.get(\"ContentBasedDeduplication\", False))\n        redrive = props.get(\"RedrivePolicy\")\n        redrive_target = None\n        max_receive = 5\n        if isinstance(redrive, dict):\n            dlq = redrive.get(\"deadLetterTargetArn\", \"\")\n            if isinstance(dlq, dict):\n                dlq = str(resolver.resolve(dlq))\n            redrive_target = str(dlq) if dlq else None\n            max_receive = int(redrive.get(\"maxReceiveCount\", 5))\n        queues.append(\n            SqsQueue(\n                name=name,\n                is_fifo=is_fifo,\n                visibility_timeout=vis,\n                content_based_dedup=dedup,\n                redrive_target=redrive_target,\n                max_receive_count=max_receive,\n            )\n        )\n    return queues\n\n\ndef _collect_buckets(resources: list[CfnResource]) -> list[S3Bucket]:\n    \"\"\"Extract S3 buckets from parsed CloudFormation resources.\"\"\"\n    buckets: list[S3Bucket] = []\n    for r in resources:\n        if r.resource_type != \"AWS::S3::Bucket\":\n            continue\n        name = r.properties.get(\"BucketName\", r.logical_id)\n        if isinstance(name, dict):\n            name = r.logical_id  # Can't resolve intrinsics for bucket names easily\n        buckets.append(S3Bucket(name=name))\n    return buckets\n\n\ndef _collect_topics(\n    resources: list[CfnResource],\n    resolver: RefResolver,\n) -> list[SnsTopic]:\n    \"\"\"Extract SNS topics from parsed CloudFormation resources.\"\"\"\n    topics: list[SnsTopic] = []\n    for r in resources:\n        if r.resource_type != \"AWS::SNS::Topic\":\n            continue\n        props = r.properties\n        name = props.get(\"TopicName\", r.logical_id)\n        if isinstance(name, dict):\n            name = str(resolver.resolve(name))\n        arn = f\"arn:aws:sns:us-east-1:000000000000:{name}\"\n        topics.append(SnsTopic(name=name, topic_arn=arn))\n    return topics\n\n\ndef _collect_event_buses(\n    resources: list[CfnResource],\n    resolver: RefResolver,\n) -> list[EventBus]:\n    \"\"\"Extract EventBridge event buses from parsed CloudFormation resources.\"\"\"\n    buses: list[EventBus] = []\n    for r in resources:\n        if r.resource_type != \"AWS::Events::EventBus\":\n            continue\n        props = r.properties\n        name = props.get(\"Name\", r.logical_id)\n        if isinstance(name, dict):\n            name = str(resolver.resolve(name))\n        arn = f\"arn:aws:events:us-east-1:000000000000:event-bus/{name}\"\n        buses.append(EventBus(name=name, bus_arn=arn))\n    return buses\n\n\ndef _collect_event_rules(\n    resources: list[CfnResource],\n    resolver: RefResolver,\n) -> list[EventRule]:\n    \"\"\"Extract EventBridge rules from parsed CloudFormation resources.\"\"\"\n    rules: list[EventRule] = []\n    for r in resources:\n        if r.resource_type != \"AWS::Events::Rule\":\n            continue\n        props = r.properties\n        rule_name = props.get(\"Name\", r.logical_id)\n        if isinstance(rule_name, dict):\n            rule_name = str(resolver.resolve(rule_name))\n        bus_name = props.get(\"EventBusName\", \"default\")\n        if isinstance(bus_name, dict):\n            bus_name = str(resolver.resolve(bus_name))\n        pattern = props.get(\"EventPattern\")\n        schedule = props.get(\"ScheduleExpression\")\n        raw_targets = props.get(\"Targets\", [])\n        targets: list[dict[str, Any]] = []\n        for t in raw_targets:\n            target_arn = t.get(\"Arn\", \"\")\n            if isinstance(target_arn, dict):\n                target_arn = str(resolver.resolve(target_arn))\n            targets.append(\n                {\n                    \"target_id\": t.get(\"Id\", \"\"),\n                    \"arn\": target_arn,\n                    \"input_path\": t.get(\"InputPath\"),\n                    \"input_template\": t.get(\"InputTransformer\", {}).get(\"InputTemplate\"),\n                }\n            )\n        rules.append(\n            EventRule(\n                rule_name=rule_name,\n                event_bus_name=bus_name,\n                event_pattern=pattern,\n                schedule_expression=schedule,\n                targets=targets,\n            )\n        )\n    return rules\n\n\ndef _resolve_sm_definition(definition: Any, resolver: RefResolver) -> Any:\n    \"\"\"Resolve a Step Functions DefinitionString that may use intrinsic functions.\"\"\"\n    if isinstance(definition, dict):\n        return resolver.resolve(definition)\n    return definition\n\n\ndef _resolve_substitutions(subs: dict[str, Any], resolver: RefResolver) -> dict[str, str]:\n    \"\"\"Resolve CloudFormation DefinitionSubstitutions to plain strings.\"\"\"\n    return {k: str(resolver.resolve(v)) if isinstance(v, dict) else str(v) for k, v in subs.items()}\n\n\ndef _collect_state_machines(\n    resources: list[CfnResource],\n    resolver: RefResolver,\n) -> list[StateMachine]:\n    \"\"\"Extract Step Functions state machines from parsed CloudFormation resources.\"\"\"\n    machines: list[StateMachine] = []\n    for r in resources:\n        if r.resource_type != \"AWS::StepFunctions::StateMachine\":\n            continue\n        props = r.properties\n        name = props.get(\"StateMachineName\", r.logical_id)\n        if isinstance(name, dict):\n            name = str(resolver.resolve(name))\n        definition = props.get(\"DefinitionString\", props.get(\"Definition\", \"\"))\n        definition = _resolve_sm_definition(definition, resolver)\n        role_arn = props.get(\"RoleArn\", \"\")\n        if isinstance(role_arn, dict):\n            role_arn = str(resolver.resolve(role_arn))\n        resolved_subs = _resolve_substitutions(props.get(\"DefinitionSubstitutions\", {}), resolver)\n        machines.append(\n            StateMachine(\n                name=name,\n                definition=definition,\n                workflow_type=props.get(\"StateMachineType\", \"STANDARD\"),\n                role_arn=role_arn,\n                definition_substitutions=resolved_subs,\n            )\n        )\n    return machines\n\n\ndef _collect_user_pools(\n    resources: list[CfnResource],\n    resolver: RefResolver,\n) -> list[CognitoUserPool]:\n    \"\"\"Extract Cognito user pools from parsed CloudFormation resources.\"\"\"\n    pools: list[CognitoUserPool] = []\n    # First pass: collect user pool clients to map pool -> client_id\n    client_map: dict[str, str] = {}\n    for r in resources:\n        if r.resource_type != \"AWS::Cognito::UserPoolClient\":\n            continue\n        pool_ref = r.properties.get(\"UserPoolId\", \"\")\n        if isinstance(pool_ref, dict):\n            pool_ref = str(resolver.resolve(pool_ref))\n        client_map[pool_ref] = r.logical_id\n\n    for r in resources:\n        if r.resource_type != \"AWS::Cognito::UserPool\":\n            continue\n        props = r.properties\n        name = props.get(\"UserPoolName\", r.logical_id)\n        if isinstance(name, dict):\n            name = str(resolver.resolve(name))\n        auto_confirm = True\n        lambda_config = props.get(\"LambdaConfig\", {})\n        pre_auth = lambda_config.get(\"PreAuthentication\")\n        if isinstance(pre_auth, dict):\n            pre_auth = str(resolver.resolve(pre_auth))\n        post_confirm = lambda_config.get(\"PostConfirmation\")\n        if isinstance(post_confirm, dict):\n            post_confirm = str(resolver.resolve(post_confirm))\n        pw_policy = props.get(\"Policies\", {}).get(\"PasswordPolicy\", {})\n        client_id = client_map.get(r.logical_id, \"\")\n        pools.append(\n            CognitoUserPool(\n                logical_id=r.logical_id,\n                user_pool_name=name,\n                auto_confirm=auto_confirm,\n                password_policy=pw_policy,\n                pre_auth_trigger=pre_auth,\n                post_confirm_trigger=post_confirm,\n                client_id=client_id,\n            )\n        )\n    return pools\n\n\ndef _collect_ssm_parameters(\n    resources: list[CfnResource],\n    resolver: RefResolver,\n) -> list[SsmParameter]:\n    \"\"\"Extract SSM parameters from parsed CloudFormation resources.\"\"\"\n    parameters: list[SsmParameter] = []\n    for r in resources:\n        if r.resource_type != \"AWS::SSM::Parameter\":\n            continue\n        props = r.properties\n        name = props.get(\"Name\", r.logical_id)\n        if isinstance(name, dict):\n            name = str(resolver.resolve(name))\n        param_type = props.get(\"Type\", \"String\")\n        value = props.get(\"Value\", \"\")\n        if isinstance(value, dict):\n            value = str(resolver.resolve(value))\n        description = props.get(\"Description\", \"\")\n        parameters.append(\n            SsmParameter(name=name, type=param_type, value=value, description=description)\n        )\n    return parameters\n\n\ndef _collect_secrets(\n    resources: list[CfnResource],\n    resolver: RefResolver,\n) -> list[SmSecret]:\n    \"\"\"Extract Secrets Manager secrets from parsed CloudFormation resources.\"\"\"\n    secrets: list[SmSecret] = []\n    for r in resources:\n        if r.resource_type != \"AWS::SecretsManager::Secret\":\n            continue\n        props = r.properties\n        name = props.get(\"Name\", r.logical_id)\n        if isinstance(name, dict):\n            name = str(resolver.resolve(name))\n        description = props.get(\"Description\", \"\")\n        secret_string = props.get(\"SecretString\")\n        if secret_string is None:\n            # Try GenerateSecretString.SecretStringTemplate\n            gen = props.get(\"GenerateSecretString\", {})\n            if isinstance(gen, dict):\n                secret_string = gen.get(\"SecretStringTemplate\")\n        if isinstance(secret_string, dict):\n            secret_string = str(resolver.resolve(secret_string))\n        secrets.append(SmSecret(name=name, description=description, secret_string=secret_string))\n    return secrets\n\n\ndef _collect_ecs_services(template: dict) -> list:\n    \"\"\"Extract ECS services from the raw CloudFormation template.\"\"\"\n    try:\n        from lws.providers.ecs.provider import parse_ecs_resources\n\n        return parse_ecs_resources(template)\n    except Exception:\n        logger.debug(\"Could not parse ECS resources\", exc_info=True)\n        return []\n","structuredPatch":[{"oldStart":303,"oldLines":32,"newStart":303,"newLines":58,"lines":[" "," def _resolve_ref_value(r: CfnResource) -> str | None:","     \"\"\"Return the local Ref value for a single CloudFormation resource, or None.\"\"\"","-    if r.resource_type == \"AWS::SQS::Queue\":","-        queue_name = r.properties.get(\"QueueName\", r.logical_id)","-        if isinstance(queue_name, str):","-            return f\"arn:ldk:sqs:local:000000000000:queue/{queue_name}\"","-    elif r.resource_type == \"AWS::DynamoDB::Table\":","-        table_name = r.properties.get(\"TableName\", r.logical_id)","-        if isinstance(table_name, str):","-            return table_name","-    elif r.resource_type == \"AWS::S3::Bucket\":","-        bucket_name = r.properties.get(\"BucketName\", r.logical_id)","-        return bucket_name if isinstance(bucket_name, str) else r.logical_id","-    elif r.resource_type == \"AWS::SNS::Topic\":","-        topic_name = r.properties.get(\"TopicName\", r.logical_id)","-        if isinstance(topic_name, str):","-            return f\"arn:ldk:sns:local:000000000000:{topic_name}\"","-    elif r.resource_type == \"AWS::SSM::Parameter\":","-        name = r.properties.get(\"Name\", r.logical_id)","-        if isinstance(name, str):","-            return name","-    elif r.resource_type == \"AWS::SecretsManager::Secret\":","-        name = r.properties.get(\"Name\", r.logical_id)","-        if isinstance(name, str):","-            return f\"arn:aws:secretsmanager:us-east-1:000000000000:secret:{name}\"","+    handler = _REF_RESOLVERS.get(r.resource_type)","+    if handler is not None:","+        return handler(r)","     return None"," "," ","+def _ref_sqs(r: CfnResource) -> str | None:","+    queue_name = r.properties.get(\"QueueName\", r.logical_id)","+    if isinstance(queue_name, str):","+        return f\"arn:ldk:sqs:local:000000000000:queue/{queue_name}\"","+    return None","+","+","+def _ref_dynamodb(r: CfnResource) -> str | None:","+    table_name = r.properties.get(\"TableName\", r.logical_id)","+    return table_name if isinstance(table_name, str) else None","+","+","+def _ref_s3(r: CfnResource) -> str:","+    bucket_name = r.properties.get(\"BucketName\", r.logical_id)","+    return bucket_name if isinstance(bucket_name, str) else r.logical_id","+","+","+def _ref_sns(r: CfnResource) -> str | None:","+    topic_name = r.properties.get(\"TopicName\", r.logical_id)","+    if isinstance(topic_name, str):","+        return f\"arn:ldk:sns:local:000000000000:{topic_name}\"","+    return None","+","+","+def _ref_ssm(r: CfnResource) -> str | None:","+    name = r.properties.get(\"Name\", r.logical_id)","+    return name if isinstance(name, str) else None","+","+","+def _ref_secretsmanager(r: CfnResource) -> str | None:","+    name = r.properties.get(\"Name\", r.logical_id)","+    if isinstance(name, str):","+        return f\"arn:aws:secretsmanager:us-east-1:000000000000:secret:{name}\"","+    return None","+","+","+_REF_RESOLVERS: dict[str, Callable[[CfnResource], str | None]] = {","+    \"AWS::SQS::Queue\": _ref_sqs,","+    \"AWS::DynamoDB::Table\": _ref_dynamodb,","+    \"AWS::S3::Bucket\": _ref_s3,","+    \"AWS::SNS::Topic\": _ref_sns,","+    \"AWS::SSM::Parameter\": _ref_ssm,","+    \"AWS::SecretsManager::Secret\": _ref_secretsmanager,","+}","+","+"," def _collect_lambdas(","     resources: list[CfnResource],","     asset_map: dict[str, Path],"]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"aeb70c43-0fd6-4abe-af40-d6771a0f78a2"}
{"parentUuid":"d0eae0a4-7f53-4a62-b2e5-3163b0a8cda7","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","message":{"model":"claude-opus-4-6","id":"msg_01B2G2Y6Jo3wcMqfLYx3BLqB","type":"message","role":"assistant","content":[{"type":"text","text":"I need to add the `Callable` import:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1284,"cache_read_input_tokens":82041,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1284},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CY1FZEGKgu31VmCxufmfL","type":"assistant","uuid":"083877e5-66dd-45e1-8044-a1d187ed5a75","timestamp":"2026-02-10T23:25:06.457Z"}
{"parentUuid":"083877e5-66dd-45e1-8044-a1d187ed5a75","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","message":{"model":"claude-opus-4-6","id":"msg_01B2G2Y6Jo3wcMqfLYx3BLqB","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01EMrWocNS5nUmJLBjSQ2Ebg","name":"Read","input":{"file_path":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services/src/lws/parser/assembly.py","offset":1,"limit":16}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1284,"cache_read_input_tokens":82041,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1284},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CY1FZEGKgu31VmCxufmfL","type":"assistant","uuid":"76b973a8-5652-468d-9a10-c8da3a509478","timestamp":"2026-02-10T23:25:07.336Z"}
{"parentUuid":"76b973a8-5652-468d-9a10-c8da3a509478","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"callback"},"parentToolUseID":"toolu_01EMrWocNS5nUmJLBjSQ2Ebg","toolUseID":"toolu_01EMrWocNS5nUmJLBjSQ2Ebg","timestamp":"2026-02-10T23:25:07.345Z","uuid":"0beb5431-b314-4b65-ac56-5e5915ce9dae"}
{"parentUuid":"76b973a8-5652-468d-9a10-c8da3a509478","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01EMrWocNS5nUmJLBjSQ2Ebg","type":"tool_result","content":"     1→\"\"\"Assembly orchestrator -- top-level entry point for CDK output parsing.\n     2→\n     3→Ties together tree parsing, template parsing, reference resolution and\n     4→asset location to produce a single ``AppModel`` that the rest of the\n     5→system can consume.\n     6→\"\"\"\n     7→\n     8→from __future__ import annotations\n     9→\n    10→import json\n    11→import logging\n    12→from dataclasses import dataclass, field\n    13→from pathlib import Path\n    14→from typing import Any\n    15→\n    16→from lws.parser.asset_parser import parse_assets\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"c949d1bc-b5f6-47eb-b3c3-8bf0ac64eefe","timestamp":"2026-02-10T23:25:07.344Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services/src/lws/parser/assembly.py","content":"\"\"\"Assembly orchestrator -- top-level entry point for CDK output parsing.\n\nTies together tree parsing, template parsing, reference resolution and\nasset location to produce a single ``AppModel`` that the rest of the\nsystem can consume.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport json\nimport logging\nfrom dataclasses import dataclass, field\nfrom pathlib import Path\nfrom typing import Any\n\nfrom lws.parser.asset_parser import parse_assets","numLines":16,"startLine":1,"totalLines":789}},"sourceToolAssistantUUID":"76b973a8-5652-468d-9a10-c8da3a509478"}
{"parentUuid":"c949d1bc-b5f6-47eb-b3c3-8bf0ac64eefe","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","message":{"model":"claude-opus-4-6","id":"msg_01XiDb1wMB6pdaWB8jgZDiR5","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01BqaVWGgZkRR13TJHRCg8gB","name":"Edit","input":{"replace_all":false,"file_path":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services/src/lws/parser/assembly.py","old_string":"from typing import Any","new_string":"from collections.abc import Callable\nfrom typing import Any"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":379,"cache_read_input_tokens":83325,"output_tokens":160,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":379,"ephemeral_5m_input_tokens":0},"inference_geo":"","iterations":[]}},"requestId":"req_011CY1FZSdiGVxsDrFqzb23d","type":"assistant","uuid":"da716bab-fc9c-4a70-aa6d-a58adf1f0aa5","timestamp":"2026-02-10T23:25:11.020Z"}
{"parentUuid":"da716bab-fc9c-4a70-aa6d-a58adf1f0aa5","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"callback"},"parentToolUseID":"toolu_01BqaVWGgZkRR13TJHRCg8gB","toolUseID":"toolu_01BqaVWGgZkRR13TJHRCg8gB","timestamp":"2026-02-10T23:25:11.029Z","uuid":"54e20176-f87c-4f19-87b5-cf83d67d3ee3"}
{"parentUuid":"da716bab-fc9c-4a70-aa6d-a58adf1f0aa5","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01BqaVWGgZkRR13TJHRCg8gB","type":"tool_result","content":"The file /Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services/src/lws/parser/assembly.py has been updated successfully."}]},"uuid":"b1d56596-0c8d-4216-892a-872ef6eaf3b8","timestamp":"2026-02-10T23:25:11.027Z","toolUseResult":{"filePath":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services/src/lws/parser/assembly.py","oldString":"from typing import Any","newString":"from collections.abc import Callable\nfrom typing import Any","originalFile":"\"\"\"Assembly orchestrator -- top-level entry point for CDK output parsing.\n\nTies together tree parsing, template parsing, reference resolution and\nasset location to produce a single ``AppModel`` that the rest of the\nsystem can consume.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport json\nimport logging\nfrom dataclasses import dataclass, field\nfrom pathlib import Path\nfrom typing import Any\n\nfrom lws.parser.asset_parser import parse_assets\nfrom lws.parser.ref_resolver import RefResolver\nfrom lws.parser.template_parser import (\n    CfnResource,\n    extract_api_routes,\n    extract_dynamo_tables,\n    extract_lambda_functions,\n    parse_template,\n)\nfrom lws.parser.tree_parser import parse_tree\n\nlogger = logging.getLogger(__name__)\n\n# ---------------------------------------------------------------------------\n# Domain model dataclasses\n# ---------------------------------------------------------------------------\n\n\n@dataclass\nclass LambdaFunction:\n    \"\"\"Parsed Lambda function ready for local execution.\"\"\"\n\n    name: str\n    handler: str\n    runtime: str\n    code_path: Path | None = None\n    timeout: int = 30\n    memory: int = 128\n    environment: dict[str, str] = field(default_factory=dict)\n\n    @property\n    def logical_id(self) -> str:\n        return self.name\n\n\n@dataclass\nclass DynamoTable:\n    \"\"\"Parsed DynamoDB table definition.\"\"\"\n\n    name: str\n    key_schema: list[dict[str, str]] = field(default_factory=list)\n    gsi_definitions: list[dict[str, Any]] = field(default_factory=list)\n\n    @property\n    def logical_id(self) -> str:\n        return self.name\n\n    @property\n    def table_name(self) -> str:\n        return self.name\n\n\n@dataclass\nclass ApiRoute:\n    \"\"\"A single API Gateway route.\"\"\"\n\n    method: str\n    path: str\n    handler_name: str | None = None\n\n\n@dataclass\nclass ApiDefinition:\n    \"\"\"A collection of routes making up an API.\"\"\"\n\n    name: str = \"default\"\n    routes: list[ApiRoute] = field(default_factory=list)\n\n    @property\n    def logical_id(self) -> str:\n        return self.name\n\n\n@dataclass\nclass SqsQueue:\n    \"\"\"Parsed SQS queue definition.\"\"\"\n\n    name: str\n    is_fifo: bool = False\n    visibility_timeout: int = 30\n    content_based_dedup: bool = False\n    redrive_target: str | None = None\n    max_receive_count: int = 5\n\n\n@dataclass\nclass S3Bucket:\n    \"\"\"Parsed S3 bucket definition.\"\"\"\n\n    name: str\n\n\n@dataclass\nclass SnsTopic:\n    \"\"\"Parsed SNS topic definition.\"\"\"\n\n    name: str\n    topic_arn: str = \"\"\n\n\n@dataclass\nclass EventBus:\n    \"\"\"Parsed EventBridge event bus definition.\"\"\"\n\n    name: str\n    bus_arn: str = \"\"\n\n\n@dataclass\nclass EventRule:\n    \"\"\"Parsed EventBridge rule definition.\"\"\"\n\n    rule_name: str\n    event_bus_name: str = \"default\"\n    event_pattern: dict[str, Any] | None = None\n    schedule_expression: str | None = None\n    targets: list[dict[str, Any]] = field(default_factory=list)\n\n\n@dataclass\nclass StateMachine:\n    \"\"\"Parsed Step Functions state machine definition.\"\"\"\n\n    name: str\n    definition: str | dict[str, Any] = \"\"\n    workflow_type: str = \"STANDARD\"\n    role_arn: str = \"\"\n    definition_substitutions: dict[str, str] = field(default_factory=dict)\n\n\n@dataclass\nclass CognitoUserPool:\n    \"\"\"Parsed Cognito user pool definition.\"\"\"\n\n    logical_id: str\n    user_pool_name: str = \"default\"\n    auto_confirm: bool = True\n    password_policy: dict[str, Any] = field(default_factory=dict)\n    pre_auth_trigger: str | None = None\n    post_confirm_trigger: str | None = None\n    client_id: str = \"\"\n\n\n@dataclass\nclass SsmParameter:\n    \"\"\"Parsed SSM Parameter Store parameter.\"\"\"\n\n    name: str\n    type: str  # \"String\", \"StringList\", \"SecureString\"\n    value: str\n    description: str = \"\"\n\n\n@dataclass\nclass SmSecret:\n    \"\"\"Parsed Secrets Manager secret.\"\"\"\n\n    name: str\n    description: str = \"\"\n    secret_string: str | None = None\n\n\n@dataclass\nclass AppModel:\n    \"\"\"Complete parsed representation of a CDK application.\"\"\"\n\n    functions: list[LambdaFunction] = field(default_factory=list)\n    tables: list[DynamoTable] = field(default_factory=list)\n    apis: list[ApiDefinition] = field(default_factory=list)\n    queues: list[SqsQueue] = field(default_factory=list)\n    buckets: list[S3Bucket] = field(default_factory=list)\n    topics: list[SnsTopic] = field(default_factory=list)\n    event_buses: list[EventBus] = field(default_factory=list)\n    event_rules: list[EventRule] = field(default_factory=list)\n    state_machines: list[StateMachine] = field(default_factory=list)\n    user_pools: list[CognitoUserPool] = field(default_factory=list)\n    ecs_services: list[Any] = field(default_factory=list)\n    ssm_parameters: list[SsmParameter] = field(default_factory=list)\n    secrets: list[SmSecret] = field(default_factory=list)\n\n\n# ---------------------------------------------------------------------------\n# Orchestrator\n# ---------------------------------------------------------------------------\n\n\ndef parse_assembly(cdk_out_path: Path) -> AppModel:\n    \"\"\"Parse an entire CDK ``cdk.out`` directory into an :class:`AppModel`.\n\n    Parameters\n    ----------\n    cdk_out_path:\n        Path to the ``cdk.out`` directory produced by ``cdk synth``.\n\n    Returns\n    -------\n    AppModel\n    \"\"\"\n    manifest_path = cdk_out_path / \"manifest.json\"\n    if not manifest_path.exists():\n        logger.warning(\"No manifest.json found in %s\", cdk_out_path)\n        return AppModel()\n\n    with open(manifest_path, encoding=\"utf-8\") as fh:\n        manifest = json.load(fh)\n\n    # Parse assets (hash -> filesystem path)\n    asset_map = parse_assets(cdk_out_path)\n\n    # Parse tree.json if present\n    tree_path = cdk_out_path / \"tree.json\"\n    if tree_path.exists():\n        parse_tree(tree_path)  # Currently used for validation; future enrichment\n\n    # Collect all stack artifacts\n    model = AppModel()\n    for artifact_id, artifact in (manifest.get(\"artifacts\") or {}).items():\n        if artifact.get(\"type\") != \"aws:cloudformation:stack\":\n            continue\n        _process_stack(cdk_out_path, artifact_id, artifact, asset_map, model)\n\n    return model\n\n\ndef _process_stack(\n    cdk_out_path: Path,\n    artifact_id: str,\n    artifact: dict,\n    asset_map: dict[str, Path],\n    model: AppModel,\n) -> None:\n    \"\"\"Process a single CloudFormation stack artifact.\"\"\"\n    template_file = artifact.get(\"properties\", {}).get(\"templateFile\")\n    if not template_file:\n        logger.warning(\"Stack %s has no templateFile\", artifact_id)\n        return\n\n    template_path = cdk_out_path / template_file\n    if not template_path.exists():\n        logger.warning(\"Template not found: %s\", template_path)\n        return\n\n    resources = parse_template(template_path)\n    resource_type_map = {r.logical_id: r.resource_type for r in resources}\n    resource_map = _build_resource_map(resources)\n    resolver = RefResolver(resource_map=resource_map, resource_types=resource_type_map)\n\n    model.functions.extend(_collect_lambdas(resources, asset_map, cdk_out_path, resolver))\n    model.tables.extend(_collect_tables(resources, resolver))\n    api_def = _collect_api_routes(resources, resolver, artifact_id)\n    if api_def:\n        model.apis.append(api_def)\n    model.queues.extend(_collect_queues(resources, resolver))\n    model.buckets.extend(_collect_buckets(resources))\n    model.topics.extend(_collect_topics(resources, resolver))\n    model.event_buses.extend(_collect_event_buses(resources, resolver))\n    model.event_rules.extend(_collect_event_rules(resources, resolver))\n    model.state_machines.extend(_collect_state_machines(resources, resolver))\n    model.user_pools.extend(_collect_user_pools(resources, resolver))\n    model.ssm_parameters.extend(_collect_ssm_parameters(resources, resolver))\n    model.secrets.extend(_collect_secrets(resources, resolver))\n\n    # ECS needs the raw template dict\n    with open(template_path, encoding=\"utf-8\") as fh:\n        raw_template = json.load(fh)\n    ecs_services = _collect_ecs_services(raw_template)\n    model.ecs_services.extend(ecs_services)\n\n\ndef _build_resource_map(resources: list[CfnResource]) -> dict[str, str]:\n    \"\"\"Build a Ref resource_map so intrinsic ``Ref`` calls resolve to useful local values.\n\n    In real CloudFormation:\n    - ``Ref`` on an ``AWS::SQS::Queue`` returns the queue URL.\n    - ``Ref`` on an ``AWS::DynamoDB::Table`` returns the table name.\n\n    We reproduce this behaviour with deterministic local placeholders so that\n    Lambda environment variables like ``QUEUE_URL`` and ``TABLE_NAME`` resolve\n    to values the local providers can understand.\n    \"\"\"\n    resource_map: dict[str, str] = {}\n    for r in resources:\n        ref = _resolve_ref_value(r)\n        if ref is not None:\n            resource_map[r.logical_id] = ref\n    return resource_map\n\n\ndef _resolve_ref_value(r: CfnResource) -> str | None:\n    \"\"\"Return the local Ref value for a single CloudFormation resource, or None.\"\"\"\n    handler = _REF_RESOLVERS.get(r.resource_type)\n    if handler is not None:\n        return handler(r)\n    return None\n\n\ndef _ref_sqs(r: CfnResource) -> str | None:\n    queue_name = r.properties.get(\"QueueName\", r.logical_id)\n    if isinstance(queue_name, str):\n        return f\"arn:ldk:sqs:local:000000000000:queue/{queue_name}\"\n    return None\n\n\ndef _ref_dynamodb(r: CfnResource) -> str | None:\n    table_name = r.properties.get(\"TableName\", r.logical_id)\n    return table_name if isinstance(table_name, str) else None\n\n\ndef _ref_s3(r: CfnResource) -> str:\n    bucket_name = r.properties.get(\"BucketName\", r.logical_id)\n    return bucket_name if isinstance(bucket_name, str) else r.logical_id\n\n\ndef _ref_sns(r: CfnResource) -> str | None:\n    topic_name = r.properties.get(\"TopicName\", r.logical_id)\n    if isinstance(topic_name, str):\n        return f\"arn:ldk:sns:local:000000000000:{topic_name}\"\n    return None\n\n\ndef _ref_ssm(r: CfnResource) -> str | None:\n    name = r.properties.get(\"Name\", r.logical_id)\n    return name if isinstance(name, str) else None\n\n\ndef _ref_secretsmanager(r: CfnResource) -> str | None:\n    name = r.properties.get(\"Name\", r.logical_id)\n    if isinstance(name, str):\n        return f\"arn:aws:secretsmanager:us-east-1:000000000000:secret:{name}\"\n    return None\n\n\n_REF_RESOLVERS: dict[str, Callable[[CfnResource], str | None]] = {\n    \"AWS::SQS::Queue\": _ref_sqs,\n    \"AWS::DynamoDB::Table\": _ref_dynamodb,\n    \"AWS::S3::Bucket\": _ref_s3,\n    \"AWS::SNS::Topic\": _ref_sns,\n    \"AWS::SSM::Parameter\": _ref_ssm,\n    \"AWS::SecretsManager::Secret\": _ref_secretsmanager,\n}\n\n\ndef _collect_lambdas(\n    resources: list[CfnResource],\n    asset_map: dict[str, Path],\n    cdk_out_path: Path,\n    resolver: RefResolver,\n) -> list[LambdaFunction]:\n    \"\"\"Extract Lambda functions from parsed CloudFormation resources.\"\"\"\n    functions: list[LambdaFunction] = []\n    lambda_props_list = extract_lambda_functions(resources)\n    lambda_resources = [r for r in resources if r.resource_type == \"AWS::Lambda::Function\"]\n    for r, props in zip(lambda_resources, lambda_props_list):\n        code_path = _resolve_code_path(props.code_uri, asset_map, cdk_out_path, resolver)\n        env = {k: str(resolver.resolve(v)) for k, v in props.environment.items()}\n        functions.append(\n            LambdaFunction(\n                name=r.logical_id,\n                handler=props.handler or \"index.handler\",\n                runtime=props.runtime or \"python3.11\",\n                code_path=code_path,\n                timeout=props.timeout or 30,\n                memory=props.memory_size or 128,\n                environment=env,\n            )\n        )\n    return functions\n\n\ndef _collect_tables(\n    resources: list[CfnResource],\n    resolver: RefResolver,\n) -> list[DynamoTable]:\n    \"\"\"Extract DynamoDB tables from parsed CloudFormation resources.\"\"\"\n    tables: list[DynamoTable] = []\n    dynamo_props_list = extract_dynamo_tables(resources)\n    dynamo_resources = [r for r in resources if r.resource_type == \"AWS::DynamoDB::Table\"]\n    for r, props in zip(dynamo_resources, dynamo_props_list):\n        name = props.table_name or r.logical_id\n        if isinstance(name, dict):\n            name = str(resolver.resolve(name))\n        tables.append(\n            DynamoTable(\n                name=name,\n                key_schema=props.key_schema,\n                gsi_definitions=props.gsi_definitions,\n            )\n        )\n    return tables\n\n\ndef _collect_api_routes(\n    resources: list[CfnResource],\n    resolver: RefResolver,\n    artifact_id: str,\n) -> ApiDefinition | None:\n    \"\"\"Extract API Gateway routes from parsed CloudFormation resources.\"\"\"\n    api_routes = extract_api_routes(resources)\n    if not api_routes:\n        return None\n    routes: list[ApiRoute] = []\n    for route_props in api_routes:\n        handler_name = _find_handler_for_integration(\n            route_props.integration_uri, resources, resolver\n        )\n        routes.append(\n            ApiRoute(\n                method=route_props.http_method or \"ANY\",\n                path=route_props.resource_path or \"/\",\n                handler_name=handler_name,\n            )\n        )\n    return ApiDefinition(name=artifact_id, routes=routes)\n\n\ndef _resolve_code_from_s3_key(s3_key: str, asset_map: dict[str, Path]) -> Path | None:\n    \"\"\"Try to match an S3Key to an asset by hash.\"\"\"\n    asset_hash = s3_key.replace(\".zip\", \"\")\n    if asset_hash in asset_map:\n        return asset_map[asset_hash]\n    for hash_key, path in asset_map.items():\n        if hash_key in s3_key:\n            return path\n    return None\n\n\ndef _resolve_code_from_s3_bucket(\n    s3_bucket: dict, resolver: RefResolver, asset_map: dict[str, Path]\n) -> Path | None:\n    \"\"\"Try to match an S3Bucket ref to an asset.\"\"\"\n    resolved = str(resolver.resolve(s3_bucket))\n    for h, p in asset_map.items():\n        if h in resolved:\n            return p\n    return None\n\n\ndef _resolve_code_path(\n    code_uri: Any,\n    asset_map: dict[str, Path],\n    cdk_out_path: Path,\n    resolver: RefResolver,\n) -> Path | None:\n    \"\"\"Resolve a Lambda Code property to a local filesystem path.\"\"\"\n    if code_uri is None:\n        return None\n\n    if isinstance(code_uri, dict):\n        s3_key = code_uri.get(\"S3Key\")\n        if isinstance(s3_key, str):\n            result = _resolve_code_from_s3_key(s3_key, asset_map)\n            if result:\n                return result\n\n        s3_bucket = code_uri.get(\"S3Bucket\")\n        if isinstance(s3_bucket, dict):\n            result = _resolve_code_from_s3_bucket(s3_bucket, resolver, asset_map)\n            if result:\n                return result\n\n    if isinstance(code_uri, str):\n        candidate = cdk_out_path / code_uri\n        if candidate.exists():\n            return candidate\n\n    return None\n\n\ndef _find_handler_for_integration(\n    integration_uri: Any,\n    resources: list[CfnResource],\n    resolver: RefResolver,\n) -> str | None:\n    \"\"\"Try to match an API integration URI back to a Lambda logical ID.\"\"\"\n    if integration_uri is None:\n        return None\n\n    resolved = str(resolver.resolve(integration_uri))\n\n    # Look for a Lambda function logical ID in the resolved string\n    for r in resources:\n        if r.resource_type == \"AWS::Lambda::Function\":\n            if r.logical_id in resolved:\n                return r.logical_id\n\n    return None\n\n\n# ---------------------------------------------------------------------------\n# Collectors for new resource types\n# ---------------------------------------------------------------------------\n\n\ndef _collect_queues(\n    resources: list[CfnResource],\n    resolver: RefResolver,\n) -> list[SqsQueue]:\n    \"\"\"Extract SQS queues from parsed CloudFormation resources.\"\"\"\n    queues: list[SqsQueue] = []\n    for r in resources:\n        if r.resource_type != \"AWS::SQS::Queue\":\n            continue\n        props = r.properties\n        name = props.get(\"QueueName\", r.logical_id)\n        if isinstance(name, dict):\n            name = str(resolver.resolve(name))\n        is_fifo = bool(props.get(\"FifoQueue\", False))\n        vis = int(props.get(\"VisibilityTimeout\", 30))\n        dedup = bool(props.get(\"ContentBasedDeduplication\", False))\n        redrive = props.get(\"RedrivePolicy\")\n        redrive_target = None\n        max_receive = 5\n        if isinstance(redrive, dict):\n            dlq = redrive.get(\"deadLetterTargetArn\", \"\")\n            if isinstance(dlq, dict):\n                dlq = str(resolver.resolve(dlq))\n            redrive_target = str(dlq) if dlq else None\n            max_receive = int(redrive.get(\"maxReceiveCount\", 5))\n        queues.append(\n            SqsQueue(\n                name=name,\n                is_fifo=is_fifo,\n                visibility_timeout=vis,\n                content_based_dedup=dedup,\n                redrive_target=redrive_target,\n                max_receive_count=max_receive,\n            )\n        )\n    return queues\n\n\ndef _collect_buckets(resources: list[CfnResource]) -> list[S3Bucket]:\n    \"\"\"Extract S3 buckets from parsed CloudFormation resources.\"\"\"\n    buckets: list[S3Bucket] = []\n    for r in resources:\n        if r.resource_type != \"AWS::S3::Bucket\":\n            continue\n        name = r.properties.get(\"BucketName\", r.logical_id)\n        if isinstance(name, dict):\n            name = r.logical_id  # Can't resolve intrinsics for bucket names easily\n        buckets.append(S3Bucket(name=name))\n    return buckets\n\n\ndef _collect_topics(\n    resources: list[CfnResource],\n    resolver: RefResolver,\n) -> list[SnsTopic]:\n    \"\"\"Extract SNS topics from parsed CloudFormation resources.\"\"\"\n    topics: list[SnsTopic] = []\n    for r in resources:\n        if r.resource_type != \"AWS::SNS::Topic\":\n            continue\n        props = r.properties\n        name = props.get(\"TopicName\", r.logical_id)\n        if isinstance(name, dict):\n            name = str(resolver.resolve(name))\n        arn = f\"arn:aws:sns:us-east-1:000000000000:{name}\"\n        topics.append(SnsTopic(name=name, topic_arn=arn))\n    return topics\n\n\ndef _collect_event_buses(\n    resources: list[CfnResource],\n    resolver: RefResolver,\n) -> list[EventBus]:\n    \"\"\"Extract EventBridge event buses from parsed CloudFormation resources.\"\"\"\n    buses: list[EventBus] = []\n    for r in resources:\n        if r.resource_type != \"AWS::Events::EventBus\":\n            continue\n        props = r.properties\n        name = props.get(\"Name\", r.logical_id)\n        if isinstance(name, dict):\n            name = str(resolver.resolve(name))\n        arn = f\"arn:aws:events:us-east-1:000000000000:event-bus/{name}\"\n        buses.append(EventBus(name=name, bus_arn=arn))\n    return buses\n\n\ndef _collect_event_rules(\n    resources: list[CfnResource],\n    resolver: RefResolver,\n) -> list[EventRule]:\n    \"\"\"Extract EventBridge rules from parsed CloudFormation resources.\"\"\"\n    rules: list[EventRule] = []\n    for r in resources:\n        if r.resource_type != \"AWS::Events::Rule\":\n            continue\n        props = r.properties\n        rule_name = props.get(\"Name\", r.logical_id)\n        if isinstance(rule_name, dict):\n            rule_name = str(resolver.resolve(rule_name))\n        bus_name = props.get(\"EventBusName\", \"default\")\n        if isinstance(bus_name, dict):\n            bus_name = str(resolver.resolve(bus_name))\n        pattern = props.get(\"EventPattern\")\n        schedule = props.get(\"ScheduleExpression\")\n        raw_targets = props.get(\"Targets\", [])\n        targets: list[dict[str, Any]] = []\n        for t in raw_targets:\n            target_arn = t.get(\"Arn\", \"\")\n            if isinstance(target_arn, dict):\n                target_arn = str(resolver.resolve(target_arn))\n            targets.append(\n                {\n                    \"target_id\": t.get(\"Id\", \"\"),\n                    \"arn\": target_arn,\n                    \"input_path\": t.get(\"InputPath\"),\n                    \"input_template\": t.get(\"InputTransformer\", {}).get(\"InputTemplate\"),\n                }\n            )\n        rules.append(\n            EventRule(\n                rule_name=rule_name,\n                event_bus_name=bus_name,\n                event_pattern=pattern,\n                schedule_expression=schedule,\n                targets=targets,\n            )\n        )\n    return rules\n\n\ndef _resolve_sm_definition(definition: Any, resolver: RefResolver) -> Any:\n    \"\"\"Resolve a Step Functions DefinitionString that may use intrinsic functions.\"\"\"\n    if isinstance(definition, dict):\n        return resolver.resolve(definition)\n    return definition\n\n\ndef _resolve_substitutions(subs: dict[str, Any], resolver: RefResolver) -> dict[str, str]:\n    \"\"\"Resolve CloudFormation DefinitionSubstitutions to plain strings.\"\"\"\n    return {k: str(resolver.resolve(v)) if isinstance(v, dict) else str(v) for k, v in subs.items()}\n\n\ndef _collect_state_machines(\n    resources: list[CfnResource],\n    resolver: RefResolver,\n) -> list[StateMachine]:\n    \"\"\"Extract Step Functions state machines from parsed CloudFormation resources.\"\"\"\n    machines: list[StateMachine] = []\n    for r in resources:\n        if r.resource_type != \"AWS::StepFunctions::StateMachine\":\n            continue\n        props = r.properties\n        name = props.get(\"StateMachineName\", r.logical_id)\n        if isinstance(name, dict):\n            name = str(resolver.resolve(name))\n        definition = props.get(\"DefinitionString\", props.get(\"Definition\", \"\"))\n        definition = _resolve_sm_definition(definition, resolver)\n        role_arn = props.get(\"RoleArn\", \"\")\n        if isinstance(role_arn, dict):\n            role_arn = str(resolver.resolve(role_arn))\n        resolved_subs = _resolve_substitutions(props.get(\"DefinitionSubstitutions\", {}), resolver)\n        machines.append(\n            StateMachine(\n                name=name,\n                definition=definition,\n                workflow_type=props.get(\"StateMachineType\", \"STANDARD\"),\n                role_arn=role_arn,\n                definition_substitutions=resolved_subs,\n            )\n        )\n    return machines\n\n\ndef _collect_user_pools(\n    resources: list[CfnResource],\n    resolver: RefResolver,\n) -> list[CognitoUserPool]:\n    \"\"\"Extract Cognito user pools from parsed CloudFormation resources.\"\"\"\n    pools: list[CognitoUserPool] = []\n    # First pass: collect user pool clients to map pool -> client_id\n    client_map: dict[str, str] = {}\n    for r in resources:\n        if r.resource_type != \"AWS::Cognito::UserPoolClient\":\n            continue\n        pool_ref = r.properties.get(\"UserPoolId\", \"\")\n        if isinstance(pool_ref, dict):\n            pool_ref = str(resolver.resolve(pool_ref))\n        client_map[pool_ref] = r.logical_id\n\n    for r in resources:\n        if r.resource_type != \"AWS::Cognito::UserPool\":\n            continue\n        props = r.properties\n        name = props.get(\"UserPoolName\", r.logical_id)\n        if isinstance(name, dict):\n            name = str(resolver.resolve(name))\n        auto_confirm = True\n        lambda_config = props.get(\"LambdaConfig\", {})\n        pre_auth = lambda_config.get(\"PreAuthentication\")\n        if isinstance(pre_auth, dict):\n            pre_auth = str(resolver.resolve(pre_auth))\n        post_confirm = lambda_config.get(\"PostConfirmation\")\n        if isinstance(post_confirm, dict):\n            post_confirm = str(resolver.resolve(post_confirm))\n        pw_policy = props.get(\"Policies\", {}).get(\"PasswordPolicy\", {})\n        client_id = client_map.get(r.logical_id, \"\")\n        pools.append(\n            CognitoUserPool(\n                logical_id=r.logical_id,\n                user_pool_name=name,\n                auto_confirm=auto_confirm,\n                password_policy=pw_policy,\n                pre_auth_trigger=pre_auth,\n                post_confirm_trigger=post_confirm,\n                client_id=client_id,\n            )\n        )\n    return pools\n\n\ndef _collect_ssm_parameters(\n    resources: list[CfnResource],\n    resolver: RefResolver,\n) -> list[SsmParameter]:\n    \"\"\"Extract SSM parameters from parsed CloudFormation resources.\"\"\"\n    parameters: list[SsmParameter] = []\n    for r in resources:\n        if r.resource_type != \"AWS::SSM::Parameter\":\n            continue\n        props = r.properties\n        name = props.get(\"Name\", r.logical_id)\n        if isinstance(name, dict):\n            name = str(resolver.resolve(name))\n        param_type = props.get(\"Type\", \"String\")\n        value = props.get(\"Value\", \"\")\n        if isinstance(value, dict):\n            value = str(resolver.resolve(value))\n        description = props.get(\"Description\", \"\")\n        parameters.append(\n            SsmParameter(name=name, type=param_type, value=value, description=description)\n        )\n    return parameters\n\n\ndef _collect_secrets(\n    resources: list[CfnResource],\n    resolver: RefResolver,\n) -> list[SmSecret]:\n    \"\"\"Extract Secrets Manager secrets from parsed CloudFormation resources.\"\"\"\n    secrets: list[SmSecret] = []\n    for r in resources:\n        if r.resource_type != \"AWS::SecretsManager::Secret\":\n            continue\n        props = r.properties\n        name = props.get(\"Name\", r.logical_id)\n        if isinstance(name, dict):\n            name = str(resolver.resolve(name))\n        description = props.get(\"Description\", \"\")\n        secret_string = props.get(\"SecretString\")\n        if secret_string is None:\n            # Try GenerateSecretString.SecretStringTemplate\n            gen = props.get(\"GenerateSecretString\", {})\n            if isinstance(gen, dict):\n                secret_string = gen.get(\"SecretStringTemplate\")\n        if isinstance(secret_string, dict):\n            secret_string = str(resolver.resolve(secret_string))\n        secrets.append(SmSecret(name=name, description=description, secret_string=secret_string))\n    return secrets\n\n\ndef _collect_ecs_services(template: dict) -> list:\n    \"\"\"Extract ECS services from the raw CloudFormation template.\"\"\"\n    try:\n        from lws.providers.ecs.provider import parse_ecs_resources\n\n        return parse_ecs_resources(template)\n    except Exception:\n        logger.debug(\"Could not parse ECS resources\", exc_info=True)\n        return []\n","structuredPatch":[{"oldStart":11,"oldLines":6,"newStart":11,"newLines":7,"lines":[" import logging"," from dataclasses import dataclass, field"," from pathlib import Path","+from collections.abc import Callable"," from typing import Any"," "," from lws.parser.asset_parser import parse_assets"]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"da716bab-fc9c-4a70-aa6d-a58adf1f0aa5"}
{"parentUuid":"b1d56596-0c8d-4216-892a-872ef6eaf3b8","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","message":{"model":"claude-opus-4-6","id":"msg_01D85JbztaXaF7icuANKJaGB","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Gf28AA54ThJTqPTVDHvTc8","name":"Bash","input":{"command":"uv run python -m pytest tests/ -x -q 2>&1 | tail -5","description":"Run unit tests","timeout":120000}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":215,"cache_read_input_tokens":83704,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":215},"output_tokens":26,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CY1FZi2uxKAyQ8wPLPHp6","type":"assistant","uuid":"67fa3848-b3dc-4130-9fe1-5740301e8fec","timestamp":"2026-02-10T23:25:15.751Z"}
{"parentUuid":"67fa3848-b3dc-4130-9fe1-5740301e8fec","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","message":{"model":"claude-opus-4-6","id":"msg_01D85JbztaXaF7icuANKJaGB","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01A3iVSL4JH5vFC9whtS6Kj3","name":"Bash","input":{"command":"uvx ruff check src/lws/parser/assembly.py src/lws/cli/ldk.py src/lws/providers/ssm/routes.py src/lws/providers/secretsmanager/routes.py src/lws/parser/tree_parser.py 2>&1","description":"Run ruff lint on changed files","timeout":60000}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":215,"cache_read_input_tokens":83704,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":215},"output_tokens":26,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CY1FZi2uxKAyQ8wPLPHp6","type":"assistant","uuid":"30acee7f-c99e-44b2-a789-a846e3859650","timestamp":"2026-02-10T23:25:17.599Z"}
{"parentUuid":"30acee7f-c99e-44b2-a789-a846e3859650","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"progress","data":{"type":"bash_progress","output":"","fullOutput":"","elapsedTimeSeconds":1,"totalLines":0,"timeoutMs":120000},"toolUseID":"bash-progress-0","parentToolUseID":"toolu_01Gf28AA54ThJTqPTVDHvTc8","uuid":"1e5b0a4e-b654-4d53-b29a-b0feb2a547fb","timestamp":"2026-02-10T23:25:17.773Z"}
{"parentUuid":"1e5b0a4e-b654-4d53-b29a-b0feb2a547fb","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"progress","data":{"type":"bash_progress","output":"","fullOutput":"","elapsedTimeSeconds":3,"totalLines":0,"timeoutMs":120000},"toolUseID":"bash-progress-1","parentToolUseID":"toolu_01Gf28AA54ThJTqPTVDHvTc8","uuid":"9df27cd1-48c2-4108-8eaa-415e324c00b3","timestamp":"2026-02-10T23:25:18.776Z"}
{"parentUuid":"9df27cd1-48c2-4108-8eaa-415e324c00b3","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"progress","data":{"type":"bash_progress","output":"","fullOutput":"","elapsedTimeSeconds":4,"totalLines":0,"timeoutMs":120000},"toolUseID":"bash-progress-2","parentToolUseID":"toolu_01Gf28AA54ThJTqPTVDHvTc8","uuid":"25bf899b-dd8f-48f4-b5f9-582106c69eec","timestamp":"2026-02-10T23:25:19.779Z"}
{"parentUuid":"25bf899b-dd8f-48f4-b5f9-582106c69eec","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"progress","data":{"type":"bash_progress","output":"","fullOutput":"","elapsedTimeSeconds":5,"totalLines":0,"timeoutMs":120000},"toolUseID":"bash-progress-3","parentToolUseID":"toolu_01Gf28AA54ThJTqPTVDHvTc8","uuid":"80fab548-5875-4ae5-9a54-91313d30b31d","timestamp":"2026-02-10T23:25:20.781Z"}
{"parentUuid":"80fab548-5875-4ae5-9a54-91313d30b31d","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"progress","data":{"type":"bash_progress","output":"","fullOutput":"","elapsedTimeSeconds":6,"totalLines":0,"timeoutMs":120000},"toolUseID":"bash-progress-4","parentToolUseID":"toolu_01Gf28AA54ThJTqPTVDHvTc8","uuid":"1afd56fb-2229-4d8e-b414-dce9ec20eba7","timestamp":"2026-02-10T23:25:21.782Z"}
{"parentUuid":"1afd56fb-2229-4d8e-b414-dce9ec20eba7","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"progress","data":{"type":"bash_progress","output":"","fullOutput":"","elapsedTimeSeconds":7,"totalLines":0,"timeoutMs":120000},"toolUseID":"bash-progress-5","parentToolUseID":"toolu_01Gf28AA54ThJTqPTVDHvTc8","uuid":"366dfb08-2a70-4a46-9af7-230f1e088916","timestamp":"2026-02-10T23:25:22.781Z"}
{"parentUuid":"366dfb08-2a70-4a46-9af7-230f1e088916","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"progress","data":{"type":"bash_progress","output":"","fullOutput":"","elapsedTimeSeconds":8,"totalLines":0,"timeoutMs":120000},"toolUseID":"bash-progress-6","parentToolUseID":"toolu_01Gf28AA54ThJTqPTVDHvTc8","uuid":"580428d0-a087-432e-b5db-3d32f2d248d5","timestamp":"2026-02-10T23:25:23.781Z"}
{"parentUuid":"580428d0-a087-432e-b5db-3d32f2d248d5","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"progress","data":{"type":"bash_progress","output":"","fullOutput":"","elapsedTimeSeconds":9,"totalLines":0,"timeoutMs":120000},"toolUseID":"bash-progress-7","parentToolUseID":"toolu_01Gf28AA54ThJTqPTVDHvTc8","uuid":"d24c04f1-e4f9-41e4-ad3e-7bc400dd222c","timestamp":"2026-02-10T23:25:24.783Z"}
{"parentUuid":"d24c04f1-e4f9-41e4-ad3e-7bc400dd222c","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"progress","data":{"type":"bash_progress","output":"","fullOutput":"","elapsedTimeSeconds":10,"totalLines":0,"timeoutMs":120000},"toolUseID":"bash-progress-8","parentToolUseID":"toolu_01Gf28AA54ThJTqPTVDHvTc8","uuid":"2ec59f42-8fdf-4071-91d7-ff3cdad0afc3","timestamp":"2026-02-10T23:25:25.786Z"}
{"parentUuid":"2ec59f42-8fdf-4071-91d7-ff3cdad0afc3","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"progress","data":{"type":"bash_progress","output":"","fullOutput":"","elapsedTimeSeconds":11,"totalLines":0,"timeoutMs":120000},"toolUseID":"bash-progress-9","parentToolUseID":"toolu_01Gf28AA54ThJTqPTVDHvTc8","uuid":"66286eba-cb5a-4041-a607-6aa2d87cd97a","timestamp":"2026-02-10T23:25:26.786Z"}
{"parentUuid":"66286eba-cb5a-4041-a607-6aa2d87cd97a","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"progress","data":{"type":"bash_progress","output":"","fullOutput":"","elapsedTimeSeconds":12,"totalLines":0,"timeoutMs":120000},"toolUseID":"bash-progress-10","parentToolUseID":"toolu_01Gf28AA54ThJTqPTVDHvTc8","uuid":"858091c1-2400-40d8-adb0-e3a7923bbfc5","timestamp":"2026-02-10T23:25:27.787Z"}
{"parentUuid":"858091c1-2400-40d8-adb0-e3a7923bbfc5","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"progress","data":{"type":"bash_progress","output":"","fullOutput":"","elapsedTimeSeconds":13,"totalLines":0,"timeoutMs":120000},"toolUseID":"bash-progress-11","parentToolUseID":"toolu_01Gf28AA54ThJTqPTVDHvTc8","uuid":"8e85f433-2649-4b89-b58e-f8a0070ae9cc","timestamp":"2026-02-10T23:25:28.788Z"}
{"parentUuid":"8e85f433-2649-4b89-b58e-f8a0070ae9cc","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"progress","data":{"type":"bash_progress","output":"","fullOutput":"","elapsedTimeSeconds":14,"totalLines":0,"timeoutMs":120000},"toolUseID":"bash-progress-12","parentToolUseID":"toolu_01Gf28AA54ThJTqPTVDHvTc8","uuid":"b7cb22c2-5b19-467d-95b8-f270f93b2e8d","timestamp":"2026-02-10T23:25:29.789Z"}
{"parentUuid":"b7cb22c2-5b19-467d-95b8-f270f93b2e8d","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"progress","data":{"type":"bash_progress","output":"","fullOutput":"","elapsedTimeSeconds":15,"totalLines":0,"timeoutMs":120000},"toolUseID":"bash-progress-13","parentToolUseID":"toolu_01Gf28AA54ThJTqPTVDHvTc8","uuid":"64621834-81cb-45c9-a456-5bcdaec6d666","timestamp":"2026-02-10T23:25:30.792Z"}
{"parentUuid":"64621834-81cb-45c9-a456-5bcdaec6d666","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"progress","data":{"type":"bash_progress","output":"","fullOutput":"","elapsedTimeSeconds":16,"totalLines":0,"timeoutMs":120000},"toolUseID":"bash-progress-14","parentToolUseID":"toolu_01Gf28AA54ThJTqPTVDHvTc8","uuid":"b6f6bd11-ce31-4fc1-86a1-337339c00f6e","timestamp":"2026-02-10T23:25:31.793Z"}
{"parentUuid":"b6f6bd11-ce31-4fc1-86a1-337339c00f6e","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"progress","data":{"type":"bash_progress","output":"","fullOutput":"","elapsedTimeSeconds":17,"totalLines":0,"timeoutMs":120000},"toolUseID":"bash-progress-15","parentToolUseID":"toolu_01Gf28AA54ThJTqPTVDHvTc8","uuid":"3fa6e9b7-0801-4dba-b8a9-f29dc0b7ba80","timestamp":"2026-02-10T23:25:32.794Z"}
{"parentUuid":"3fa6e9b7-0801-4dba-b8a9-f29dc0b7ba80","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"progress","data":{"type":"bash_progress","output":"","fullOutput":"","elapsedTimeSeconds":18,"totalLines":0,"timeoutMs":120000},"toolUseID":"bash-progress-16","parentToolUseID":"toolu_01Gf28AA54ThJTqPTVDHvTc8","uuid":"86dd2d87-383f-486a-a760-39009bc36773","timestamp":"2026-02-10T23:25:33.795Z"}
{"parentUuid":"86dd2d87-383f-486a-a760-39009bc36773","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"progress","data":{"type":"bash_progress","output":"","fullOutput":"","elapsedTimeSeconds":19,"totalLines":0,"timeoutMs":120000},"toolUseID":"bash-progress-17","parentToolUseID":"toolu_01Gf28AA54ThJTqPTVDHvTc8","uuid":"b30a5668-1d74-4544-a3a3-0d3bf8e58561","timestamp":"2026-02-10T23:25:34.796Z"}
{"parentUuid":"b30a5668-1d74-4544-a3a3-0d3bf8e58561","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"progress","data":{"type":"bash_progress","output":"","fullOutput":"","elapsedTimeSeconds":20,"totalLines":0,"timeoutMs":120000},"toolUseID":"bash-progress-18","parentToolUseID":"toolu_01Gf28AA54ThJTqPTVDHvTc8","uuid":"1a314b3f-ac89-4af9-a985-c089fa01fba4","timestamp":"2026-02-10T23:25:35.797Z"}
{"parentUuid":"1a314b3f-ac89-4af9-a985-c089fa01fba4","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"progress","data":{"type":"bash_progress","output":"","fullOutput":"","elapsedTimeSeconds":21,"totalLines":0,"timeoutMs":120000},"toolUseID":"bash-progress-19","parentToolUseID":"toolu_01Gf28AA54ThJTqPTVDHvTc8","uuid":"bac40da4-6e7c-4068-9c57-d449bdbbefbc","timestamp":"2026-02-10T23:25:36.800Z"}
{"parentUuid":"bac40da4-6e7c-4068-9c57-d449bdbbefbc","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"progress","data":{"type":"bash_progress","output":"","fullOutput":"","elapsedTimeSeconds":22,"totalLines":0,"timeoutMs":120000},"toolUseID":"bash-progress-20","parentToolUseID":"toolu_01Gf28AA54ThJTqPTVDHvTc8","uuid":"7037772b-d5a6-450d-9365-77565d426d5d","timestamp":"2026-02-10T23:25:37.800Z"}
{"parentUuid":"7037772b-d5a6-450d-9365-77565d426d5d","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"progress","data":{"type":"bash_progress","output":"","fullOutput":"","elapsedTimeSeconds":23,"totalLines":0,"timeoutMs":120000},"toolUseID":"bash-progress-21","parentToolUseID":"toolu_01Gf28AA54ThJTqPTVDHvTc8","uuid":"7cc0b989-2a6a-4011-b6bc-4e2b4748aed5","timestamp":"2026-02-10T23:25:38.801Z"}
{"parentUuid":"7cc0b989-2a6a-4011-b6bc-4e2b4748aed5","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"progress","data":{"type":"bash_progress","output":"","fullOutput":"","elapsedTimeSeconds":24,"totalLines":0,"timeoutMs":120000},"toolUseID":"bash-progress-22","parentToolUseID":"toolu_01Gf28AA54ThJTqPTVDHvTc8","uuid":"580fa733-b53c-4430-8c62-a80d6c2924cc","timestamp":"2026-02-10T23:25:39.804Z"}
{"parentUuid":"580fa733-b53c-4430-8c62-a80d6c2924cc","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"progress","data":{"type":"bash_progress","output":"","fullOutput":"","elapsedTimeSeconds":25,"totalLines":0,"timeoutMs":120000},"toolUseID":"bash-progress-23","parentToolUseID":"toolu_01Gf28AA54ThJTqPTVDHvTc8","uuid":"d0281eda-e64f-4d92-a8e4-8b5431b6c076","timestamp":"2026-02-10T23:25:40.805Z"}
{"parentUuid":"d0281eda-e64f-4d92-a8e4-8b5431b6c076","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"progress","data":{"type":"bash_progress","output":"","fullOutput":"","elapsedTimeSeconds":26,"totalLines":0,"timeoutMs":120000},"toolUseID":"bash-progress-24","parentToolUseID":"toolu_01Gf28AA54ThJTqPTVDHvTc8","uuid":"2549f3c0-c96a-41dd-bb9f-d6cbd2badae0","timestamp":"2026-02-10T23:25:41.807Z"}
{"parentUuid":"2549f3c0-c96a-41dd-bb9f-d6cbd2badae0","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"progress","data":{"type":"bash_progress","output":"","fullOutput":"","elapsedTimeSeconds":27,"totalLines":0,"timeoutMs":120000},"toolUseID":"bash-progress-25","parentToolUseID":"toolu_01Gf28AA54ThJTqPTVDHvTc8","uuid":"da498152-fb08-47a4-a7be-f37d0c922639","timestamp":"2026-02-10T23:25:42.808Z"}
{"parentUuid":"da498152-fb08-47a4-a7be-f37d0c922639","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"progress","data":{"type":"bash_progress","output":"","fullOutput":"","elapsedTimeSeconds":28,"totalLines":0,"timeoutMs":120000},"toolUseID":"bash-progress-26","parentToolUseID":"toolu_01Gf28AA54ThJTqPTVDHvTc8","uuid":"e4107c3f-5d46-44b4-858a-f33eee45c4b5","timestamp":"2026-02-10T23:25:43.810Z"}
{"parentUuid":"e4107c3f-5d46-44b4-858a-f33eee45c4b5","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"progress","data":{"type":"bash_progress","output":"","fullOutput":"","elapsedTimeSeconds":29,"totalLines":0,"timeoutMs":120000},"toolUseID":"bash-progress-27","parentToolUseID":"toolu_01Gf28AA54ThJTqPTVDHvTc8","uuid":"a14874a1-cf09-462c-9abb-1bf4b2920ceb","timestamp":"2026-02-10T23:25:44.813Z"}
{"parentUuid":"a14874a1-cf09-462c-9abb-1bf4b2920ceb","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"progress","data":{"type":"bash_progress","output":"","fullOutput":"","elapsedTimeSeconds":30,"totalLines":0,"timeoutMs":120000},"toolUseID":"bash-progress-28","parentToolUseID":"toolu_01Gf28AA54ThJTqPTVDHvTc8","uuid":"10aeb0b7-4cd2-4013-a046-d06651a38e26","timestamp":"2026-02-10T23:25:45.816Z"}
{"parentUuid":"10aeb0b7-4cd2-4013-a046-d06651a38e26","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"progress","data":{"type":"bash_progress","output":"","fullOutput":"","elapsedTimeSeconds":31,"totalLines":0,"timeoutMs":120000},"toolUseID":"bash-progress-29","parentToolUseID":"toolu_01Gf28AA54ThJTqPTVDHvTc8","uuid":"1143f1c5-a08a-4bed-b14b-3cac8e15339c","timestamp":"2026-02-10T23:25:46.816Z"}
{"parentUuid":"67fa3848-b3dc-4130-9fe1-5740301e8fec","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Gf28AA54ThJTqPTVDHvTc8","type":"tool_result","content":"  Enable tracemalloc to get traceback where the object was allocated.\n  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.\n\n-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html\n1657 passed, 4 warnings in 30.79s","is_error":false}]},"uuid":"a5c99426-da2b-4396-a186-37103b1da4b6","timestamp":"2026-02-10T23:25:47.556Z","toolUseResult":{"stdout":"  Enable tracemalloc to get traceback where the object was allocated.\n  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.\n\n-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html\n1657 passed, 4 warnings in 30.79s","stderr":"","interrupted":false,"isImage":false,"noOutputExpected":false},"sourceToolAssistantUUID":"67fa3848-b3dc-4130-9fe1-5740301e8fec"}
{"parentUuid":"30acee7f-c99e-44b2-a789-a846e3859650","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"user","message":{"role":"user","content":[{"type":"tool_result","content":"Exit code 1\nI001 [*] Import block is un-sorted or un-formatted\n  --> src/lws/parser/assembly.py:8:1\n   |\n 6 |   \"\"\"\n 7 |\n 8 | / from __future__ import annotations\n 9 | |\n10 | | import json\n11 | | import logging\n12 | | from dataclasses import dataclass, field\n13 | | from pathlib import Path\n14 | | from collections.abc import Callable\n15 | | from typing import Any\n16 | |\n17 | | from lws.parser.asset_parser import parse_assets\n18 | | from lws.parser.ref_resolver import RefResolver\n19 | | from lws.parser.template_parser import (\n20 | |     CfnResource,\n21 | |     extract_api_routes,\n22 | |     extract_dynamo_tables,\n23 | |     extract_lambda_functions,\n24 | |     parse_template,\n25 | | )\n26 | | from lws.parser.tree_parser import parse_tree\n   | |_____________________________________________^\n27 |\n28 |   logger = logging.getLogger(__name__)\n   |\nhelp: Organize imports\n\nFound 1 error.\n[*] 1 fixable with the `--fix` option.","is_error":true,"tool_use_id":"toolu_01A3iVSL4JH5vFC9whtS6Kj3"}]},"uuid":"794bdbac-5582-4af4-bd76-6ac9369df75d","timestamp":"2026-02-10T23:25:48.110Z","toolUseResult":"Error: Exit code 1\nI001 [*] Import block is un-sorted or un-formatted\n  --> src/lws/parser/assembly.py:8:1\n   |\n 6 |   \"\"\"\n 7 |\n 8 | / from __future__ import annotations\n 9 | |\n10 | | import json\n11 | | import logging\n12 | | from dataclasses import dataclass, field\n13 | | from pathlib import Path\n14 | | from collections.abc import Callable\n15 | | from typing import Any\n16 | |\n17 | | from lws.parser.asset_parser import parse_assets\n18 | | from lws.parser.ref_resolver import RefResolver\n19 | | from lws.parser.template_parser import (\n20 | |     CfnResource,\n21 | |     extract_api_routes,\n22 | |     extract_dynamo_tables,\n23 | |     extract_lambda_functions,\n24 | |     parse_template,\n25 | | )\n26 | | from lws.parser.tree_parser import parse_tree\n   | |_____________________________________________^\n27 |\n28 |   logger = logging.getLogger(__name__)\n   |\nhelp: Organize imports\n\nFound 1 error.\n[*] 1 fixable with the `--fix` option.","sourceToolAssistantUUID":"30acee7f-c99e-44b2-a789-a846e3859650"}
{"parentUuid":"794bdbac-5582-4af4-bd76-6ac9369df75d","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","message":{"model":"claude-opus-4-6","id":"msg_01RwL6Ryax9i3rNXLSTqgpDP","type":"message","role":"assistant","content":[{"type":"text","text":"Import order issue — `Callable` needs to be before `dataclass`:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":960,"cache_read_input_tokens":83919,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":960},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CY1FcSxe26FbbHqAdeqm5","type":"assistant","uuid":"8e96d1b1-6f71-48b2-97ba-c9ecc8ba20de","timestamp":"2026-02-10T23:25:50.440Z"}
{"parentUuid":"8e96d1b1-6f71-48b2-97ba-c9ecc8ba20de","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","message":{"model":"claude-opus-4-6","id":"msg_01RwL6Ryax9i3rNXLSTqgpDP","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01LtGFfe3PkmvoAQpFPgKDgt","name":"Edit","input":{"replace_all":false,"file_path":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services/src/lws/parser/assembly.py","old_string":"from dataclasses import dataclass, field\nfrom pathlib import Path\nfrom collections.abc import Callable\nfrom typing import Any","new_string":"from collections.abc import Callable\nfrom dataclasses import dataclass, field\nfrom pathlib import Path\nfrom typing import Any"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":960,"cache_read_input_tokens":83919,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":960},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CY1FcSxe26FbbHqAdeqm5","type":"assistant","uuid":"6294774c-6777-4089-9fbf-417cddca7374","timestamp":"2026-02-10T23:25:51.861Z"}
{"parentUuid":"6294774c-6777-4089-9fbf-417cddca7374","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"callback"},"parentToolUseID":"toolu_01LtGFfe3PkmvoAQpFPgKDgt","toolUseID":"toolu_01LtGFfe3PkmvoAQpFPgKDgt","timestamp":"2026-02-10T23:25:51.865Z","uuid":"99f13012-ce4f-4f4a-af3c-108beee63797"}
{"parentUuid":"6294774c-6777-4089-9fbf-417cddca7374","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01LtGFfe3PkmvoAQpFPgKDgt","type":"tool_result","content":"The file /Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services/src/lws/parser/assembly.py has been updated successfully."}]},"uuid":"ffc20229-60d5-4a30-9c14-7af7d055cb5e","timestamp":"2026-02-10T23:25:51.864Z","toolUseResult":{"filePath":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services/src/lws/parser/assembly.py","oldString":"from dataclasses import dataclass, field\nfrom pathlib import Path\nfrom collections.abc import Callable\nfrom typing import Any","newString":"from collections.abc import Callable\nfrom dataclasses import dataclass, field\nfrom pathlib import Path\nfrom typing import Any","originalFile":"\"\"\"Assembly orchestrator -- top-level entry point for CDK output parsing.\n\nTies together tree parsing, template parsing, reference resolution and\nasset location to produce a single ``AppModel`` that the rest of the\nsystem can consume.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport json\nimport logging\nfrom dataclasses import dataclass, field\nfrom pathlib import Path\nfrom collections.abc import Callable\nfrom typing import Any\n\nfrom lws.parser.asset_parser import parse_assets\nfrom lws.parser.ref_resolver import RefResolver\nfrom lws.parser.template_parser import (\n    CfnResource,\n    extract_api_routes,\n    extract_dynamo_tables,\n    extract_lambda_functions,\n    parse_template,\n)\nfrom lws.parser.tree_parser import parse_tree\n\nlogger = logging.getLogger(__name__)\n\n# ---------------------------------------------------------------------------\n# Domain model dataclasses\n# ---------------------------------------------------------------------------\n\n\n@dataclass\nclass LambdaFunction:\n    \"\"\"Parsed Lambda function ready for local execution.\"\"\"\n\n    name: str\n    handler: str\n    runtime: str\n    code_path: Path | None = None\n    timeout: int = 30\n    memory: int = 128\n    environment: dict[str, str] = field(default_factory=dict)\n\n    @property\n    def logical_id(self) -> str:\n        return self.name\n\n\n@dataclass\nclass DynamoTable:\n    \"\"\"Parsed DynamoDB table definition.\"\"\"\n\n    name: str\n    key_schema: list[dict[str, str]] = field(default_factory=list)\n    gsi_definitions: list[dict[str, Any]] = field(default_factory=list)\n\n    @property\n    def logical_id(self) -> str:\n        return self.name\n\n    @property\n    def table_name(self) -> str:\n        return self.name\n\n\n@dataclass\nclass ApiRoute:\n    \"\"\"A single API Gateway route.\"\"\"\n\n    method: str\n    path: str\n    handler_name: str | None = None\n\n\n@dataclass\nclass ApiDefinition:\n    \"\"\"A collection of routes making up an API.\"\"\"\n\n    name: str = \"default\"\n    routes: list[ApiRoute] = field(default_factory=list)\n\n    @property\n    def logical_id(self) -> str:\n        return self.name\n\n\n@dataclass\nclass SqsQueue:\n    \"\"\"Parsed SQS queue definition.\"\"\"\n\n    name: str\n    is_fifo: bool = False\n    visibility_timeout: int = 30\n    content_based_dedup: bool = False\n    redrive_target: str | None = None\n    max_receive_count: int = 5\n\n\n@dataclass\nclass S3Bucket:\n    \"\"\"Parsed S3 bucket definition.\"\"\"\n\n    name: str\n\n\n@dataclass\nclass SnsTopic:\n    \"\"\"Parsed SNS topic definition.\"\"\"\n\n    name: str\n    topic_arn: str = \"\"\n\n\n@dataclass\nclass EventBus:\n    \"\"\"Parsed EventBridge event bus definition.\"\"\"\n\n    name: str\n    bus_arn: str = \"\"\n\n\n@dataclass\nclass EventRule:\n    \"\"\"Parsed EventBridge rule definition.\"\"\"\n\n    rule_name: str\n    event_bus_name: str = \"default\"\n    event_pattern: dict[str, Any] | None = None\n    schedule_expression: str | None = None\n    targets: list[dict[str, Any]] = field(default_factory=list)\n\n\n@dataclass\nclass StateMachine:\n    \"\"\"Parsed Step Functions state machine definition.\"\"\"\n\n    name: str\n    definition: str | dict[str, Any] = \"\"\n    workflow_type: str = \"STANDARD\"\n    role_arn: str = \"\"\n    definition_substitutions: dict[str, str] = field(default_factory=dict)\n\n\n@dataclass\nclass CognitoUserPool:\n    \"\"\"Parsed Cognito user pool definition.\"\"\"\n\n    logical_id: str\n    user_pool_name: str = \"default\"\n    auto_confirm: bool = True\n    password_policy: dict[str, Any] = field(default_factory=dict)\n    pre_auth_trigger: str | None = None\n    post_confirm_trigger: str | None = None\n    client_id: str = \"\"\n\n\n@dataclass\nclass SsmParameter:\n    \"\"\"Parsed SSM Parameter Store parameter.\"\"\"\n\n    name: str\n    type: str  # \"String\", \"StringList\", \"SecureString\"\n    value: str\n    description: str = \"\"\n\n\n@dataclass\nclass SmSecret:\n    \"\"\"Parsed Secrets Manager secret.\"\"\"\n\n    name: str\n    description: str = \"\"\n    secret_string: str | None = None\n\n\n@dataclass\nclass AppModel:\n    \"\"\"Complete parsed representation of a CDK application.\"\"\"\n\n    functions: list[LambdaFunction] = field(default_factory=list)\n    tables: list[DynamoTable] = field(default_factory=list)\n    apis: list[ApiDefinition] = field(default_factory=list)\n    queues: list[SqsQueue] = field(default_factory=list)\n    buckets: list[S3Bucket] = field(default_factory=list)\n    topics: list[SnsTopic] = field(default_factory=list)\n    event_buses: list[EventBus] = field(default_factory=list)\n    event_rules: list[EventRule] = field(default_factory=list)\n    state_machines: list[StateMachine] = field(default_factory=list)\n    user_pools: list[CognitoUserPool] = field(default_factory=list)\n    ecs_services: list[Any] = field(default_factory=list)\n    ssm_parameters: list[SsmParameter] = field(default_factory=list)\n    secrets: list[SmSecret] = field(default_factory=list)\n\n\n# ---------------------------------------------------------------------------\n# Orchestrator\n# ---------------------------------------------------------------------------\n\n\ndef parse_assembly(cdk_out_path: Path) -> AppModel:\n    \"\"\"Parse an entire CDK ``cdk.out`` directory into an :class:`AppModel`.\n\n    Parameters\n    ----------\n    cdk_out_path:\n        Path to the ``cdk.out`` directory produced by ``cdk synth``.\n\n    Returns\n    -------\n    AppModel\n    \"\"\"\n    manifest_path = cdk_out_path / \"manifest.json\"\n    if not manifest_path.exists():\n        logger.warning(\"No manifest.json found in %s\", cdk_out_path)\n        return AppModel()\n\n    with open(manifest_path, encoding=\"utf-8\") as fh:\n        manifest = json.load(fh)\n\n    # Parse assets (hash -> filesystem path)\n    asset_map = parse_assets(cdk_out_path)\n\n    # Parse tree.json if present\n    tree_path = cdk_out_path / \"tree.json\"\n    if tree_path.exists():\n        parse_tree(tree_path)  # Currently used for validation; future enrichment\n\n    # Collect all stack artifacts\n    model = AppModel()\n    for artifact_id, artifact in (manifest.get(\"artifacts\") or {}).items():\n        if artifact.get(\"type\") != \"aws:cloudformation:stack\":\n            continue\n        _process_stack(cdk_out_path, artifact_id, artifact, asset_map, model)\n\n    return model\n\n\ndef _process_stack(\n    cdk_out_path: Path,\n    artifact_id: str,\n    artifact: dict,\n    asset_map: dict[str, Path],\n    model: AppModel,\n) -> None:\n    \"\"\"Process a single CloudFormation stack artifact.\"\"\"\n    template_file = artifact.get(\"properties\", {}).get(\"templateFile\")\n    if not template_file:\n        logger.warning(\"Stack %s has no templateFile\", artifact_id)\n        return\n\n    template_path = cdk_out_path / template_file\n    if not template_path.exists():\n        logger.warning(\"Template not found: %s\", template_path)\n        return\n\n    resources = parse_template(template_path)\n    resource_type_map = {r.logical_id: r.resource_type for r in resources}\n    resource_map = _build_resource_map(resources)\n    resolver = RefResolver(resource_map=resource_map, resource_types=resource_type_map)\n\n    model.functions.extend(_collect_lambdas(resources, asset_map, cdk_out_path, resolver))\n    model.tables.extend(_collect_tables(resources, resolver))\n    api_def = _collect_api_routes(resources, resolver, artifact_id)\n    if api_def:\n        model.apis.append(api_def)\n    model.queues.extend(_collect_queues(resources, resolver))\n    model.buckets.extend(_collect_buckets(resources))\n    model.topics.extend(_collect_topics(resources, resolver))\n    model.event_buses.extend(_collect_event_buses(resources, resolver))\n    model.event_rules.extend(_collect_event_rules(resources, resolver))\n    model.state_machines.extend(_collect_state_machines(resources, resolver))\n    model.user_pools.extend(_collect_user_pools(resources, resolver))\n    model.ssm_parameters.extend(_collect_ssm_parameters(resources, resolver))\n    model.secrets.extend(_collect_secrets(resources, resolver))\n\n    # ECS needs the raw template dict\n    with open(template_path, encoding=\"utf-8\") as fh:\n        raw_template = json.load(fh)\n    ecs_services = _collect_ecs_services(raw_template)\n    model.ecs_services.extend(ecs_services)\n\n\ndef _build_resource_map(resources: list[CfnResource]) -> dict[str, str]:\n    \"\"\"Build a Ref resource_map so intrinsic ``Ref`` calls resolve to useful local values.\n\n    In real CloudFormation:\n    - ``Ref`` on an ``AWS::SQS::Queue`` returns the queue URL.\n    - ``Ref`` on an ``AWS::DynamoDB::Table`` returns the table name.\n\n    We reproduce this behaviour with deterministic local placeholders so that\n    Lambda environment variables like ``QUEUE_URL`` and ``TABLE_NAME`` resolve\n    to values the local providers can understand.\n    \"\"\"\n    resource_map: dict[str, str] = {}\n    for r in resources:\n        ref = _resolve_ref_value(r)\n        if ref is not None:\n            resource_map[r.logical_id] = ref\n    return resource_map\n\n\ndef _resolve_ref_value(r: CfnResource) -> str | None:\n    \"\"\"Return the local Ref value for a single CloudFormation resource, or None.\"\"\"\n    handler = _REF_RESOLVERS.get(r.resource_type)\n    if handler is not None:\n        return handler(r)\n    return None\n\n\ndef _ref_sqs(r: CfnResource) -> str | None:\n    queue_name = r.properties.get(\"QueueName\", r.logical_id)\n    if isinstance(queue_name, str):\n        return f\"arn:ldk:sqs:local:000000000000:queue/{queue_name}\"\n    return None\n\n\ndef _ref_dynamodb(r: CfnResource) -> str | None:\n    table_name = r.properties.get(\"TableName\", r.logical_id)\n    return table_name if isinstance(table_name, str) else None\n\n\ndef _ref_s3(r: CfnResource) -> str:\n    bucket_name = r.properties.get(\"BucketName\", r.logical_id)\n    return bucket_name if isinstance(bucket_name, str) else r.logical_id\n\n\ndef _ref_sns(r: CfnResource) -> str | None:\n    topic_name = r.properties.get(\"TopicName\", r.logical_id)\n    if isinstance(topic_name, str):\n        return f\"arn:ldk:sns:local:000000000000:{topic_name}\"\n    return None\n\n\ndef _ref_ssm(r: CfnResource) -> str | None:\n    name = r.properties.get(\"Name\", r.logical_id)\n    return name if isinstance(name, str) else None\n\n\ndef _ref_secretsmanager(r: CfnResource) -> str | None:\n    name = r.properties.get(\"Name\", r.logical_id)\n    if isinstance(name, str):\n        return f\"arn:aws:secretsmanager:us-east-1:000000000000:secret:{name}\"\n    return None\n\n\n_REF_RESOLVERS: dict[str, Callable[[CfnResource], str | None]] = {\n    \"AWS::SQS::Queue\": _ref_sqs,\n    \"AWS::DynamoDB::Table\": _ref_dynamodb,\n    \"AWS::S3::Bucket\": _ref_s3,\n    \"AWS::SNS::Topic\": _ref_sns,\n    \"AWS::SSM::Parameter\": _ref_ssm,\n    \"AWS::SecretsManager::Secret\": _ref_secretsmanager,\n}\n\n\ndef _collect_lambdas(\n    resources: list[CfnResource],\n    asset_map: dict[str, Path],\n    cdk_out_path: Path,\n    resolver: RefResolver,\n) -> list[LambdaFunction]:\n    \"\"\"Extract Lambda functions from parsed CloudFormation resources.\"\"\"\n    functions: list[LambdaFunction] = []\n    lambda_props_list = extract_lambda_functions(resources)\n    lambda_resources = [r for r in resources if r.resource_type == \"AWS::Lambda::Function\"]\n    for r, props in zip(lambda_resources, lambda_props_list):\n        code_path = _resolve_code_path(props.code_uri, asset_map, cdk_out_path, resolver)\n        env = {k: str(resolver.resolve(v)) for k, v in props.environment.items()}\n        functions.append(\n            LambdaFunction(\n                name=r.logical_id,\n                handler=props.handler or \"index.handler\",\n                runtime=props.runtime or \"python3.11\",\n                code_path=code_path,\n                timeout=props.timeout or 30,\n                memory=props.memory_size or 128,\n                environment=env,\n            )\n        )\n    return functions\n\n\ndef _collect_tables(\n    resources: list[CfnResource],\n    resolver: RefResolver,\n) -> list[DynamoTable]:\n    \"\"\"Extract DynamoDB tables from parsed CloudFormation resources.\"\"\"\n    tables: list[DynamoTable] = []\n    dynamo_props_list = extract_dynamo_tables(resources)\n    dynamo_resources = [r for r in resources if r.resource_type == \"AWS::DynamoDB::Table\"]\n    for r, props in zip(dynamo_resources, dynamo_props_list):\n        name = props.table_name or r.logical_id\n        if isinstance(name, dict):\n            name = str(resolver.resolve(name))\n        tables.append(\n            DynamoTable(\n                name=name,\n                key_schema=props.key_schema,\n                gsi_definitions=props.gsi_definitions,\n            )\n        )\n    return tables\n\n\ndef _collect_api_routes(\n    resources: list[CfnResource],\n    resolver: RefResolver,\n    artifact_id: str,\n) -> ApiDefinition | None:\n    \"\"\"Extract API Gateway routes from parsed CloudFormation resources.\"\"\"\n    api_routes = extract_api_routes(resources)\n    if not api_routes:\n        return None\n    routes: list[ApiRoute] = []\n    for route_props in api_routes:\n        handler_name = _find_handler_for_integration(\n            route_props.integration_uri, resources, resolver\n        )\n        routes.append(\n            ApiRoute(\n                method=route_props.http_method or \"ANY\",\n                path=route_props.resource_path or \"/\",\n                handler_name=handler_name,\n            )\n        )\n    return ApiDefinition(name=artifact_id, routes=routes)\n\n\ndef _resolve_code_from_s3_key(s3_key: str, asset_map: dict[str, Path]) -> Path | None:\n    \"\"\"Try to match an S3Key to an asset by hash.\"\"\"\n    asset_hash = s3_key.replace(\".zip\", \"\")\n    if asset_hash in asset_map:\n        return asset_map[asset_hash]\n    for hash_key, path in asset_map.items():\n        if hash_key in s3_key:\n            return path\n    return None\n\n\ndef _resolve_code_from_s3_bucket(\n    s3_bucket: dict, resolver: RefResolver, asset_map: dict[str, Path]\n) -> Path | None:\n    \"\"\"Try to match an S3Bucket ref to an asset.\"\"\"\n    resolved = str(resolver.resolve(s3_bucket))\n    for h, p in asset_map.items():\n        if h in resolved:\n            return p\n    return None\n\n\ndef _resolve_code_path(\n    code_uri: Any,\n    asset_map: dict[str, Path],\n    cdk_out_path: Path,\n    resolver: RefResolver,\n) -> Path | None:\n    \"\"\"Resolve a Lambda Code property to a local filesystem path.\"\"\"\n    if code_uri is None:\n        return None\n\n    if isinstance(code_uri, dict):\n        s3_key = code_uri.get(\"S3Key\")\n        if isinstance(s3_key, str):\n            result = _resolve_code_from_s3_key(s3_key, asset_map)\n            if result:\n                return result\n\n        s3_bucket = code_uri.get(\"S3Bucket\")\n        if isinstance(s3_bucket, dict):\n            result = _resolve_code_from_s3_bucket(s3_bucket, resolver, asset_map)\n            if result:\n                return result\n\n    if isinstance(code_uri, str):\n        candidate = cdk_out_path / code_uri\n        if candidate.exists():\n            return candidate\n\n    return None\n\n\ndef _find_handler_for_integration(\n    integration_uri: Any,\n    resources: list[CfnResource],\n    resolver: RefResolver,\n) -> str | None:\n    \"\"\"Try to match an API integration URI back to a Lambda logical ID.\"\"\"\n    if integration_uri is None:\n        return None\n\n    resolved = str(resolver.resolve(integration_uri))\n\n    # Look for a Lambda function logical ID in the resolved string\n    for r in resources:\n        if r.resource_type == \"AWS::Lambda::Function\":\n            if r.logical_id in resolved:\n                return r.logical_id\n\n    return None\n\n\n# ---------------------------------------------------------------------------\n# Collectors for new resource types\n# ---------------------------------------------------------------------------\n\n\ndef _collect_queues(\n    resources: list[CfnResource],\n    resolver: RefResolver,\n) -> list[SqsQueue]:\n    \"\"\"Extract SQS queues from parsed CloudFormation resources.\"\"\"\n    queues: list[SqsQueue] = []\n    for r in resources:\n        if r.resource_type != \"AWS::SQS::Queue\":\n            continue\n        props = r.properties\n        name = props.get(\"QueueName\", r.logical_id)\n        if isinstance(name, dict):\n            name = str(resolver.resolve(name))\n        is_fifo = bool(props.get(\"FifoQueue\", False))\n        vis = int(props.get(\"VisibilityTimeout\", 30))\n        dedup = bool(props.get(\"ContentBasedDeduplication\", False))\n        redrive = props.get(\"RedrivePolicy\")\n        redrive_target = None\n        max_receive = 5\n        if isinstance(redrive, dict):\n            dlq = redrive.get(\"deadLetterTargetArn\", \"\")\n            if isinstance(dlq, dict):\n                dlq = str(resolver.resolve(dlq))\n            redrive_target = str(dlq) if dlq else None\n            max_receive = int(redrive.get(\"maxReceiveCount\", 5))\n        queues.append(\n            SqsQueue(\n                name=name,\n                is_fifo=is_fifo,\n                visibility_timeout=vis,\n                content_based_dedup=dedup,\n                redrive_target=redrive_target,\n                max_receive_count=max_receive,\n            )\n        )\n    return queues\n\n\ndef _collect_buckets(resources: list[CfnResource]) -> list[S3Bucket]:\n    \"\"\"Extract S3 buckets from parsed CloudFormation resources.\"\"\"\n    buckets: list[S3Bucket] = []\n    for r in resources:\n        if r.resource_type != \"AWS::S3::Bucket\":\n            continue\n        name = r.properties.get(\"BucketName\", r.logical_id)\n        if isinstance(name, dict):\n            name = r.logical_id  # Can't resolve intrinsics for bucket names easily\n        buckets.append(S3Bucket(name=name))\n    return buckets\n\n\ndef _collect_topics(\n    resources: list[CfnResource],\n    resolver: RefResolver,\n) -> list[SnsTopic]:\n    \"\"\"Extract SNS topics from parsed CloudFormation resources.\"\"\"\n    topics: list[SnsTopic] = []\n    for r in resources:\n        if r.resource_type != \"AWS::SNS::Topic\":\n            continue\n        props = r.properties\n        name = props.get(\"TopicName\", r.logical_id)\n        if isinstance(name, dict):\n            name = str(resolver.resolve(name))\n        arn = f\"arn:aws:sns:us-east-1:000000000000:{name}\"\n        topics.append(SnsTopic(name=name, topic_arn=arn))\n    return topics\n\n\ndef _collect_event_buses(\n    resources: list[CfnResource],\n    resolver: RefResolver,\n) -> list[EventBus]:\n    \"\"\"Extract EventBridge event buses from parsed CloudFormation resources.\"\"\"\n    buses: list[EventBus] = []\n    for r in resources:\n        if r.resource_type != \"AWS::Events::EventBus\":\n            continue\n        props = r.properties\n        name = props.get(\"Name\", r.logical_id)\n        if isinstance(name, dict):\n            name = str(resolver.resolve(name))\n        arn = f\"arn:aws:events:us-east-1:000000000000:event-bus/{name}\"\n        buses.append(EventBus(name=name, bus_arn=arn))\n    return buses\n\n\ndef _collect_event_rules(\n    resources: list[CfnResource],\n    resolver: RefResolver,\n) -> list[EventRule]:\n    \"\"\"Extract EventBridge rules from parsed CloudFormation resources.\"\"\"\n    rules: list[EventRule] = []\n    for r in resources:\n        if r.resource_type != \"AWS::Events::Rule\":\n            continue\n        props = r.properties\n        rule_name = props.get(\"Name\", r.logical_id)\n        if isinstance(rule_name, dict):\n            rule_name = str(resolver.resolve(rule_name))\n        bus_name = props.get(\"EventBusName\", \"default\")\n        if isinstance(bus_name, dict):\n            bus_name = str(resolver.resolve(bus_name))\n        pattern = props.get(\"EventPattern\")\n        schedule = props.get(\"ScheduleExpression\")\n        raw_targets = props.get(\"Targets\", [])\n        targets: list[dict[str, Any]] = []\n        for t in raw_targets:\n            target_arn = t.get(\"Arn\", \"\")\n            if isinstance(target_arn, dict):\n                target_arn = str(resolver.resolve(target_arn))\n            targets.append(\n                {\n                    \"target_id\": t.get(\"Id\", \"\"),\n                    \"arn\": target_arn,\n                    \"input_path\": t.get(\"InputPath\"),\n                    \"input_template\": t.get(\"InputTransformer\", {}).get(\"InputTemplate\"),\n                }\n            )\n        rules.append(\n            EventRule(\n                rule_name=rule_name,\n                event_bus_name=bus_name,\n                event_pattern=pattern,\n                schedule_expression=schedule,\n                targets=targets,\n            )\n        )\n    return rules\n\n\ndef _resolve_sm_definition(definition: Any, resolver: RefResolver) -> Any:\n    \"\"\"Resolve a Step Functions DefinitionString that may use intrinsic functions.\"\"\"\n    if isinstance(definition, dict):\n        return resolver.resolve(definition)\n    return definition\n\n\ndef _resolve_substitutions(subs: dict[str, Any], resolver: RefResolver) -> dict[str, str]:\n    \"\"\"Resolve CloudFormation DefinitionSubstitutions to plain strings.\"\"\"\n    return {k: str(resolver.resolve(v)) if isinstance(v, dict) else str(v) for k, v in subs.items()}\n\n\ndef _collect_state_machines(\n    resources: list[CfnResource],\n    resolver: RefResolver,\n) -> list[StateMachine]:\n    \"\"\"Extract Step Functions state machines from parsed CloudFormation resources.\"\"\"\n    machines: list[StateMachine] = []\n    for r in resources:\n        if r.resource_type != \"AWS::StepFunctions::StateMachine\":\n            continue\n        props = r.properties\n        name = props.get(\"StateMachineName\", r.logical_id)\n        if isinstance(name, dict):\n            name = str(resolver.resolve(name))\n        definition = props.get(\"DefinitionString\", props.get(\"Definition\", \"\"))\n        definition = _resolve_sm_definition(definition, resolver)\n        role_arn = props.get(\"RoleArn\", \"\")\n        if isinstance(role_arn, dict):\n            role_arn = str(resolver.resolve(role_arn))\n        resolved_subs = _resolve_substitutions(props.get(\"DefinitionSubstitutions\", {}), resolver)\n        machines.append(\n            StateMachine(\n                name=name,\n                definition=definition,\n                workflow_type=props.get(\"StateMachineType\", \"STANDARD\"),\n                role_arn=role_arn,\n                definition_substitutions=resolved_subs,\n            )\n        )\n    return machines\n\n\ndef _collect_user_pools(\n    resources: list[CfnResource],\n    resolver: RefResolver,\n) -> list[CognitoUserPool]:\n    \"\"\"Extract Cognito user pools from parsed CloudFormation resources.\"\"\"\n    pools: list[CognitoUserPool] = []\n    # First pass: collect user pool clients to map pool -> client_id\n    client_map: dict[str, str] = {}\n    for r in resources:\n        if r.resource_type != \"AWS::Cognito::UserPoolClient\":\n            continue\n        pool_ref = r.properties.get(\"UserPoolId\", \"\")\n        if isinstance(pool_ref, dict):\n            pool_ref = str(resolver.resolve(pool_ref))\n        client_map[pool_ref] = r.logical_id\n\n    for r in resources:\n        if r.resource_type != \"AWS::Cognito::UserPool\":\n            continue\n        props = r.properties\n        name = props.get(\"UserPoolName\", r.logical_id)\n        if isinstance(name, dict):\n            name = str(resolver.resolve(name))\n        auto_confirm = True\n        lambda_config = props.get(\"LambdaConfig\", {})\n        pre_auth = lambda_config.get(\"PreAuthentication\")\n        if isinstance(pre_auth, dict):\n            pre_auth = str(resolver.resolve(pre_auth))\n        post_confirm = lambda_config.get(\"PostConfirmation\")\n        if isinstance(post_confirm, dict):\n            post_confirm = str(resolver.resolve(post_confirm))\n        pw_policy = props.get(\"Policies\", {}).get(\"PasswordPolicy\", {})\n        client_id = client_map.get(r.logical_id, \"\")\n        pools.append(\n            CognitoUserPool(\n                logical_id=r.logical_id,\n                user_pool_name=name,\n                auto_confirm=auto_confirm,\n                password_policy=pw_policy,\n                pre_auth_trigger=pre_auth,\n                post_confirm_trigger=post_confirm,\n                client_id=client_id,\n            )\n        )\n    return pools\n\n\ndef _collect_ssm_parameters(\n    resources: list[CfnResource],\n    resolver: RefResolver,\n) -> list[SsmParameter]:\n    \"\"\"Extract SSM parameters from parsed CloudFormation resources.\"\"\"\n    parameters: list[SsmParameter] = []\n    for r in resources:\n        if r.resource_type != \"AWS::SSM::Parameter\":\n            continue\n        props = r.properties\n        name = props.get(\"Name\", r.logical_id)\n        if isinstance(name, dict):\n            name = str(resolver.resolve(name))\n        param_type = props.get(\"Type\", \"String\")\n        value = props.get(\"Value\", \"\")\n        if isinstance(value, dict):\n            value = str(resolver.resolve(value))\n        description = props.get(\"Description\", \"\")\n        parameters.append(\n            SsmParameter(name=name, type=param_type, value=value, description=description)\n        )\n    return parameters\n\n\ndef _collect_secrets(\n    resources: list[CfnResource],\n    resolver: RefResolver,\n) -> list[SmSecret]:\n    \"\"\"Extract Secrets Manager secrets from parsed CloudFormation resources.\"\"\"\n    secrets: list[SmSecret] = []\n    for r in resources:\n        if r.resource_type != \"AWS::SecretsManager::Secret\":\n            continue\n        props = r.properties\n        name = props.get(\"Name\", r.logical_id)\n        if isinstance(name, dict):\n            name = str(resolver.resolve(name))\n        description = props.get(\"Description\", \"\")\n        secret_string = props.get(\"SecretString\")\n        if secret_string is None:\n            # Try GenerateSecretString.SecretStringTemplate\n            gen = props.get(\"GenerateSecretString\", {})\n            if isinstance(gen, dict):\n                secret_string = gen.get(\"SecretStringTemplate\")\n        if isinstance(secret_string, dict):\n            secret_string = str(resolver.resolve(secret_string))\n        secrets.append(SmSecret(name=name, description=description, secret_string=secret_string))\n    return secrets\n\n\ndef _collect_ecs_services(template: dict) -> list:\n    \"\"\"Extract ECS services from the raw CloudFormation template.\"\"\"\n    try:\n        from lws.providers.ecs.provider import parse_ecs_resources\n\n        return parse_ecs_resources(template)\n    except Exception:\n        logger.debug(\"Could not parse ECS resources\", exc_info=True)\n        return []\n","structuredPatch":[{"oldStart":9,"oldLines":9,"newStart":9,"newLines":9,"lines":[" "," import json"," import logging","+from collections.abc import Callable"," from dataclasses import dataclass, field"," from pathlib import Path","-from collections.abc import Callable"," from typing import Any"," "," from lws.parser.asset_parser import parse_assets"]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"6294774c-6777-4089-9fbf-417cddca7374"}
{"parentUuid":"ffc20229-60d5-4a30-9c14-7af7d055cb5e","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","message":{"model":"claude-opus-4-6","id":"msg_01H7HSj53FgQKyGgLPeWBMBz","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_018tYx3RFzzdpag8VnPACL2S","name":"Bash","input":{"command":"uvx ruff check src/lws/parser/assembly.py src/lws/cli/ldk.py src/lws/providers/ssm/routes.py src/lws/providers/secretsmanager/routes.py src/lws/parser/tree_parser.py 2>&1","description":"Run ruff lint on changed files","timeout":60000}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":272,"cache_read_input_tokens":84879,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":272},"output_tokens":25,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CY1Fcjbm3vJeburZeimnq","type":"assistant","uuid":"223be2e3-9ae2-4ce0-975b-23307f703289","timestamp":"2026-02-10T23:25:55.679Z"}
{"parentUuid":"223be2e3-9ae2-4ce0-975b-23307f703289","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_018tYx3RFzzdpag8VnPACL2S","type":"tool_result","content":"All checks passed!","is_error":false}]},"uuid":"68884b1b-beb2-4a93-ae43-acbebe8c9046","timestamp":"2026-02-10T23:25:56.159Z","toolUseResult":{"stdout":"All checks passed!","stderr":"","interrupted":false,"isImage":false,"noOutputExpected":false},"sourceToolAssistantUUID":"223be2e3-9ae2-4ce0-975b-23307f703289"}
{"parentUuid":"68884b1b-beb2-4a93-ae43-acbebe8c9046","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","message":{"model":"claude-opus-4-6","id":"msg_01FNHjosRa3KMuAV2AupH3qq","type":"message","role":"assistant","content":[{"type":"text","text":"All checks pass. Let me verify tests still pass:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":177,"cache_read_input_tokens":85151,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":177},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CY1Fd31G9r4jNcFbrfQ9o","type":"assistant","uuid":"88c3ef47-2003-4867-9949-f25733d593a3","timestamp":"2026-02-10T23:26:01.769Z"}
{"parentUuid":"88c3ef47-2003-4867-9949-f25733d593a3","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","message":{"model":"claude-opus-4-6","id":"msg_01FNHjosRa3KMuAV2AupH3qq","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01XHXjvfeBG5aiqaoGZjBCRx","name":"Bash","input":{"command":"uv run python -m pytest tests/ -x -q 2>&1 | tail -5","description":"Run unit tests","timeout":120000}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":177,"cache_read_input_tokens":85151,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":177},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CY1Fd31G9r4jNcFbrfQ9o","type":"assistant","uuid":"8d2606b7-644b-4312-8fc6-7a28231c497b","timestamp":"2026-02-10T23:26:02.769Z"}
{"parentUuid":"8d2606b7-644b-4312-8fc6-7a28231c497b","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"progress","data":{"type":"bash_progress","output":"","fullOutput":"","elapsedTimeSeconds":2,"totalLines":0,"timeoutMs":120000},"toolUseID":"bash-progress-0","parentToolUseID":"toolu_01XHXjvfeBG5aiqaoGZjBCRx","uuid":"d6614be4-19e7-44fa-8261-4ca92c89adbe","timestamp":"2026-02-10T23:26:04.794Z"}
{"parentUuid":"d6614be4-19e7-44fa-8261-4ca92c89adbe","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"progress","data":{"type":"bash_progress","output":"","fullOutput":"","elapsedTimeSeconds":3,"totalLines":0,"timeoutMs":120000},"toolUseID":"bash-progress-1","parentToolUseID":"toolu_01XHXjvfeBG5aiqaoGZjBCRx","uuid":"a36dcc56-ab07-4e21-bd45-752d092fd65e","timestamp":"2026-02-10T23:26:05.795Z"}
{"parentUuid":"a36dcc56-ab07-4e21-bd45-752d092fd65e","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"progress","data":{"type":"bash_progress","output":"","fullOutput":"","elapsedTimeSeconds":4,"totalLines":0,"timeoutMs":120000},"toolUseID":"bash-progress-2","parentToolUseID":"toolu_01XHXjvfeBG5aiqaoGZjBCRx","uuid":"1466e8a1-29d4-4b0e-b975-eb707f318c78","timestamp":"2026-02-10T23:26:06.798Z"}
{"parentUuid":"1466e8a1-29d4-4b0e-b975-eb707f318c78","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"progress","data":{"type":"bash_progress","output":"","fullOutput":"","elapsedTimeSeconds":5,"totalLines":0,"timeoutMs":120000},"toolUseID":"bash-progress-3","parentToolUseID":"toolu_01XHXjvfeBG5aiqaoGZjBCRx","uuid":"a9a7f6f5-df07-474e-a218-37a5fa255a86","timestamp":"2026-02-10T23:26:07.800Z"}
{"parentUuid":"a9a7f6f5-df07-474e-a218-37a5fa255a86","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"progress","data":{"type":"bash_progress","output":"","fullOutput":"","elapsedTimeSeconds":6,"totalLines":0,"timeoutMs":120000},"toolUseID":"bash-progress-4","parentToolUseID":"toolu_01XHXjvfeBG5aiqaoGZjBCRx","uuid":"ee4f9575-9a74-4076-954b-a7414de9cc19","timestamp":"2026-02-10T23:26:08.801Z"}
{"parentUuid":"ee4f9575-9a74-4076-954b-a7414de9cc19","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"progress","data":{"type":"bash_progress","output":"","fullOutput":"","elapsedTimeSeconds":7,"totalLines":0,"timeoutMs":120000},"toolUseID":"bash-progress-5","parentToolUseID":"toolu_01XHXjvfeBG5aiqaoGZjBCRx","uuid":"79ccac93-f2c5-41b9-81a8-47c5a2412b64","timestamp":"2026-02-10T23:26:09.802Z"}
{"parentUuid":"79ccac93-f2c5-41b9-81a8-47c5a2412b64","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"progress","data":{"type":"bash_progress","output":"","fullOutput":"","elapsedTimeSeconds":8,"totalLines":0,"timeoutMs":120000},"toolUseID":"bash-progress-6","parentToolUseID":"toolu_01XHXjvfeBG5aiqaoGZjBCRx","uuid":"c1b464f9-8f9b-47d3-bf41-dbc05f8bf032","timestamp":"2026-02-10T23:26:10.804Z"}
{"parentUuid":"c1b464f9-8f9b-47d3-bf41-dbc05f8bf032","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"progress","data":{"type":"bash_progress","output":"","fullOutput":"","elapsedTimeSeconds":9,"totalLines":0,"timeoutMs":120000},"toolUseID":"bash-progress-7","parentToolUseID":"toolu_01XHXjvfeBG5aiqaoGZjBCRx","uuid":"92ea01ec-bd5e-41d0-b0c5-b3a5a4780de1","timestamp":"2026-02-10T23:26:11.807Z"}
{"parentUuid":"92ea01ec-bd5e-41d0-b0c5-b3a5a4780de1","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"progress","data":{"type":"bash_progress","output":"","fullOutput":"","elapsedTimeSeconds":10,"totalLines":0,"timeoutMs":120000},"toolUseID":"bash-progress-8","parentToolUseID":"toolu_01XHXjvfeBG5aiqaoGZjBCRx","uuid":"ae50548d-b2eb-4181-aeb1-d295993d8620","timestamp":"2026-02-10T23:26:12.808Z"}
{"parentUuid":"ae50548d-b2eb-4181-aeb1-d295993d8620","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"progress","data":{"type":"bash_progress","output":"","fullOutput":"","elapsedTimeSeconds":11,"totalLines":0,"timeoutMs":120000},"toolUseID":"bash-progress-9","parentToolUseID":"toolu_01XHXjvfeBG5aiqaoGZjBCRx","uuid":"84ac7ac0-3d5b-4cd6-b1ab-1d69d78b51ad","timestamp":"2026-02-10T23:26:13.810Z"}
{"parentUuid":"84ac7ac0-3d5b-4cd6-b1ab-1d69d78b51ad","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"progress","data":{"type":"bash_progress","output":"","fullOutput":"","elapsedTimeSeconds":12,"totalLines":0,"timeoutMs":120000},"toolUseID":"bash-progress-10","parentToolUseID":"toolu_01XHXjvfeBG5aiqaoGZjBCRx","uuid":"83b794e0-b107-4089-8e3f-3d6e3d45a952","timestamp":"2026-02-10T23:26:14.812Z"}
{"parentUuid":"83b794e0-b107-4089-8e3f-3d6e3d45a952","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"progress","data":{"type":"bash_progress","output":"","fullOutput":"","elapsedTimeSeconds":13,"totalLines":0,"timeoutMs":120000},"toolUseID":"bash-progress-11","parentToolUseID":"toolu_01XHXjvfeBG5aiqaoGZjBCRx","uuid":"61a8db12-8d55-46c7-8f2b-00656b7cb390","timestamp":"2026-02-10T23:26:15.814Z"}
{"parentUuid":"61a8db12-8d55-46c7-8f2b-00656b7cb390","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"progress","data":{"type":"bash_progress","output":"","fullOutput":"","elapsedTimeSeconds":14,"totalLines":0,"timeoutMs":120000},"toolUseID":"bash-progress-12","parentToolUseID":"toolu_01XHXjvfeBG5aiqaoGZjBCRx","uuid":"ed70475c-de82-41d3-ba3d-ed1f59fc7b83","timestamp":"2026-02-10T23:26:16.815Z"}
{"parentUuid":"ed70475c-de82-41d3-ba3d-ed1f59fc7b83","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"progress","data":{"type":"bash_progress","output":"","fullOutput":"","elapsedTimeSeconds":15,"totalLines":0,"timeoutMs":120000},"toolUseID":"bash-progress-13","parentToolUseID":"toolu_01XHXjvfeBG5aiqaoGZjBCRx","uuid":"466bbe1a-c37e-4182-8c5a-7def67883e13","timestamp":"2026-02-10T23:26:17.817Z"}
{"parentUuid":"466bbe1a-c37e-4182-8c5a-7def67883e13","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"progress","data":{"type":"bash_progress","output":"","fullOutput":"","elapsedTimeSeconds":16,"totalLines":0,"timeoutMs":120000},"toolUseID":"bash-progress-14","parentToolUseID":"toolu_01XHXjvfeBG5aiqaoGZjBCRx","uuid":"d7311179-f0b1-4abe-b00a-9307f09a0071","timestamp":"2026-02-10T23:26:18.819Z"}
{"parentUuid":"d7311179-f0b1-4abe-b00a-9307f09a0071","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"progress","data":{"type":"bash_progress","output":"","fullOutput":"","elapsedTimeSeconds":17,"totalLines":0,"timeoutMs":120000},"toolUseID":"bash-progress-15","parentToolUseID":"toolu_01XHXjvfeBG5aiqaoGZjBCRx","uuid":"e7b25a36-005d-4f68-8a14-4d0046857642","timestamp":"2026-02-10T23:26:19.820Z"}
{"parentUuid":"e7b25a36-005d-4f68-8a14-4d0046857642","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"progress","data":{"type":"bash_progress","output":"","fullOutput":"","elapsedTimeSeconds":18,"totalLines":0,"timeoutMs":120000},"toolUseID":"bash-progress-16","parentToolUseID":"toolu_01XHXjvfeBG5aiqaoGZjBCRx","uuid":"3c3cb7bf-69aa-49b7-b237-46d9331ee380","timestamp":"2026-02-10T23:26:20.823Z"}
{"parentUuid":"3c3cb7bf-69aa-49b7-b237-46d9331ee380","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"progress","data":{"type":"bash_progress","output":"","fullOutput":"","elapsedTimeSeconds":19,"totalLines":0,"timeoutMs":120000},"toolUseID":"bash-progress-17","parentToolUseID":"toolu_01XHXjvfeBG5aiqaoGZjBCRx","uuid":"9acdc954-746a-4cf5-96cd-9459867a79ef","timestamp":"2026-02-10T23:26:21.826Z"}
{"parentUuid":"9acdc954-746a-4cf5-96cd-9459867a79ef","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"progress","data":{"type":"bash_progress","output":"","fullOutput":"","elapsedTimeSeconds":20,"totalLines":0,"timeoutMs":120000},"toolUseID":"bash-progress-18","parentToolUseID":"toolu_01XHXjvfeBG5aiqaoGZjBCRx","uuid":"75097abe-4b5c-4ae9-8db3-ba60cbdfbb9e","timestamp":"2026-02-10T23:26:22.827Z"}
{"parentUuid":"75097abe-4b5c-4ae9-8db3-ba60cbdfbb9e","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"progress","data":{"type":"bash_progress","output":"","fullOutput":"","elapsedTimeSeconds":21,"totalLines":0,"timeoutMs":120000},"toolUseID":"bash-progress-19","parentToolUseID":"toolu_01XHXjvfeBG5aiqaoGZjBCRx","uuid":"c1ef7ad9-6b69-4511-affa-d131306f339d","timestamp":"2026-02-10T23:26:23.830Z"}
{"parentUuid":"c1ef7ad9-6b69-4511-affa-d131306f339d","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"progress","data":{"type":"bash_progress","output":"","fullOutput":"","elapsedTimeSeconds":22,"totalLines":0,"timeoutMs":120000},"toolUseID":"bash-progress-20","parentToolUseID":"toolu_01XHXjvfeBG5aiqaoGZjBCRx","uuid":"b0a7ad6a-2fc2-404c-a92d-cfa1fcfa3dfa","timestamp":"2026-02-10T23:26:24.831Z"}
{"parentUuid":"b0a7ad6a-2fc2-404c-a92d-cfa1fcfa3dfa","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"progress","data":{"type":"bash_progress","output":"","fullOutput":"","elapsedTimeSeconds":23,"totalLines":0,"timeoutMs":120000},"toolUseID":"bash-progress-21","parentToolUseID":"toolu_01XHXjvfeBG5aiqaoGZjBCRx","uuid":"43961b7b-e497-4311-b5c5-faababda1e0c","timestamp":"2026-02-10T23:26:25.830Z"}
{"parentUuid":"43961b7b-e497-4311-b5c5-faababda1e0c","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"progress","data":{"type":"bash_progress","output":"","fullOutput":"","elapsedTimeSeconds":24,"totalLines":0,"timeoutMs":120000},"toolUseID":"bash-progress-22","parentToolUseID":"toolu_01XHXjvfeBG5aiqaoGZjBCRx","uuid":"bdfe3d9a-c7e5-46fe-abfc-9ca8585dce4d","timestamp":"2026-02-10T23:26:26.833Z"}
{"parentUuid":"bdfe3d9a-c7e5-46fe-abfc-9ca8585dce4d","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"progress","data":{"type":"bash_progress","output":"","fullOutput":"","elapsedTimeSeconds":25,"totalLines":0,"timeoutMs":120000},"toolUseID":"bash-progress-23","parentToolUseID":"toolu_01XHXjvfeBG5aiqaoGZjBCRx","uuid":"458ee40e-e906-43bd-94eb-2ba6bcaea785","timestamp":"2026-02-10T23:26:27.835Z"}
{"parentUuid":"458ee40e-e906-43bd-94eb-2ba6bcaea785","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"progress","data":{"type":"bash_progress","output":"","fullOutput":"","elapsedTimeSeconds":26,"totalLines":0,"timeoutMs":120000},"toolUseID":"bash-progress-24","parentToolUseID":"toolu_01XHXjvfeBG5aiqaoGZjBCRx","uuid":"c7ac667c-42b3-4976-b0b6-797741d9e15f","timestamp":"2026-02-10T23:26:28.842Z"}
{"parentUuid":"c7ac667c-42b3-4976-b0b6-797741d9e15f","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"progress","data":{"type":"bash_progress","output":"","fullOutput":"","elapsedTimeSeconds":27,"totalLines":0,"timeoutMs":120000},"toolUseID":"bash-progress-25","parentToolUseID":"toolu_01XHXjvfeBG5aiqaoGZjBCRx","uuid":"8c046492-dbed-4b63-bc59-300bd09a7428","timestamp":"2026-02-10T23:26:29.843Z"}
{"parentUuid":"8c046492-dbed-4b63-bc59-300bd09a7428","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"progress","data":{"type":"bash_progress","output":"","fullOutput":"","elapsedTimeSeconds":28,"totalLines":0,"timeoutMs":120000},"toolUseID":"bash-progress-26","parentToolUseID":"toolu_01XHXjvfeBG5aiqaoGZjBCRx","uuid":"3e6763cd-75a3-40c2-bc40-c6d20555f561","timestamp":"2026-02-10T23:26:30.846Z"}
{"parentUuid":"3e6763cd-75a3-40c2-bc40-c6d20555f561","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"progress","data":{"type":"bash_progress","output":"","fullOutput":"","elapsedTimeSeconds":29,"totalLines":0,"timeoutMs":120000},"toolUseID":"bash-progress-27","parentToolUseID":"toolu_01XHXjvfeBG5aiqaoGZjBCRx","uuid":"a25ef8c2-b324-4895-82d6-08ce7a047559","timestamp":"2026-02-10T23:26:31.849Z"}
{"parentUuid":"a25ef8c2-b324-4895-82d6-08ce7a047559","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"progress","data":{"type":"bash_progress","output":"","fullOutput":"","elapsedTimeSeconds":30,"totalLines":0,"timeoutMs":120000},"toolUseID":"bash-progress-28","parentToolUseID":"toolu_01XHXjvfeBG5aiqaoGZjBCRx","uuid":"8603cac4-b686-429e-bb53-67e95ea558fe","timestamp":"2026-02-10T23:26:32.850Z"}
{"parentUuid":"8603cac4-b686-429e-bb53-67e95ea558fe","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"progress","data":{"type":"bash_progress","output":"","fullOutput":"","elapsedTimeSeconds":31,"totalLines":0,"timeoutMs":120000},"toolUseID":"bash-progress-29","parentToolUseID":"toolu_01XHXjvfeBG5aiqaoGZjBCRx","uuid":"75e92417-b1db-42bd-a922-0c717ec5596a","timestamp":"2026-02-10T23:26:33.850Z"}
{"parentUuid":"8d2606b7-644b-4312-8fc6-7a28231c497b","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01XHXjvfeBG5aiqaoGZjBCRx","type":"tool_result","content":"  Enable tracemalloc to get traceback where the object was allocated.\n  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.\n\n-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html\n1657 passed, 4 warnings in 30.66s","is_error":false}]},"uuid":"c8825f4c-4151-462d-9184-4605bba22152","timestamp":"2026-02-10T23:26:34.395Z","toolUseResult":{"stdout":"  Enable tracemalloc to get traceback where the object was allocated.\n  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.\n\n-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html\n1657 passed, 4 warnings in 30.66s","stderr":"","interrupted":false,"isImage":false,"noOutputExpected":false},"sourceToolAssistantUUID":"8d2606b7-644b-4312-8fc6-7a28231c497b"}
{"parentUuid":"c8825f4c-4151-462d-9184-4605bba22152","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","message":{"model":"claude-opus-4-6","id":"msg_01CbuVUkA9yBbEmh7ssNMvTj","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01MrYpNYTiBT3eva5DvLRNJL","name":"TaskUpdate","input":{"taskId":"6","status":"completed"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":224,"cache_read_input_tokens":85328,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":224},"output_tokens":26,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CY1Ffs8mt5iHQmT29kkab","type":"assistant","uuid":"c7659726-4120-47c1-bfeb-4b712617a663","timestamp":"2026-02-10T23:26:37.971Z"}
{"parentUuid":"c7659726-4120-47c1-bfeb-4b712617a663","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01MrYpNYTiBT3eva5DvLRNJL","type":"tool_result","content":"Updated task #6 status"}]},"uuid":"918b3ae9-bcdd-4553-9672-b5f7d90226dd","timestamp":"2026-02-10T23:26:37.976Z","toolUseResult":{"success":true,"taskId":"6","updatedFields":["status"],"statusChange":{"from":"in_progress","to":"completed"}},"sourceToolAssistantUUID":"c7659726-4120-47c1-bfeb-4b712617a663"}
{"parentUuid":"918b3ae9-bcdd-4553-9672-b5f7d90226dd","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","message":{"model":"claude-opus-4-6","id":"msg_01BmrCMioQDJB6QqF8xMZo2Q","type":"message","role":"assistant","content":[{"type":"text","text":"All done. Here's a summary of the changes:\n\n**`src/lws/parser/assembly.py`**\n- Added `SsmParameter` and `SmSecret` dataclasses\n- Added `ssm_parameters` and `secrets` fields to `AppModel`\n- Added `_collect_ssm_parameters()` and `_collect_secrets()` collector functions\n- Wired collectors into `_process_stack()`\n- Added SSM/SecretsManager Ref resolution to `_build_resource_map()` (refactored to dispatch table to stay under complexity limit)\n\n**`src/lws/parser/tree_parser.py`**\n- Added `aws-cdk-lib.aws_ssm.StringParameter` and `aws-cdk-lib.aws_secretsmanager.Secret` to `FQN_CATEGORY_MAP`\n\n**`src/lws/providers/ssm/routes.py`**\n- `create_ssm_app()` now accepts `initial_parameters: list[dict] | None` and pre-seeds state\n\n**`src/lws/providers/secretsmanager/routes.py`**\n- `create_secretsmanager_app()` now accepts `initial_secrets: list[dict] | None` and pre-seeds state with secret versions\n\n**`src/lws/cli/ldk.py`**\n- CDK mode `_create_providers()` now passes parsed SSM/SecretsManager data to the app factories\n- Added SSM parameters and secrets to `_collect_extra_resources()`, `_add_resource_details()`, `_has_any_resources()`, and `_add_service_metadata()`\n\nAll 1657 tests pass, ruff lint clean on all modified files."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":88,"cache_read_input_tokens":85552,"output_tokens":412,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":88,"ephemeral_5m_input_tokens":0},"inference_geo":"","iterations":[]}},"requestId":"req_011CY1Fg8QYPQEW34bjTKGYb","type":"assistant","uuid":"347daf3a-3229-473a-a52e-2cf10892306b","timestamp":"2026-02-10T23:26:47.888Z"}
{"parentUuid":"347daf3a-3229-473a-a52e-2cf10892306b","isSidechain":false,"userType":"external","cwd":"/Users/eamonnfaherty/Development/github.com/local-web-services/local-web-services","sessionId":"1b68b70d-d8a7-4039-a173-05eca81837b4","version":"2.1.38","gitBranch":"feat/ssm-secretsmanager-v0.4.0","slug":"sorted-churning-garden","type":"progress","data":{"type":"hook_progress","hookEvent":"Stop","hookName":"Stop","command":"entire hooks claude-code stop"},"parentToolUseID":"fd1673c4-8c5c-4d15-ba94-d92d455ca73c","toolUseID":"fd1673c4-8c5c-4d15-ba94-d92d455ca73c","timestamp":"2026-02-10T23:26:47.895Z","uuid":"923ba2e3-dd7d-4179-a767-77f8cb321893"}
